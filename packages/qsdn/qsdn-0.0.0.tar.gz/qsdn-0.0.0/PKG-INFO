Metadata-Version: 2.1
Name: qsdn
Version: 0.0.0
Summary: Python Qt5 Classes that Display and Parse Numbers using Standard Decimal Notation
Home-page: https://github.com/shawnpringle/separatorsafterdecimal
Author: Shawn.Pringle
Author-email: shawn.pringle@gmail.com
License: UNKNOWN
Download-URL: https://github.com/shawnpringle/separatorsafterdecimal/archive/v0.0.0.tar.gz
Description: Welcome to Standard Decimal Notation's documentation!
        *****************************************************
        
        Contents:
        
        ... module:: qsdn
           platform:
              Unix, Windows
        
           synopsis:
              This module allows for parsing, validation and production of
              numeric literals, written with thousand separators through out
              the number.  Often underlying system libraries for working with
              locales neglect to put thousand separators (commas) after the
              decimal place or they sometimes use scientific notation.  The
              classes inherit from the Qt classes for making things less
              complex.
        
           Thousand separators in general will not always be commas but
           instead will be different according to the locale settings.  In
           Windows for example, the user can set his thousand separator to any
           character.  Support for converting strings directly to Decimals and
           from Decimals to strings is included.
        
           Also, numbers are always expressed in standard decimal notation.
        
           Care has been taken to overload all of the members in a way that is
           consistent with the base class QLocale and QValidator.
        
           This module requires PyQt5.  It is presently only tested with
           Microsoft Windows.  Users from other platforms are invited to join
           my team and submit pull-requests to ensure correct functioning.  If
           KDE and PyKDE are installed on your system, KDE's settings for
           thousands separator and decimal symbol will be used.  Otherwise the
           system's locale settings will be used to determine these values.
        
        class qsdn.Locale(_name=None, p_mandatory_decimals=Decimal('0'), p_maximum_decimals=Decimal('Infinity'))
        
           For a Locale, locale:
                 Main benefit is numbers converted to a string are always
                 converted to standard decimal notation.  And you control how
                 far numbers are written before they are truncated.  Another
                 benefit is it works with decimal.Decimal numbers natively.
                 So numbers get converted directly from String to Decimal and
                 vice versa.
        
              To construct one, you can supply a name of a locale and specify
              the mandatory and maximum digits after the decimal point.
        
              locale = Locale("en_US", 2, 3) locale.toString(4) is '4.00'
              locale.toString(4.01) is '4.01' locale.toString(1/3) is '0.333'
        
              To specify the language and script, pass in a QLocale to the
              constructor: like this: qlocale  = QLocale('en_US',
              QLocale.Latin, QLocale.Spanish) sdnlocale = Locale(qlocale, 2,
              3)
        
                 To get the Decimal of a string, s, use:
        
                 (d, ok) = locale.toDecimal(s, 10)
        
                 The value d is your decimal, and you should check ok before
                 you trust d.
        
                 To get the string representation use:
        
                 s = locale.toString(d)
        
              All to* routines take a string, and an optional base.  If the
              base is set to zero, it will look at the first digits of the
              number to determine  base it should use.  So, '013' will be
              interpreted as 11 (as 0 indicates octal form) unless you set the
              base to 10, in which as it will be interpreted as 13. You can
              use '0x' to prefix hexadecimal numbers.  Some developers don't
              want to expose this programming concept to the users of thier
              software.  For those who don't specify the base explicitly as
              10.  As of 1.0.0, the base defaults to 10, because the new
              behavior as of PyQt5 in the QLocale class is to always  have the
              base fixed as 10.
        
                 By default Locale will use the settings specified in your
                 default locale.  This is guaranteed to be true for Mac OS,
                 Windows and KDE-GUIs.
        
           static c()
        
              Returns the C locale.  In the C locale, to* routines will not
              accept group separtors and do not produce them.
        
           static setDefault(QLocale)
        
           static system()
        
              Returns the system default for Locale.
        
           toDecimal(s, *, base=10)
        
              This creates a decimal representation of s.
        
                    It returns an ordered pair.  The first of the pair is the
                    Decimal number, the second of the pair indicates whether
                    the string had a valid representation of that number.  You
                    should always check the second of the ordered pair before
                    using the decimal returned.
        
                 It returns an ordered pair.  The first of the pair is the
                 number, the second of the pair indicates whether the string
                 had a valid representation of that number.  You should always
                 check the second of the ordered pair before using the number
                 returned.
        
                    note:
                       You may set another parameter, the base, so you can
                       interpret the string as 8 for octal, 16 for hex, 2 for
                       binary.
        
                 If base is set to 0, numbers such as '0777' will be
                 interpreted as octal.  The string '0x33' will be interpreted
                 as hexadecimal and '777' will be interpreted as a decimal.
        
              Like the other to* functions of QLocale as well as this class
              Locale, interpret a
                 a string and parse it and return a Decimal.  The base value
                 is used to determine what base to use. It is done this way so
                 this works like toLong, toInt, toFloat, etc... Leading and
                 trailing whitespace is ignored.
        
           toDouble(s, *, base=10)
        
              Parses the string s and returns a floating point value whose
              string is s.
        
              It returns an ordered pair.  The first of the pair is the
              number, the second of the pair indicates whether the string had
              a valid representation of that number.  You should always check
              the second of the ordered pair before using the number returned.
        
                 note:
                    You may set another parameter, the base, so you can
                    interpret the string as 8 for octal, 16 for hex, 2 for
                    binary.
        
              If base is set to 0, numbers such as '0777' will be interpreted
              as octal.  The string '0x33' will be interpreted as hexadecimal
              and '777' will be interpreted as a decimal.
        
                 It returns an ordered pair.  The first of the pair is the
                 number, the second of the pair indicates whether the string
                 had a valid representation of that number.  You should always
                 check the second of the ordered pair before using the number
                 returned.
        
           toFloat(s, *, base=10)
        
              Parses the string s and returns a floating point value whose
              string is s.
        
              It returns an ordered pair.  The first of the pair is the
              number, the second of the pair indicates whether the string had
              a valid representation of that number.  You should always check
              the second of the ordered pair before using the number returned.
        
                 note:
                    You may set another parameter, the base, so you can
                    interpret the string as 8 for octal, 16 for hex, 2 for
                    binary.
        
              If base is set to 0, numbers such as '0777' will be interpreted
              as octal.  The string '0x33' will be interpreted as hexadecimal
              and '777' will be interpreted as a decimal.
        
           toInt(s, *, base=10)
        
              Parses the string s and returns an integer value whose string is
              s.
        
              It returns an ordered pair.  The first of the pair is the
              number, the second of the pair indicates whether the string had
              a valid representation of that number.  You should always check
              the second of the ordered pair before using the number returned.
        
                 note:
                    You may set another parameter, the base, so you can
                    interpret the string as 8 for octal, 16 for hex, 2 for
                    binary.
        
              If base is set to 0, numbers such as '0777' will be interpreted
              as octal.  The string '0x33' will be interpreted as hexadecimal
              and '777' will be interpreted as a decimal.
        
           toLongLong(s, *, base=10)
        
              Parses the string s and returns a floating point value whose
              string is s.
        
              It returns an ordered pair.  The first of the pair is the
              number, the second of the pair indicates whether the string had
              a valid representation of that number.  You should always check
              the second of the ordered pair before using the number returned.
        
                 note:
                    You may set another parameter, the base, so you can
                    interpret the string as 8 for octal, 16 for hex, 2 for
                    binary.
        
              If base is set to 0, numbers such as '0777' will be interpreted
              as octal.  The string '0x33' will be interpreted as hexadecimal
              and '777' will be interpreted as a decimal.
        
              Leading and trailing whitespace is ignored.
        
           toShort(s, *, base=10)
        
              Parses the string s and returns a short value whose string is s.
        
              It returns an ordered pair.  The first of the pair is the
              number, the second of the pair indicates whether the string had
              a valid representation of that number.  You should always check
              the second of the ordered pair before using the number returned.
        
                 note:
                    You may set another parameter, the base, so you can
                    interpret the string as 8 for octal, 16 for hex, 2 for
                    binary.
        
              If base is set to 0, numbers such as '0777' will be interpreted
              as octal.  The string '0x33' will be interpreted as hexadecimal
              and '777' will be interpreted as a decimal.
        
              Leading and trailing whitespace is ignored.
        
           toString(x, arg2=None, arg3=None)
        
              Convert any given Decimal, double, Date, Time, int or long to a
              string.
        
              Numbers are always converted to Standard decimal notation.  That
              is to say, numbers are never converted to scientifc notation.
        
              The way toString is controlled: If passing a decimal.Decimal
              typed value, the precision is recorded in the  number itself.
              So, D('4.00') will be expressed as '4.00' and not '4'. D('4')
              will be expressed as '4'.
        
              When a number passed is NOT a Decimal, numbers are created in
              the following way: Two extra parameters, set during creation of
              the locale, determines how  many digits will appear in the
              result of toString(). For example, we have a number like 5.1 and
              mandatory decimals was set    to 2, toString(5.1) should return
              '5.10'.  A number like 6 would be '6.00'. A number like 5.104
              would depend on the maximum decimals setting, also  set at
              construction of the locale: _maximum_decimals controls the
              maximum number of decimals after the decimal point So, if
              _maximum_decimals is 6 and _mandatory_decimals is 2 then
              toString(3.1415929) is '3.141,592'. Notice the number is
              truncated and not rounded.   Consider rounding a copy of the
              number before displaying.
        
           toUInt(s, *, base=10)
        
              Parses the string s and returns an unsigned integer value whose
              string is s.
        
              It returns an ordered pair.  The first of the pair is the
              number, the second of the pair indicates whether the string had
              a valid representation of that number.  You should always check
              the second of the ordered pair before using the number returned.
        
                 note:
                    You may set another parameter, the base (which defaults to
                    10), so you can interpret the string as 8 for octal, 16
                    for hex, 2 for binary.
        
              If base is set to 0, numbers such as '0777' will be interpreted
              as octal.  The string '0x33' will be interpreted as hexadecimal
              and '777' will be interpreted as a decimal.
        
              Leading and trailing whitespace is ignored.
        
           toULongLong(s, base=10)
        
              Parses the string s and returns an unsigned long long value
              whose string is s.
        
              It returns an ordered pair.  The first of the pair is the
              number, the second of the pair indicates whether the string had
              a valid representation of that number.  You should always check
              the second of the ordered pair before using the number returned.
        
                 note:
                    You may set another parameter, the base, so you can
                    interpret the string as 8 for octal, 16 for hex, 2 for
                    binary.
        
              If base is set to 0, numbers such as '0777' will be interpreted
              as octal.  The string '0x33' will be interpreted as hexadecimal
              and '777' will be interpreted as a decimal.
        
              Leading and trailing whitespace is ignored.
        
           toUShort(s, base=10)
        
              Parses the string s and returns a unsigned long long value whose
              string is s.
        
              It returns an ordered pair.  The first of the pair is the
              number, the second of the pair indicates whether the string had
              a valid representation of that number.  You should always check
              the second of the ordered pair before using the number returned.
        
                 note:
                    You may set another parameter, the base, so you can
                    interpret the string as 8 for octal, 16 for hex, 2 for
                    binary.
        
              If base is set to 0, numbers such as '0777' will be interpreted
              as octal.  The string '0x33' will be interpreted as hexadecimal
              and '777' will be interpreted as a decimal.
        
              Leading and trailing whitespace is ignored.
        
        class qsdn.NumericValidator(parent=None)
        
           NumericValidator allows for numbers of any length but
           groupSeparators are added or corrected when missing or out of
           place.
        
           U.S. dollar amounts;
              dollar = NumericValidator(6,2) s = '42.1'
              dollar.validate(s='42.1', 2)   =>  s = '42.10' s='50000'
              dollar.toString(s)                       => s = ' 50,000.00'
        
           locale()
        
              get the locale used by this validator
        
           setLocale(plocale)
        
              Set the locale used by this Validator.
        
           validate(self, str, int) -> Tuple[QValidator.State, str, int]
        
        class qsdn.LimitingNumericValidator(maximum_decamals=1000, maximum_decimals=1000, use_space=False, parent=None)
        
           NumericValidator limits the number of digits after the decimal
           point and the number of digits before.
        
              bitcoin                                                :
              NumericValidator(8, 8) US dollars less than $1,000,000 :
              NumericValidator(6, 2)
        
              If use space is true, spaces are added on the left such that the
              location of decimal point remains constant.  Numbers like
              '10,000.004', '102.126' become  aligned. Bitcoin amounts:
        
                 '              0.004,3' '         10.4' '        320.0' '
                 0.000,004'
        
              U.S. dollar amounts;
                 dollar = NumericValidator(6,2) s = '42.1'
                 dollar.validate(s='42.1', 2)   =>  s = '        42.10'
                 s='50000' dollar.toString(s)                       => s = '
                 50,000.00'
        
           decamals()
        
              gets the number of decimal digits that are allowed **before**
              the decimal point (apart from spaces)
        
           decimals()
        
              gets the number of decimal digits that are allowed *after* the
              decimal point
        
           locale()
        
              get the locale used by this validator
        
           setDecamals(i)
        
              sets the number of decimal digits that should be allowed
              **before** the decimal point
        
           setDecimals(i)
        
              sets the number of decimal digits that should be allowed
              **after** the decimal point
        
           setLocale(plocale)
        
              Set the locale used by this Validator.
        
           validate(s, pos)
        
              Validates s, by adjusting the position of the commas to be in
              the correct places and adjusting pos accordingly as well as
              space in order to keep decimal points aligned when varying sized
              numbers are put one above the other.
        
        
        Indices and tables
        ******************
        
        * Index
        
        * Module Index
        
        * Search Page
        
Platform: UNKNOWN
Classifier: Programming Language :: Python :: 3
Classifier: License :: OSI Approved :: MIT License
Classifier: Operating System :: OS Independent
Description-Content-Type: text/plain
