Metadata-Version: 2.1
Name: qsdn
Version: 0.0.0
Summary: Python Qt5 Classes that Display and Parse Numbers using Standard Decimal Notation
Home-page: https://github.com/shawnpringle/separatorsafterdecimal
Author: Shawn.Pringle
Author-email: shawn.pringle@gmail.com
License: UNKNOWN
Download-URL: https://github.com/shawnpringle/separatorsafterdecimal/archive/v0.0.0.tar.gz
Platform: UNKNOWN
Classifier: Programming Language :: Python :: 3
Classifier: License :: OSI Approved :: MIT License
Classifier: Operating System :: OS Independent
Description-Content-Type: text/plain
Requires-Dist: PyQt5

Welcome to Standard Decimal Notation's documentation!
*****************************************************

Contents:

... module:: qsdn
   platform:
      Unix, Windows

   synopsis:
      This module allows for parsing, validation and production of
      numeric literals, written with thousand separators through out
      the number.  Often underlying system libraries for working with
      locales neglect to put thousand separators (commas) after the
      decimal place or they sometimes use scientific notation.  The
      classes inherit from the Qt classes for making things less
      complex.

   Thousand separators in general will not always be commas but
   instead will be different according to the locale settings.  In
   Windows for example, the user can set his thousand separator to any
   character.  Support for converting strings directly to Decimals and
   from Decimals to strings is included.

   Also, numbers are always expressed in standard decimal notation.

   Care has been taken to overload all of the members in a way that is
   consistent with the base class QLocale and QValidator.

   This module requires PyQt5.  It is presently only tested with
   Microsoft Windows.  Users from other platforms are invited to join
   my team and submit pull-requests to ensure correct functioning.  If
   KDE and PyKDE are installed on your system, KDE's settings for
   thousands separator and decimal symbol will be used.  Otherwise the
   system's locale settings will be used to determine these values.

class qsdn.Locale(_name=None, p_mandatory_decimals=Decimal('0'), p_maximum_decimals=Decimal('Infinity'))

   For a Locale, locale:
         Main benefit is numbers converted to a string are always
         converted to standard decimal notation.  And you control how
         far numbers are written before they are truncated.  Another
         benefit is it works with decimal.Decimal numbers natively.
         So numbers get converted directly from String to Decimal and
         vice versa.

      To construct one, you can supply a name of a locale and specify
      the mandatory and maximum digits after the decimal point.

      locale = Locale("en_US", 2, 3) locale.toString(4) is '4.00'
      locale.toString(4.01) is '4.01' locale.toString(1/3) is '0.333'

      To specify the language and script, pass in a QLocale to the
      constructor: like this: qlocale  = QLocale('en_US',
      QLocale.Latin, QLocale.Spanish) sdnlocale = Locale(qlocale, 2,
      3)

         To get the Decimal of a string, s, use:

         (d, ok) = locale.toDecimal(s, 10)

         The value d is your decimal, and you should check ok before
         you trust d.

         To get the string representation use:

         s = locale.toString(d)

      All to* routines take a string, and an optional base.  If the
      base is set to zero, it will look at the first digits of the
      number to determine  base it should use.  So, '013' will be
      interpreted as 11 (as 0 indicates octal form) unless you set the
      base to 10, in which as it will be interpreted as 13. You can
      use '0x' to prefix hexadecimal numbers.  Some developers don't
      want to expose this programming concept to the users of thier
      software.  For those who don't specify the base explicitly as
      10.  As of 1.0.0, the base defaults to 10, because the new
      behavior as of PyQt5 in the QLocale class is to always  have the
      base fixed as 10.

         By default Locale will use the settings specified in your
         default locale.  This is guaranteed to be true for Mac OS,
         Windows and KDE-GUIs.

   static c()

      Returns the C locale.  In the C locale, to* routines will not
      accept group separtors and do not produce them.

   static setDefault(QLocale)

   static system()

      Returns the system default for Locale.

   toDecimal(s, *, base=10)

      This creates a decimal representation of s.

            It returns an ordered pair.  The first of the pair is the
            Decimal number, the second of the pair indicates whether
            the string had a valid representation of that number.  You
            should always check the second of the ordered pair before
            using the decimal returned.

         It returns an ordered pair.  The first of the pair is the
         number, the second of the pair indicates whether the string
         had a valid representation of that number.  You should always
         check the second of the ordered pair before using the number
         returned.

            note:
               You may set another parameter, the base, so you can
               interpret the string as 8 for octal, 16 for hex, 2 for
               binary.

         If base is set to 0, numbers such as '0777' will be
         interpreted as octal.  The string '0x33' will be interpreted
         as hexadecimal and '777' will be interpreted as a decimal.

      Like the other to* functions of QLocale as well as this class
      Locale, interpret a
         a string and parse it and return a Decimal.  The base value
         is used to determine what base to use. It is done this way so
         this works like toLong, toInt, toFloat, etc... Leading and
         trailing whitespace is ignored.

   toDouble(s, *, base=10)

      Parses the string s and returns a floating point value whose
      string is s.

      It returns an ordered pair.  The first of the pair is the
      number, the second of the pair indicates whether the string had
      a valid representation of that number.  You should always check
      the second of the ordered pair before using the number returned.

         note:
            You may set another parameter, the base, so you can
            interpret the string as 8 for octal, 16 for hex, 2 for
            binary.

      If base is set to 0, numbers such as '0777' will be interpreted
      as octal.  The string '0x33' will be interpreted as hexadecimal
      and '777' will be interpreted as a decimal.

         It returns an ordered pair.  The first of the pair is the
         number, the second of the pair indicates whether the string
         had a valid representation of that number.  You should always
         check the second of the ordered pair before using the number
         returned.

   toFloat(s, *, base=10)

      Parses the string s and returns a floating point value whose
      string is s.

      It returns an ordered pair.  The first of the pair is the
      number, the second of the pair indicates whether the string had
      a valid representation of that number.  You should always check
      the second of the ordered pair before using the number returned.

         note:
            You may set another parameter, the base, so you can
            interpret the string as 8 for octal, 16 for hex, 2 for
            binary.

      If base is set to 0, numbers such as '0777' will be interpreted
      as octal.  The string '0x33' will be interpreted as hexadecimal
      and '777' will be interpreted as a decimal.

   toInt(s, *, base=10)

      Parses the string s and returns an integer value whose string is
      s.

      It returns an ordered pair.  The first of the pair is the
      number, the second of the pair indicates whether the string had
      a valid representation of that number.  You should always check
      the second of the ordered pair before using the number returned.

         note:
            You may set another parameter, the base, so you can
            interpret the string as 8 for octal, 16 for hex, 2 for
            binary.

      If base is set to 0, numbers such as '0777' will be interpreted
      as octal.  The string '0x33' will be interpreted as hexadecimal
      and '777' will be interpreted as a decimal.

   toLongLong(s, *, base=10)

      Parses the string s and returns a floating point value whose
      string is s.

      It returns an ordered pair.  The first of the pair is the
      number, the second of the pair indicates whether the string had
      a valid representation of that number.  You should always check
      the second of the ordered pair before using the number returned.

         note:
            You may set another parameter, the base, so you can
            interpret the string as 8 for octal, 16 for hex, 2 for
            binary.

      If base is set to 0, numbers such as '0777' will be interpreted
      as octal.  The string '0x33' will be interpreted as hexadecimal
      and '777' will be interpreted as a decimal.

      Leading and trailing whitespace is ignored.

   toShort(s, *, base=10)

      Parses the string s and returns a short value whose string is s.

      It returns an ordered pair.  The first of the pair is the
      number, the second of the pair indicates whether the string had
      a valid representation of that number.  You should always check
      the second of the ordered pair before using the number returned.

         note:
            You may set another parameter, the base, so you can
            interpret the string as 8 for octal, 16 for hex, 2 for
            binary.

      If base is set to 0, numbers such as '0777' will be interpreted
      as octal.  The string '0x33' will be interpreted as hexadecimal
      and '777' will be interpreted as a decimal.

      Leading and trailing whitespace is ignored.

   toString(x, arg2=None, arg3=None)

      Convert any given Decimal, double, Date, Time, int or long to a
      string.

      Numbers are always converted to Standard decimal notation.  That
      is to say, numbers are never converted to scientifc notation.

      The way toString is controlled: If passing a decimal.Decimal
      typed value, the precision is recorded in the  number itself.
      So, D('4.00') will be expressed as '4.00' and not '4'. D('4')
      will be expressed as '4'.

      When a number passed is NOT a Decimal, numbers are created in
      the following way: Two extra parameters, set during creation of
      the locale, determines how  many digits will appear in the
      result of toString(). For example, we have a number like 5.1 and
      mandatory decimals was set    to 2, toString(5.1) should return
      '5.10'.  A number like 6 would be '6.00'. A number like 5.104
      would depend on the maximum decimals setting, also  set at
      construction of the locale: _maximum_decimals controls the
      maximum number of decimals after the decimal point So, if
      _maximum_decimals is 6 and _mandatory_decimals is 2 then
      toString(3.1415929) is '3.141,592'. Notice the number is
      truncated and not rounded.   Consider rounding a copy of the
      number before displaying.

   toUInt(s, *, base=10)

      Parses the string s and returns an unsigned integer value whose
      string is s.

      It returns an ordered pair.  The first of the pair is the
      number, the second of the pair indicates whether the string had
      a valid representation of that number.  You should always check
      the second of the ordered pair before using the number returned.

         note:
            You may set another parameter, the base (which defaults to
            10), so you can interpret the string as 8 for octal, 16
            for hex, 2 for binary.

      If base is set to 0, numbers such as '0777' will be interpreted
      as octal.  The string '0x33' will be interpreted as hexadecimal
      and '777' will be interpreted as a decimal.

      Leading and trailing whitespace is ignored.

   toULongLong(s, base=10)

      Parses the string s and returns an unsigned long long value
      whose string is s.

      It returns an ordered pair.  The first of the pair is the
      number, the second of the pair indicates whether the string had
      a valid representation of that number.  You should always check
      the second of the ordered pair before using the number returned.

         note:
            You may set another parameter, the base, so you can
            interpret the string as 8 for octal, 16 for hex, 2 for
            binary.

      If base is set to 0, numbers such as '0777' will be interpreted
      as octal.  The string '0x33' will be interpreted as hexadecimal
      and '777' will be interpreted as a decimal.

      Leading and trailing whitespace is ignored.

   toUShort(s, base=10)

      Parses the string s and returns a unsigned long long value whose
      string is s.

      It returns an ordered pair.  The first of the pair is the
      number, the second of the pair indicates whether the string had
      a valid representation of that number.  You should always check
      the second of the ordered pair before using the number returned.

         note:
            You may set another parameter, the base, so you can
            interpret the string as 8 for octal, 16 for hex, 2 for
            binary.

      If base is set to 0, numbers such as '0777' will be interpreted
      as octal.  The string '0x33' will be interpreted as hexadecimal
      and '777' will be interpreted as a decimal.

      Leading and trailing whitespace is ignored.

class qsdn.NumericValidator(parent=None)

   NumericValidator allows for numbers of any length but
   groupSeparators are added or corrected when missing or out of
   place.

   U.S. dollar amounts;
      dollar = NumericValidator(6,2) s = '42.1'
      dollar.validate(s='42.1', 2)   =>  s = '42.10' s='50000'
      dollar.toString(s)                       => s = ' 50,000.00'

   locale()

      get the locale used by this validator

   setLocale(plocale)

      Set the locale used by this Validator.

   validate(self, str, int) -> Tuple[QValidator.State, str, int]

class qsdn.LimitingNumericValidator(maximum_decamals=1000, maximum_decimals=1000, use_space=False, parent=None)

   NumericValidator limits the number of digits after the decimal
   point and the number of digits before.

      bitcoin                                                :
      NumericValidator(8, 8) US dollars less than $1,000,000 :
      NumericValidator(6, 2)

      If use space is true, spaces are added on the left such that the
      location of decimal point remains constant.  Numbers like
      '10,000.004', '102.126' become  aligned. Bitcoin amounts:

         '              0.004,3' '         10.4' '        320.0' '
         0.000,004'

      U.S. dollar amounts;
         dollar = NumericValidator(6,2) s = '42.1'
         dollar.validate(s='42.1', 2)   =>  s = '        42.10'
         s='50000' dollar.toString(s)                       => s = '
         50,000.00'

   decamals()

      gets the number of decimal digits that are allowed **before**
      the decimal point (apart from spaces)

   decimals()

      gets the number of decimal digits that are allowed *after* the
      decimal point

   locale()

      get the locale used by this validator

   setDecamals(i)

      sets the number of decimal digits that should be allowed
      **before** the decimal point

   setDecimals(i)

      sets the number of decimal digits that should be allowed
      **after** the decimal point

   setLocale(plocale)

      Set the locale used by this Validator.

   validate(s, pos)

      Validates s, by adjusting the position of the commas to be in
      the correct places and adjusting pos accordingly as well as
      space in order to keep decimal points aligned when varying sized
      numbers are put one above the other.


Indices and tables
******************

* Index

* Module Index

* Search Page


