<?xml version="1.0" encoding="utf-8"?>

<!--

The vocabulary here should mostly be obvious after studying some examples.
See also :mod:`httpolice.notice`.

One non-obvious thing is how references work
(i.e. the mousover highlights in HTML reports):

- Constants marked up with elements like ``<h/>`` and ``<st/>``
  are magically highlighted where they appear in the corresponding message(s)
  (see :func:`httpolice.reports.html._magic_references` for details).
  For example, if a notice includes ``<st>401</st>``
  and appears in a response whose status code is 401,
  then hovering the mouse on the notice will highlight the status code.
  Sometimes you need to disable this with a ``ref="no"`` attribute.

- Anything referenced by a ``<var/>`` element is magically highlighted.

- If you want to highlight something else,
  add an explicit ``<ref/>`` element at the end of the ``<notice/>``.

-->

<notices>

  <error id="1000">
    <title>Syntax error in <var ref="place"/> header</title>
    <exception/>
  </error>

  <error id="1001">
    <title>Final <h>Transfer-Encoding</h> must be ‘<tc>chunked</tc>’</title>
    <rfc num="7230" sect="3.3.1">
      If any transfer coding
   other than <tc>chunked</tc> is applied to a request payload body, the sender
   MUST apply <tc>chunked</tc> as the final transfer coding to ensure that the
   message is properly framed.
    </rfc>
  </error>

  <error id="1002">
    <title><h>Transfer-Encoding</h> can’t have ‘<tc>chunked</tc>’ twice</title>
    <rfc num="7230" sect="3.3.1">
      A sender MUST
   NOT apply <tc>chunked</tc> more than once to a message body (i.e., chunking an
   already chunked message is not allowed).
    </rfc>
  </error>

  <debug id="1003">
    <title>Not decoding <h>Transfer-Encoding</h>: <var ref="coding"/></title>
    <explain>HTTPolice does not know how to decode the <var ref="coding"/> transfer coding. (This doesn’t mean that it’s wrong.)</explain>
  </debug>

  <error id="1004">
    <title>Message is incomplete according to <h>Content-Length</h></title>
    <explain>This message’s <h>Content-Length</h> header indicates that the body is <var ref="msg.headers.content_length.value"/> bytes long, but there are fewer bytes remaining on the stream <var ref="error.name"/>.</explain>
  </error>

  <error id="1005">
    <title>Malformed <h>Transfer-Encoding</h>: <tc>chunked</tc></title>
    <exception/>
  </error>

  <error id="1006">
    <title>Malformed request heading</title>
    <exception/>
  </error>

  <debug id="1007">
    <title>Stop parsing request stream</title>
    <explain>Due to previous notices, the data beginning at byte <var ref="offset"/> on the request stream <var ref="stream.name"/> will not be parsed.</explain>
  </debug>

  <error id="1008">
    <title>Not enough requests</title>
    <explain>There are unparsed bytes remaining on the response stream <var ref="stream.name"/>, but no requests that would correspond to them. HTTPolice will try to parse and analyze the remaining responses on their own.</explain>
  </error>

  <error id="1009">
    <title>Malformed response heading</title>
    <exception/>
  </error>

  <debug id="1010">
    <title>Stop parsing response stream</title>
    <explain>Due to previous notices, the data beginning at byte <var ref="offset"/> on the response stream <var ref="stream.name"/> will not be parsed.</explain>
  </debug>

  <debug id="1011">
    <title>Switching protocols</title>
    <explain>The <st>101</st> status code means that the connection is switching to a different protocol. HTTPolice will not parse the rest of the streams.</explain>
  </debug>

  <debug id="1012">
    <title>Switching to a tunnel</title>
    <explain>A <var ref="msg.status"/> response to a <m>CONNECT</m> request means that the connection is becoming a tunnel. HTTPolice will not parse the remainder of the streams.</explain>
  </debug>

  <error id="1013">
    <title>Multiple <var ref="header"/> headers are forbidden</title>
    <rfc num="7230" sect="3.2.2">
      A sender MUST NOT generate multiple header fields with the same field
   name in a message unless either the entire field value for that
   header field is defined as a comma-separated list [i.e., #(values)]
   or the header field is a well-known exception (as noted below).
    </rfc>
    <ref to="entries"/>
  </error>

  <comment id="1014">
    <title>RWS in <var ref="place"/> should be a single space</title>
    <explain>The syntax of <var ref="place"/> includes the rule named RWS. It should be produced as just a single space, but here it was <var ref="num"/> characters. See <rfc num="7230" sect="3.2.3"/>.</explain>
  </comment>

  <error id="1015">
    <title>Bad whitespace (BWS) in <var ref="place"/></title>
    <explain>The syntax of <var ref="place"/> includes the rule named BWS, which is whitespace allowed for historical reasons; it must not be produced by current implementations. See <rfc num="7230" sect="3.2.3"/>.</explain>
  </error>

  <error id="1016">
    <title>Obsolete line folding in headers</title>
    <explain>This message uses line folding (the “obs-fold” rule) to split one header field over several physical lines, but this is deprecated and prohibited in most cases. See <rfc num="7230" sect="3.2.4"/>.</explain>
  </error>

  <comment id="1017">
    <title>Strange escaping in <var ref="place"/></title>
    <explain>This message uses the “quoted-pair” rule to escape the character <var ref="char"/> in a context where this escaping is unnecessary and should not be used. See <rfc num="7230" sect="3.2.6"/>.</explain>
    <explain>If a literal backslash \ was intended here, it must itself be escaped as \\.</explain>
  </comment>

  <error id="1018">
    <title><h>Transfer-Encoding</h> is forbidden in a <var ref="msg.status"/> response</title>
    <rfc num="7230" sect="3.3.1">
      A server MUST NOT send a Transfer-Encoding header field in any
   response with a status code of 1xx (Informational) or 204 (No
   Content).
    </rfc>
  </error>

  <error id="1019">
    <title><h>Transfer-Encoding</h> is forbidden in a <var ref="msg.status"/> response to <m>CONNECT</m></title>
    <rfc num="7230" sect="3.3.1">
      A server MUST NOT send a Transfer-Encoding header field in
   any 2xx (Successful) response to a CONNECT request
    </rfc>
  </error>

  <error id="1020">
    <title>Can’t have both <h>Transfer-Encoding</h> and <h>Content-Length</h></title>
    <rfc num="7230" sect="3.3.2">
      A sender MUST NOT send a Content-Length header field in any message
   that contains a Transfer-Encoding header field.
    </rfc>
  </error>

  <comment id="1021">
    <title><var ref="msg.method"/> request should have <h>Content-Length</h></title>
    <rfc num="7230" sect="3.3.2">
      A user agent SHOULD send a Content-Length in a request message when
   no <h>Transfer-Encoding</h> is sent and the request method defines a meaning
   for an enclosed payload body.  For example, a Content-Length header
   field is normally sent in a <m>POST</m> request even when the value is 0
   (indicating an empty payload body).
    </rfc>
  </comment>

  <comment id="1022">
    <title>Empty <var ref="msg.method"/> request shouldn’t have <h>Content-Length</h></title>
    <rfc num="7230" sect="3.3.2">
      A user agent SHOULD NOT send a
   Content-Length header field when the request message does not contain
   a payload body and the method semantics do not anticipate such a
   body.
    </rfc>
  </comment>

  <error id="1023">
    <title><h>Content-Length</h> is forbidden in a <var ref="msg.status"/> response</title>
    <rfc num="7230" sect="3.3.2">
      A server MUST NOT send a Content-Length header field in any response
   with a status code of 1xx (Informational) or 204 (No Content).
    </rfc>
  </error>

  <error id="1024">
    <title><h>Content-Length</h> is forbidden in a <var ref="msg.status"/> response to <m>CONNECT</m></title>
    <rfc num="7230" sect="3.3.2">
      A
   server MUST NOT send a Content-Length header field in any 2xx
   (Successful) response to a CONNECT request (Section 4.3.6 of
   [RFC7231]).
    </rfc>
  </error>

  <comment id="1025">
    <title>Response delimited only by closing the connection</title>
    <explain>This response has no <h>Content-Length</h> header and no “<h>Transfer-Encoding</h>: <tc>chunked</tc>” that would delimit its body. Therefore, the body is assumed to consist of everything the server sends until closing the connection. But then the client cannot be sure that it received the entire response (that there were no network failures).</explain>
    <explain>See <rfc num="7230" sect="3.3.3"/>.</explain>
  </comment>

  <error id="1026">
    <title><var ref="entry"/> is forbidden in a trailer</title>
    <rfc num="7230" sect="4.1.2">
      A sender MUST NOT generate a trailer that contains a field necessary
   for message framing (e.g., <h ref="no">Transfer-Encoding</h> and <h ref="no">Content-Length</h>),
   routing (e.g., <h ref="no">Host</h>), request modifiers (e.g., controls and
   conditionals in Section 5 of [RFC7231]), authentication (e.g., see
   [RFC7235] and [RFC6265]), response control data (e.g., see Section
   7.1 of [RFC7231]), or determining how to process the payload (e.g.,
   <h ref="no">Content-Encoding</h>, <h ref="no">Content-Type</h>, <h ref="no">Content-Range</h>, and <h ref="no">Trailer</h>).
    </rfc>
  </error>

  <error id="1027">
    <title>Could not decode <h>Transfer-Encoding</h>: <var ref="coding"/></title>
    <exception/>
  </error>

  <error id="1028">
    <title>“<h>TE</h>: <tc>chunked</tc>” is forbidden</title>
    <rfc num="7230" sect="4.3">
      A client MUST NOT send
   the chunked transfer coding name in TE; chunked is always acceptable
   for HTTP/1.1 recipients.
    </rfc>
  </error>

  <error id="1029">
    <title><h>TE</h> header requires “<h>Connection</h>: TE”</title>
    <rfc num="7230" sect="4.3">
      Since the TE header field only applies to the immediate connection, a
   sender of TE MUST also send a "TE" connection option within the
   <h>Connection</h> header field (Section 6.1) in order to prevent the TE
   field from being forwarded by intermediaries that do not support its
   semantics.
    </rfc>
  </error>

  <comment id="1030">
    <title><var ref="header"/> was not announced in the <h>Trailer</h> header</title>
    <rfc num="7230" sect="4.4">
      When a message includes a message body encoded with the chunked
   transfer coding and the sender desires to send metadata in the form
   of trailer fields at the end of the message, the sender SHOULD
   generate a <h>Trailer</h> header field before the message body to indicate
   which fields will be present in the trailers.
    </rfc>
  </comment>

  <error id="1031">
    <title>Missing <h>Host</h> header</title>
    <rfc num="7230" sect="5.4">
      A client MUST send a Host header field in all HTTP/1.1 request
   messages.
    </rfc>
  </error>

  <comment id="1032">
    <title><h>Host</h> should be the first header</title>
    <rfc num="7230" sect="5.4">
      Since the Host field-value is critical information for handling a
   request, a user agent SHOULD generate Host as the first header field
   following the request-line.
    </rfc>
  </comment>

  <error id="1033">
    <title>Request with a bad <h ref="no">Host</h> header must be rejected</title>
    <rfc num="7230" sect="5.4">
      A server MUST respond with a <st>400</st> (Bad Request) status code to any
   HTTP/1.1 request message that lacks a Host header field and to any
   request message that contains more than one Host header field or a
   Host header field with an invalid field-value.
    </rfc>
    <ref to="msg.status"/>
    <ref to="msg.request.version"/>
    <ref to="msg.request.headers.host"/>
  </error>

  <error id="1034">
    <title>“<h>Connection</h>: <var ref="header"/>” is forbidden</title>
    <rfc num="7230" sect="5.4">
      A sender MUST NOT send a connection option corresponding to a header
   field that is intended for all recipients of the payload.  For
   example, <h>Cache-Control</h> is never appropriate as a connection option
   (Section 5.2 of [RFC7234]).
    </rfc>
  </error>

  <comment id="1035">
    <title>Deprecated media type <var ref="msg.headers.content_type.value"/></title>
    <explain>According to <h>Content-Type</h>, this message’s body is of type <var ref="msg.headers.content_type.value"/>, which is listed as “deprecated” or “obsoleted” in the <cite title="IANA media types registry" url="https://www.iana.org/assignments/media-types/media-types.xml"/>.</explain>
  </comment>

  <debug id="1036">
    <title>Not decoding <h>Content-Encoding</h>: <var ref="coding"/></title>
    <explain>HTTPolice does not know how to decode the <var ref="coding"/> content coding. (This doesn’t mean that it’s wrong.)</explain>
  </debug>

  <error id="1037">
    <title>Could not decode <h>Content-Encoding</h>: <var ref="coding"/></title>
    <exception/>
  </error>

  <error id="1038">
    <title>Bad JSON body</title>
    <explain>According to <h>Content-Type</h>, this message’s body is JSON, but HTTPolice tried to parse it as JSON and got the following error:</explain>
    <exception/>
    <ref to="msg.displayable_body"/>
  </error>

  <error id="1039">
    <title>Bad XML body</title>
    <explain>According to <h>Content-Type</h>, this message’s body is XML, but HTTPolice tried to parse it as XML and got the following error:</explain>
    <exception/>
    <ref to="msg.displayable_body"/>
  </error>

  <error id="1040">
    <title>Bad URL-encoded body</title>
    <explain>According to <h>Content-Type</h>, this message’s body is URL-encoded. But it doesn’t look like a proper URL-encoded string, as defined by <cite title="HTML5" url="https://www.w3.org/TR/html5/forms.html#url-encoded-form-data"/>, because it contains the character: <var ref="char"/>.</explain>
    <explain>This often means that the <h>Content-Type</h> header is wrong.</explain>
    <ref to="msg.displayable_body"/>
  </error>

  <comment id="1041">
    <title>Body should have a <h>Content-Type</h></title>
    <rfc num="7231" sect="3.1.1.5">
      A sender that generates a message containing a payload body SHOULD
   generate a Content-Type header field in that message unless the
   intended media type of the enclosed representation is unknown to the
   sender.
    </rfc>
    <ref to="msg.displayable_body"/>
  </comment>

  <comment id="1042">
    <title>Duplicate ‘<var ref="param"/>’ parameter in <h>Content-Type</h></title>
    <rfc num="6838" sect="4.3">
      It is an error for a specific
   parameter to be specified more than once.
    </rfc>
    <!-- This is a comment, not an error, because I'm not even sure this is correct: RFC 6838 is merely a BCP, and the requirement is not stated in RFC 2045/2046, and it's not even clear to me that RFC 6838 refers to the actual usage of parameters rather than their definition. -->
  </comment>

  <error id="1045">
    <title>Syntax error in request target</title>
    <exception/>
    <explain>See also <rfc num="7230" sect="5.3"/>.</explain>
    <ref to="msg.target"/>
  </error>

  <error id="1046">
    <title>Proxied response needs a <h>Via</h> header</title>
    <explain>According to <rfc num="7230" sect="5.7.1"/>, a proxy must add a <h>Via</h> header to each response that it forwards.</explain>
  </error>

  <comment id="1047">
    <title>Close-delimited response should have “<h>Connection</h>: close”</title>
    <explain>When a response is delimited only by closing the connection, it should have a <h>Connection</h> header with a ‘close’ option. See <rfc num="7230" sect="6.3"/> and <rfc num="7230" sect="6.6"/>.</explain>
  </comment>

  <error id="1048">
    <title><st>101</st> response needs an <h>Upgrade</h> header</title>
    <rfc num="7230" sect="6.7">
      A server that sends a 101 (Switching Protocols) response MUST send an
   <h>Upgrade</h> header field to indicate the new protocol(s) to which the
   connection is being switched
    </rfc>
  </error>

  <error id="1049">
    <title>Switching to a protocol that was not requested</title>
    <rfc num="7230" sect="6.7">
      A server MUST NOT switch to a protocol that was not indicated
   by the client in the corresponding request's <h ref="no">Upgrade</h> header field.
    </rfc>
    <ref to="msg.status"/>
    <ref to="msg.headers.upgrade"/>
    <ref to="msg.request.headers.upgrade"/>
  </error>

  <error id="1050">
    <title><h>Upgrade</h> header requires “<h>Connection</h>: upgrade”</title>
    <rfc num="7230" sect="6.7">
      When <h>Upgrade</h> is sent, the sender MUST also send a <h>Connection</h> header
   field (Section 6.1) that contains an "upgrade" connection option, in
   order to prevent Upgrade from being accidentally forwarded by
   intermediaries that might not implement the listed protocols.
    </rfc>
  </error>

  <error id="1051">
    <title><st>101</st> response to an HTTP/1.0 request is forbidden</title>
    <rfc num="7230" sect="6.7">
      A
   server MUST ignore an <h ref="no">Upgrade</h> header field that is received in an
   HTTP/1.0 request.
    </rfc>
    <ref to="msg.request.version"/>
  </error>

  <error id="1052">
    <title><var ref="header"/> makes no sense in a <var ref="msg.status"/> response</title>
    <explain>The <var ref="header"/> header provides representation metadata, but there can be no representation associated with a <var ref="msg.status"/> response. The header should probably be removed.</explain>
  </error>

  <comment id="1053">
    <title><var ref="header"/> makes no sense in an empty request</title>
    <explain>The <var ref="header"/> header provides representation metadata. It would make sense in a request with a body, but this one has no body.</explain>
    <explain>See also <rfc num="7231" sect="3.1"/>.</explain>
    <!-- This is a comment because we do not actually distinguish between "no payload" and "payload of length 0", while RFC 7230 does. It's not unthinkable to include something like a ``Content-Language`` in a POST request with a payload of length 0. -->
  </comment>

  <error id="1054">
    <title><h>Trailer</h> header makes no sense without a chunked body</title>
    <explain>The <h>Trailer</h> header announces what other headers will be sent in the trailer part of a <tc>chunked</tc> message. It doesn’t make sense here because this message does not use the chunked transfer coding.</explain>
    <explain>See also <rfc num="7230" sect="4.1.2"/>.</explain>
    <ref to="msg.headers.transfer_encoding"/>
    <!-- It would be more interesting to check that the header announced by ``Trailer`` is actually present there, but I don't think this is feasible, because many/most implementations (which are going to supply us with parsed messages) don't provide access to the trailer part at all. -->
  </error>

  <comment id="1055">
    <title>Unnecessary <h>Content-Location</h></title>
    <explain>This is a <var ref="msg.status"/> response to a <var ref="msg.request.method"/> request. By definition, its body is a representation of the requested resource. But it also has a <h>Content-Location</h> header that points to the same URI as the request URI. In this case, the header provides no additional information.</explain>
    <explain>See also <rfc num="7231" sect="3.1.4.1"/>.</explain>
  </comment>

  <comment id="1056">
    <title><m>GET</m> request with a body may cause problems</title>
    <rfc num="7231" sect="4.3.1">
      A payload within a GET request message has no defined semantics;
   sending a payload body on a GET request might cause some existing
   implementations to reject the request.
    </rfc>
    <ref to="msg.displayable_body"/>
  </comment>

  <comment id="1057">
    <title><m>HEAD</m> request with a body may cause problems</title>
    <rfc num="7231" sect="4.3.2">
      A payload within a HEAD request message has no defined semantics;
   sending a payload body on a HEAD request might cause some existing
   implementations to reject the request.
    </rfc>
  </comment>

  <error id="1058">
    <title><m>PUT</m> request with <h ref="no">Content-Range</h> must be rejected</title>
    <rfc num="7231" sect="4.3.4">
      An origin server that allows PUT on a given target resource MUST send
   a <st>400</st> (Bad Request) response to a PUT request that contains a
   <h ref="no">Content-Range</h> header field (Section 4.2 of [RFC7233]), since the
   payload is likely to be partial content that has been mistakenly PUT
   as a full representation.
    </rfc>
    <ref to="msg.status"/>
    <ref to="msg.request.headers.content_range"/>
  </error>

  <comment id="1059">
    <title><m>DELETE</m> request with a body may cause problems</title>
    <rfc num="7231" sect="4.3.5">
      A payload within a DELETE request message has no defined semantics;
   sending a payload body on a DELETE request might cause some existing
   implementations to reject the request.
    </rfc>
    <ref to="msg.displayable_body"/>
  </comment>

  <error id="1060">
    <title>Strange <h>Content-Location</h> in response to <m>DELETE</m></title>
    <explain>This is an ostensibly successful (<var ref="msg.status"/>) response to a <m>DELETE</m> request. However, according to its <h>Content-Location</h> header, it carries a representation of the target resource—the one that should have been deleted. Either the Content-Location is wrong, or the request did not actually succeed.</explain>
  </error>

  <comment id="1061">
    <title><m>CONNECT</m> request with a body may cause problems</title>
    <rfc num="7231" sect="4.3.6">
      A payload within a CONNECT request message has no defined semantics;
   sending a payload body on a CONNECT request might cause some existing
   implementations to reject the request.
    </rfc>
    <ref to="msg.displayable_body"/>
  </comment>

  <error id="1062">
    <title><m>OPTIONS</m> request with a body needs <h>Content-Type</h></title>
    <rfc num="7231" sect="4.3.7">
      A client that generates an OPTIONS request containing a payload body
   MUST send a valid <h>Content-Type</h> header field describing the
   representation media type.
    </rfc>
  </error>

  <error id="1063">
    <title><var ref="header"/> header is for responses</title>
    <explain>This request has the <var ref="header"/> header, which is only defined for responses.</explain>
  </error>

  <error id="1064">
    <title><var ref="header"/> header is for requests</title>
    <explain>This response has the <var ref="header"/> header, which is only defined for requests.</explain>
  </error>

  <error id="1066">
    <title>“<h>Expect</h>: 100-continue” is forbidden on empty requests</title>
    <rfc num="7231" sect="5.1.1">
      A client MUST NOT generate a 100-continue expectation in a request
      that does not include a message body.
    </rfc>
    <!-- Even though we don't really distinguish between "no body" and "body of length 0", it doesn't make sense to expect 100 (Continue) to a request with a ``Content-Length: 0``, for example. -->
  </error>

  <comment id="1067">
    <title><h>Max-Forwards</h> header is undefined for <var ref="msg.method"/> requests</title>
    <explain>The <h>Max-Forwards</h> header is only defined for <m>OPTIONS</m> and <m>TRACE</m> requests. <rfc num="7231" sect="5.1.2">A recipient MAY ignore a Max-Forwards header field received with any other request methods.</rfc></explain>
  </comment>

  <error id="1068">
    <title>Unsecured request must not have a <h>Referer</h> with ‘https:’</title>
    <rfc num="7231" sect="5.5.2">
      A user agent MUST NOT send a Referer header field in an
   unsecured HTTP request if the referring page was received with a
   secure protocol.
    </rfc>
  </error>

  <comment id="1070">
    <title>Missing <h>User-Agent</h> header</title>
    <rfc num="7231" sect="5.5.3">
      A user agent SHOULD send a User-Agent field in each request
   unless specifically configured not to do so.
    </rfc>
  </comment>

  <error id="1071">
    <title><var ref="msg.status"/> response to an HTTP/1.0 request is forbidden</title>
    <rfc num="7231" sect="6.2">
      Since HTTP/1.0 did not define any 1xx status codes, a
   server MUST NOT send a 1xx response to an HTTP/1.0 client.
    </rfc>
    <ref to="msg.request.version"/>
  </error>

  <error id="1072">
    <title><st>201</st> response to <var ref="msg.request.method"/> makes no sense</title>
    <explain>The <var ref="msg.request.method"/> method is defined as safe (read-only). But the <st>201</st> status code means that a new resource was created.</explain>
  </error>

  <comment id="1073">
    <title>Possibly missing <h>Location</h> header</title>
    <explain>This <st>201</st> response indicates that a new resource was created. Because there is no <h>Location</h> header in the response, it is assumed that the created resource is the same as the request target (<rfc num="7231" sect="6.3.2"/>). But <m>POST</m> requests are usually intended to create a sub-resource of the target. It’s likely that this response needs an explicit <h>Location</h>.</explain>
  </comment>

  <error id="1074">
    <title><st>202</st> response to <var ref="msg.request.method"/> makes no sense</title>
    <explain>The <var ref="msg.request.method"/> method is defined as safe (read-only). But the <st>202</st> status code means that the server started some kind of processing operation.</explain>
  </error>

  <error id="1076">
    <title><st>205</st> response must not have a body</title>
    <rfc num="7231" sect="6.3.6">
      Since the 205 status code implies that no additional content will be
   provided, a server MUST NOT generate a payload in a 205 response.
    </rfc>
    <ref to="msg.displayable_body"/>
  </error>

  <comment id="1077">
    <title><st>300</st> response should have a body</title>
    <rfc num="7231" sect="6.4.1">
      For request methods other than <m>HEAD</m>, the server SHOULD generate a
   payload in the 300 response containing a list of representation
   metadata and URI reference(s) from which the user or user agent can
   choose the one most preferred.
    </rfc>
  </comment>

  <comment id="1078">
    <title><st>301</st> response should have a <h>Location</h> header</title>
    <rfc num="7231" sect="6.4.2">
      The server SHOULD generate a Location header field in the response
   containing a preferred URI reference for the new permanent URI.
    </rfc>
  </comment>

  <comment id="1079">
    <title><st>302</st> response should have a <h>Location</h> header</title>
    <rfc num="7231" sect="6.4.3">
      The server SHOULD generate a Location header field in the response
   containing a URI reference for the different URI.
    </rfc>
  </comment>

  <error id="1080">
    <title><st>303</st> response needs a <h>Location</h> header</title>
    <rfc num="7231" sect="6.4.4">
      The 303 (See Other) status code indicates that the server is
   redirecting the user agent to a different resource, as indicated by a
   URI in the <h>Location</h> header field, which is intended to provide an
   indirect response to the original request.
    </rfc>
  </error>

  <comment id="1081">
    <title><st>303</st> response should have a body</title>
    <rfc num="7231" sect="6.4.4">
      Except for responses to a <m>HEAD</m> request, the representation of a 303
   response ought to contain a short hypertext note with a hyperlink to
   the same URI reference provided in the <h ref="no">Location</h> header field.
    </rfc>
  </comment>

  <error id="1082">
    <title>Status code <st>305</st> is deprecated</title>
    <rfc num="7231" sect="6.4.5">
      The 305 (Use Proxy) status code was defined in a previous version of
   this specification and is now deprecated (Appendix B).
    </rfc>
  </error>

  <error id="1083">
    <title>Status code <st>306</st> is reserved</title>
    <rfc num="7231" sect="6.4.6">
      The 306 status code was defined in a previous version of this
   specification, is no longer used, and the code is reserved.
    </rfc>
  </error>

  <comment id="1084">
    <title><st>307</st> response should have a <h>Location</h> header</title>
    <rfc num="7231" sect="6.4.7">
      The server SHOULD generate a Location header field in the response
   containing a URI reference for the different URI.
    </rfc>
  </comment>

  <error id="1085">
    <title>Redirection to the same URI</title>
    <explain>This <var ref="msg.status"/> response includes a <h>Location</h> header that points to the same URI as the request URI. So the resource redirects to itself.</explain>
    <ref to="msg.request.target"/>
  </error>

  <error id="1086">
    <title><var ref="msg.status"/> response to server-wide <m>OPTIONS</m> makes no sense</title>
    <explain>The <var ref="msg.status"/> status code means that the target resource can be found at a different URI. But this was an “ <m>OPTIONS</m> * ” request—it targets the entire server, not any particular resource. So the <var ref="msg.status"/> status code makes no sense here.</explain>
    <explain>Perhaps the <st>303</st> status code would fit better.</explain>
    <ref to="msg.request.target"/>
  </error>

  <comment id="1087">
    <title><var ref="msg.status"/> response should include an explanation</title>
    <rfc num="7231" sect="6.5">
      Except when responding to a <m>HEAD</m> request, the
   server SHOULD send a representation containing an explanation of the
   error situation, and whether it is a temporary or permanent
   condition.
    </rfc>
  </comment>

  <error id="1088">
    <title>Status code <st>402</st> is reserved</title>
    <rfc num="7231" sect="6.5.2">
      The 402 (Payment Required) status code is reserved for future use.
    </rfc>
  </error>

  <error id="1089">
    <title><st>405</st> response needs an <h>Allow</h> header</title>
    <rfc num="7231" sect="6.5.5">
      The origin server MUST generate an
   <h>Allow</h> header field in a 405 response containing a list of the target
   resource's currently supported methods.
    </rfc>
  </error>

  <error id="1090">
    <title><st>406</st> response, but request wasn’t negotiating</title>
    <explain>The <st>406</st> status code means that the server cannot satisfy the request’s content negotiation headers, such as <h ref="no">Accept</h>. But this request doesn’t seem to have such headers.</explain>
    <explain>See also <rfc num="7231" sect="5.3"/>.</explain>
  </error>

  <comment id="1092">
    <title><st>406</st> response should have a body</title>
    <rfc num="7231" sect="6.5.6">
      The server SHOULD generate a payload containing a list of available
   representation characteristics and corresponding resource identifiers
   from which the user or user agent can choose the one most
   appropriate.
    </rfc>
  </comment>

  <comment id="1093">
    <title><h>User-Agent</h> contains no actual product</title>
    <explain>This request’s <h>User-Agent</h> header contains only the name of the underlying library, which isn’t very useful for identifying the request. It may be a good idea to include the name of the actual product.</explain>
    <explain>For example: “My-Product/1.0 <var ref="library"/>”.</explain>
    <explain>Or simply “My-Product/1.0” or “My-Product”.</explain>
    <explain>See <rfc num="7231" sect="5.5.3"/>.</explain>
  </comment>

  <comment id="1094">
    <title><st>408</st> response should have “<h>Connection</h>: close”</title>
    <rfc num="7231" sect="6.5.7">
      A server SHOULD send the "close" connection option
   (Section 6.1 of [RFC7230]) in the response, since 408 implies that
   the server has decided to close the connection rather than continue
   waiting.
    </rfc>
  </comment>

  <error id="1095">
    <title><st>409</st> response to <var ref="msg.request.method"/> makes no sense</title>
    <explain>The <st>409</st> status code means that the request conflicted with the current state of the resource. But a <var ref="msg.request.method"/> request is, by definition, safe (read-only): it must not affect the state, so there can be no conflict.</explain>
  </error>

  <comment id="1096">
    <title><st>409</st> response should include an explanation</title>
    <rfc num="7231" sect="6.5.8">
      The server
   SHOULD generate a payload that includes enough information for a user
   to recognize the source of the conflict.
    </rfc>
  </comment>

  <error id="1097">
    <title><st>411</st> response, but request did have <h ref="no">Content-Length</h></title>
    <explain>The <st>411</st> status code means that the server wants to see a <h ref="no">Content-Length</h> header in the request. But this request did, in fact, include a valid Content-Length of <var ref="msg.request.headers.content_length.value"/>.</explain>
    <ref to="msg.request.headers.content_length"/>
  </error>

  <error id="1098">
    <title><st>413</st> response, but request had no body</title>
    <rfc num="7231" sect="6.5.11">
      The 413 (Payload Too Large) status code indicates that the server is
   refusing to process a request because the request payload is larger
   than the server is willing or able to process.
    </rfc>
  </error>

  <error id="1099">
    <title><st>415</st> response, but request had no body</title>
    <rfc num="7231" sect="6.5.13">
      The 415 (Unsupported Media Type) status code indicates that the
   origin server is refusing to service the request because the payload
   is in a format not supported by this method on the target resource.
    </rfc>
  </error>

  <error id="1100">
    <title><st>417</st> response, but request had no <h ref="no">Expect</h></title>
    <rfc num="7231" sect="6.5.14">
      The 417 (Expectation Failed) status code indicates that the
   expectation given in the request's <h ref="no">Expect</h> header field
   (Section 5.1.1) could not be met by at least one of the inbound
   servers.
    </rfc>
  </error>

  <error id="1101">
    <title><st>426</st> response needs an <h>Upgrade</h> header</title>
    <rfc num="7231" sect="6.5.15">
      The server MUST send an <h>Upgrade</h> header field in a 426
   response to indicate the required protocol(s)
    </rfc>
  </error>

  <error id="1102">
    <title><st>426</st> response, but client is ready to upgrade</title>
    <explain>In this response, the server demands that the client upgrade to <var ref="protocol"/>. But the client’s request is already offering that same upgrade in its own <h ref="no">Upgrade</h> header. The server can just send a <st>101</st> response and switch to <var ref="protocol"/>.</explain>
    <explain>See <rfc num="7230" sect="6.7"/>.</explain>
    <ref to="msg.headers.upgrade"/>
    <ref to="msg.request.headers.upgrade"/>
  </error>

  <error id="1103">
    <title>Not proceeding with protocol upgrade</title>
    <explain>This response’s <h>Upgrade</h> header indicates that the server is ready to upgrade to <var ref="protocol"/>. But the client’s request is already offering that same upgrade in its own <h ref="no">Upgrade</h> header. If the server actually wants to switch to <var ref="protocol"/>, it should go ahead, send a <st>101</st> response, and switch.</explain>
    <explain>See <rfc num="7230" sect="6.7"/>.</explain>
    <ref to="msg.request.headers.upgrade"/>
  </error>

  <comment id="1104">
    <title><var ref="msg.status"/> response should include an explanation</title>
    <rfc num="7231" sect="6.6">
      Except when responding to a <m>HEAD</m> request, the
   server SHOULD send a representation containing an explanation of the
   error situation, and whether it is a temporary or permanent
   condition.
    </rfc>
  </comment>

  <error id="1105">
    <title><st>505</st> response, but request had the same HTTP version</title>
    <explain>The <st>505</st> status code means that the server does not support the HTTP version used in the request—which is <var ref="msg.request.version"/>—but the response itself is <var ref="msg.version"/>, too.</explain>
    <rfc num="7230" sect="2.6">
      A server MUST NOT send
   a version to which it is not conformant.
    </rfc>
  </error>

  <comment id="1106">
    <title><st>505</st> response should have a body</title>
    <rfc num="7231" sect="6.6.6">
      The server SHOULD
   generate a representation for the 505 response that describes why
   that version is not supported and what other protocols are supported
   by that server.
    </rfc>
  </comment>

  <error id="1107">
    <title>Obsolete date-time format in <var ref="place"/></title>
    <explain>This message’s <var ref="place"/> uses an obsolete date-time format. See <rfc num="7231" sect="7.1.1.1"/>.</explain>
  </error>

  <error id="1108">
    <title>Wrong day of week in <var ref="place"/></title>
    <explain>This message’s <var ref="place"/> claims that <var ref="date"/> is <var ref="claimed"/>, but in reality it’s <var ref="actual"/>.</explain>
  </error>

  <error id="1109">
    <title><h>Date</h> header is in the future</title>
    <explain>The <h>Date</h> header contains the date and time at which the message was originated. But here it seems to be in the future.</explain>
    <explain>This might be due to wrong timezone settings.</explain>
  </error>

  <comment id="1110">
    <title>Missing <h>Date</h> header</title>
    <explain>According to <rfc num="7231" sect="7.1.1.2"/>, every <var ref="msg.status"/> response must have a <h>Date</h> header, unless the server has no usable clock.</explain>
  </comment>

  <error id="1111">
    <title><st>201</st> response can’t have <h>Location</h> with a fragment (#)</title>
    <rfc num="7231" sect="7.1.2">
      There are circumstances in which a fragment identifier in a <h>Location</h>
   value would not be appropriate.  For example, the Location header
   field in a 201 (Created) response is supposed to provide a URI that
   is specific to the created resource.
    </rfc>
  </error>

  <comment id="1112">
    <title><h>Location</h> header is undefined for <var ref="msg.status"/> responses</title>
    <explain><rfc num="7231" sect="7.1.2"/> does not define what it means for a <var ref="msg.status"/> response to have a <h>Location</h> header.</explain>
  </comment>

  <comment id="1113">
    <title><h>Retry-After</h> is undefined for <var ref="msg.status"/> responses</title>
    <explain>As far as HTTPolice knows, the <h>Retry-After</h> header is defined for status codes 3xx, <st>413</st>, <st>429</st>, and <st>503</st>, but not for <var ref="msg.status"/>.</explain>
  </comment>

  <error id="1114">
    <title><st>405</st> response, but <h>Allow</h> includes <var ref="msg.request.method"/></title>
    <explain>The <st>405</st> status code means that the request method (<var ref="msg.request.method"/>) is not allowed for this resource. But the <h>Allow</h> header does include <var ref="msg.request.method"/>.</explain>
  </error>

  <error id="1115">
    <title><h>Allow</h> does not include <var ref="msg.request.method"/></title>
    <explain>The <var ref="msg.status"/> status code means that this <var ref="msg.request.method"/> request was handled successfully. But the <h>Allow</h> header does not include <var ref="msg.request.method"/>, so it should have been disallowed (status code <st>405</st>).</explain>
  </error>

  <error id="1116">
    <title><h>Accept-Encoding</h>: <var ref="coding"/> must not have a quality value</title>
    <rfc num="7231" sect="5.3.4">
      Most HTTP/1.0 applications do not recognize or obey qvalues
      associated with content-codings.  This means that qvalues might
      not work and are not permitted with <cc>x-gzip</cc> or <cc>x-compress</cc>.
    </rfc>
  </error>

  <comment id="1117">
    <title><h ref="no">Accept-Language</h> shouldn’t trigger a <st>406</st> response</title>
    <explain>The <st>406</st> status code means that the server cannot satisfy the request’s content negotiation headers. The only such header (known to HTTPolice) in this request is <h ref="no">Accept-Language</h>. However, <rfc num="7231" sect="5.3.5"/> discourages sending a <st>406</st> response in this case: it’s better to send a representation in a different language, because the user may still be able to understand some of it.</explain>
    <ref to="msg.request.headers.accept_language"/>
  </comment>

  <error id="1118">
    <title><h>Last-Modified</h> can’t be later than <h>Date</h></title>
    <rfc num="7232" sect="2.2.1">
      An origin server with a clock MUST NOT send a <h>Last-Modified</h> date that
   is later than the server's time of message origination (<h>Date</h>).
    </rfc>
  </error>

  <comment id="1119">
    <title>Backslash in <var ref="place"/> may cause problems</title>
    <rfc num="7232" sect="2.3">
      Previously, opaque-tag was defined to be a quoted-string
      ([RFC2616], Section 3.11); thus, some recipients might perform
      backslash unescaping.  Servers therefore ought to avoid backslash
      characters in entity tags.
    </rfc>
  </comment>

  <error id="1120">
    <title>Weak entity tag in <h>If-Match</h> is not supposed to work</title>
    <rfc num="7232" sect="3.1">
      An origin server MUST use the strong comparison function when
   comparing entity-tags for <h>If-Match</h> (Section 2.3.2), since the client
   intends this precondition to prevent the method from being applied if
   there have been any changes to the representation data.
    </rfc>
    <explain>In other words, a conformant server will never consider two weak entity tags as equal for purposes of the <h>If-Match</h> header.</explain>
  </error>

  <error id="1121">
    <title><h ref="no">If-None-Match</h> was ignored</title>
    <explain>This is a <var ref="msg.status"/> response to a <var ref="msg.request.method"/> request, but its <h>ETag</h> header matches the <h ref="no">If-None-Match</h> header of the request. The server is supposed to send a <st>304</st> response in this situation.</explain>
    <explain>See <rfc num="7232" sect="3.2"/>.</explain>
    <ref to="msg.request.headers.if_none_match"/>
  </error>

  <error id="1122">
    <title><h>If-Modified-Since</h> in <var ref="msg.method"/> requests is not supposed to work</title>
    <explain>According to <rfc num="7232" sect="3.3"/>, an <h>If-Modified-Since</h> header must be ignored in requests that are neither <m>GET</m> nor <m>HEAD</m>.</explain>
  </error>

  <comment id="1123">
    <title><h ref="no">If-Modified-Since</h> was ignored</title>
    <explain>This is a <var ref="msg.status"/> response to a <var ref="msg.request.method"/> request, but its <h>Last-Modified</h> date is no later than the <h ref="no">If-Modified-Since</h> header of the request. The server should send a <st>304</st> response in this situation.</explain>
    <explain>See <rfc num="7232" sect="3.3"/>.</explain>
    <ref to="msg.request.headers.if_modified_since"/>
  </comment>

  <error id="1124">
    <title><st>304</st> response is undefined for <var ref="msg.request.method"/> requests</title>
    <explain>The <st>304</st> status code is only defined by <rfc num="7232" sect="4.1"/> for responses to <m>GET</m> and <m>HEAD</m>. With other methods, the <st>412</st> status code may be useful.</explain>
  </error>

  <error id="1125">
    <title><var ref="msg.status"/> response, but request has no preconditions</title>
    <explain>The <var ref="msg.status"/> status code is only used when the request includes a precondition, such as <h ref="no">If-Modified-Since</h>. But this request doesn’t seem to have any preconditions.</explain>
    <explain>See <rfc num="7232"/>.</explain>
  </error>

  <comment id="1127">
    <title><st>304</st> response should not have <var ref="header"/></title>
    <rfc num="7232" sect="4.1">
      Since the goal of a 304 response is to minimize information transfer
   when the recipient already has one or more cached representations, a
   sender SHOULD NOT generate representation metadata other than the
   above listed fields unless said metadata exists for the purpose of
   guiding cache updates (e.g., <h ref="no">Last-Modified</h> might be useful if the
   response does not have an <h ref="no">ETag</h> field).
    </rfc>
  </comment>

  <error id="1128">
    <title><h ref="no">If-Modified-Since</h> on <var ref="msg.request.method"/> must be ignored</title>
    <explain>The <st>412</st> status code means that the server could not satisfy a precondition included in the request. The only such precondition (known to HTTPolice) in this request is <h ref="no">If-Modified-Since</h>. But <rfc num="7232" sect="3.3"/> says that an <h ref="no">If-Modified-Since</h> header in a <var ref="msg.request.method"/> request must be ignored.</explain>
    <ref to="msg.request.headers.if_modified_since"/>
  </error>

  <error id="1129">
    <title>Preconditions on <var ref="msg.request.method"/> must be ignored</title>
    <explain>The <st>412</st> status code means that the server could not satisfy a precondition included in the request. But, as defined in <rfc num="7232" sect="5"/>, such preconditions must be ignored in a <var ref="msg.request.method"/> request.</explain>
  </error>

  <error id="1130">
    <title><var ref="header"/> on <var ref="msg.method"/> makes no sense</title>
    <rfc num="7232" sect="5">
      Likewise, a server
   MUST ignore the conditional request header fields defined by this
   specification when received with a request method that does not
   involve the selection or modification of a selected representation,
   such as <m>CONNECT</m>, <m>OPTIONS</m>, or <m>TRACE</m>.
    </rfc>
  </error>

  <comment id="1131">
    <title>Conditional <m>HEAD</m> request is pointless</title>
    <rfc num="7232" sect="5">
      Although conditional request header fields are defined as being
   usable with the <m>HEAD</m> method (to keep HEAD's semantics consistent with
   those of <m>GET</m>), there is no point in sending a conditional HEAD
   because a successful response is around the same size as a <st>304</st> (Not
   Modified) response and more useful than a <st>412</st> (Precondition Failed)
   response.
    </rfc>
    <ref to="header"/>
  </comment>

  <error id="1132">
    <title><h>Range</h> header on <var ref="msg.method"/> is not supposed to work</title>
    <rfc num="7233" sect="3.1">
      A server
   MUST ignore a <h>Range</h> header field received with a request method other
   than <m>GET</m>.
    </rfc>
  </error>

  <error id="1133">
    <title>Invalid byte range in <var ref="place"/></title>
    <rfc num="7233" sect="2.1">
      A byte-range-spec is invalid if the last-byte-pos value is present
   and less than the first-byte-pos.
    </rfc>
  </error>

  <error id="1134">
    <title><h>If-Range</h> requires a <h>Range</h> header</title>
    <rfc num="7233" sect="3.2">
      A client MUST NOT generate an <h>If-Range</h> header field in a request that
   does not contain a <h>Range</h> header field.
    </rfc>
  </error>

  <error id="1135">
    <title>Weak entity tags are forbidden in <h>If-Range</h></title>
    <rfc num="7233" sect="3.2">
      A client MUST NOT generate an <h>If-Range</h> header field containing an
   entity-tag that is marked as weak.
    </rfc>
  </error>

  <error id="1136">
    <title><st>206</st> response, but request had no <h ref="no">Range</h></title>
    <explain>The <st>206</st> status code only makes sense in responses to partial requests—that is, requests with a <h ref="no">Range</h> header. See <rfc num="7233" sect="4.1"/>.</explain>
  </error>

  <error id="1137">
    <title><st>206</st> response to <var ref="msg.request.method"/> is forbidden</title>
    <rfc num="7233" sect="3.1">
      A server
   MUST ignore a <h ref="no">Range</h> header field received with a request method other
   than <m>GET</m>.
    </rfc>
    <ref to="msg.request.headers.range"/>
  </error>

  <error id="1138">
    <title><st>206</st> response needs range specifiers</title>
    <explain>The <st>206</st> status code means that the response contains one or more parts of the data. When it contains one part, the response must have a <h>Content-Range</h> header. When it contains several parts, the response must have a <h>Content-Type</h> of <media>multipart/byteranges</media>. But this response has neither.</explain>
    <explain>See <rfc num="7233" sect="4.1"/>.</explain>
  </error>

  <error id="1139">
    <title>Multipart boundary not declared</title>
    <explain>According to <h>Content-Type</h>, this message has a multipart body, but Content-Type does not include the ‘boundary’ parameter that is necessary to parse such a body.</explain>
    <explain>See <rfc num="2046" sect="5.1.1"/>.</explain>
  </error>

  <error id="1140">
    <title>Multipart boundary not found</title>
    <explain>The multipart boundary declared in this message’s <h>Content-Type</h> was not found in the body.</explain>
    <explain>See <rfc num="2046" sect="5.1.1"/>.</explain>
    <ref to="msg.displayable_body"/>
  </error>

  <error id="1141">
    <title>No <h ref="no">Content-Range</h> in part #<var ref="part_num"/></title>
    <rfc num="7233" sect="4.1">
      Within the header area of each body part in the multipart payload,
   the server MUST generate a <h ref="no">Content-Range</h> header field corresponding
   to the range being enclosed in that body part.
    </rfc>
    <ref to="msg.displayable_body"/>
    <ref to="msg.headers.content_type"/>
  </error>

  <comment id="1142">
    <title>No <h ref="no">Content-Type</h> in part #<var ref="part_num"/></title>
    <rfc num="7233" sect="4.1">
      If the selected
   representation would have had a <h ref="no">Content-Type</h> header field in a <st>200</st>
   (OK) response, the server SHOULD generate that same Content-Type
   field in the header area of each body part.
    </rfc>
    <ref to="msg.displayable_body"/>
    <ref to="msg.headers.content_type"/>
  </comment>

  <error id="1143">
    <title><h>Content-Range</h> in a <media>multipart/byteranges</media> response is forbidden</title>
    <rfc num="7233" sect="4.1">
      To avoid confusion with single-part responses, a server MUST NOT
   generate a <h>Content-Range</h> header field in the HTTP header section of a
   multiple part response (this field will be sent in each part
   instead).
    </rfc>
    <ref to="msg.headers.content_type"/>
  </error>

  <error id="1144">
    <title><media>multipart/byteranges</media> response can’t be used for a single <h ref="no">Range</h></title>
    <rfc num="7233" sect="4.1">
      A server MUST NOT generate a multipart response to a request for a
   single range, since a client that does not request multiple parts
   might not support multipart responses.
    </rfc>
    <ref to="msg.request.headers.range"/>
    <ref to="msg.headers.content_type"/>
  </error>

  <error id="1145">
    <title><st>206</st> response, but <h>ETag</h> doesn’t match <h ref="no">If-Range</h></title>
    <explain>The request’s <h ref="no">If-Range</h> header means that the server is expected to send a <st>206</st> response only if the representation’s <h>ETag</h> matches the one specified in If-Range. In this case, it doesn’t match, so the server is supposed to send a <st>200</st> response with the complete data.</explain>
    <explain>See <rfc num="7233" sect="3.2"/>.</explain>
    <ref to="msg.request.headers.if_range"/>
  </error>

  <comment id="1146">
    <title>Unnecessary <var ref="header"/> header</title>
    <rfc num="7233" sect="4.1">
      If a <st ref="no">206</st> is generated in response to a request with an <h ref="no">If-Range</h>
   header field, the sender SHOULD NOT generate other representation
   header fields beyond those required above, because the client is
   understood to already have a prior response containing those header
   fields.
    </rfc>
    <ref to="msg.request.headers.if_range"/>
  </comment>

  <error id="1147">
    <title><h>Content-Range</h> is undefined for <var ref="msg.status"/> responses</title>
    <explain>The <h>Content-Range</h> header is defined by <rfc num="7233" sect="4.2"/> for responses with status codes <st>206</st> and <st>416</st>, but not <var ref="msg.status"/>.</explain>
  </error>

  <error id="1148">
    <title>Invalid byte range in <var ref="place"/></title>
    <rfc num="7233" sect="4.2">
      A <h ref="no">Content-Range</h> field value is invalid if it contains a
   byte-range-resp that has a last-byte-pos value less than its
   first-byte-pos value, or a complete-length value less than or equal
   to its last-byte-pos value.
    </rfc>
  </error>

  <error id="1149">
    <title><st>416</st> response to request without <h ref="no">Range</h> makes no sense</title>
    <explain>The <st>416</st> status code is defined by <rfc num="7233" sect="4.4"/> only for responses to requests that have a <h ref="no">Range</h> header.</explain>
  </error>

  <comment id="1150">
    <title><st>416</st> response should have <h>Content-Range</h></title>
    <rfc num="7233" sect="4.4">
      When this status
   code is generated in response to a byte-range request, the sender
   SHOULD generate a <h>Content-Range</h> header field specifying the current
   length of the selected representation
    </rfc>
    <ref to="msg.request.headers.range"/>
  </comment>

  <error id="1151">
    <title>Empty list elements in <var ref="place"/> are forbidden</title>
    <rfc num="7230" sect="7">
      In any production that uses the list construct, a sender MUST NOT
   generate empty list elements.
    </rfc>
  </error>

  <error id="1152">
    <title><h>Cache-Control</h>: <var ref="directive"/> is for responses</title>
    <explain>This request’s <h>Cache-Control</h> header includes the <var ref="directive"/> directive, which is only defined for responses.</explain>
  </error>

  <error id="1153">
    <title><h>Cache-Control</h>: <var ref="directive"/> is for requests</title>
    <explain>This response’s <h>Cache-Control</h> header includes the <var ref="directive"/> directive, which is only defined for requests.</explain>
  </error>

  <comment id="1154">
    <title><h>Cache-Control</h>: <var ref="directive"/> should be quoted</title>
    <explain>The specification for the <var ref="directive"/> directive recommends wrapping its argument in double quotes. But in this message’s <h ref="no">Cache-Control</h> header, it is not quoted.</explain>
  </comment>

  <comment id="1155">
    <title><h>Cache-Control</h>: <var ref="directive"/> should not be quoted</title>
    <explain>In this message’s <h ref="no">Cache-Control</h> header, the argument to the <var ref="directive"/> directive is wrapped in double quotes. But the specification recommends writing it as a plain token, without quotes.</explain>
  </comment>

  <error id="1156">
    <title><var ref="entry"/>: <var ref="name"/> needs an argument</title>
    <explain>According to the specification, ‘<var ref="name"/>’ in <var ref="entry"/> must have an argument. But in this message, it doesn’t.</explain>
  </error>

  <error id="1157">
    <title><var ref="entry"/>: <var ref="name"/> can’t have an argument</title>
    <explain>In this message’s <var ref="entry"/> header, ‘<var ref="name"/>’ has an argument. But the specification defines no argument for ‘<var ref="name"/>’.</explain>
  </error>

  <error id="1158">
    <title>Syntax error in <var ref="place"/>: <var ref="name"/></title>
    <explain>“<var ref="value"/>” is not a correct value for ‘<var ref="name"/>’ in <var ref="place"/>.</explain>
    <exception/>
  </error>

  <error id="1159">
    <title><h>Cache-Control</h>: <cache>no-cache</cache> can’t have an argument</title>
    <explain>In this request’s <h>Cache-Control</h> header, the <cache>no-cache</cache> directive has an argument. But the specification for <cache>no-cache</cache> only defines an argument when used in responses.</explain>
  </error>

  <comment id="1160">
    <title><h>Pragma</h> other than ‘no-cache’ is deprecated</title>
    <explain>This message’s <h>Pragma</h> header includes ‘<var ref="pragma"/>’, but all pragmas other than ‘no-cache’ are deprecated in <rfc num="7234" sect="5.4"/>.</explain>
  </comment>

  <comment id="1161">
    <title>“<h>Cache-Control</h>: no-cache” should also have “<h>Pragma</h>: no-cache”</title>
    <rfc num="7234" sect="5.4">
      When sending a no-cache request, a client ought to include both the
   pragma and cache-control directives, unless <h>Cache-Control</h>: <cache>no-cache</cache>
   is purposefully omitted to target other Cache-Control response
   directives at HTTP/1.1 caches.
    </rfc>
  </comment>

  <comment id="1162">
    <title><h>Pragma</h>: no-cache is for requests</title>
    <explain>This response contains the ‘no-cache’ pragma directive, which is defined by <rfc num="7234" sect="5.4"/> only for requests.</explain>
    <!-- Not an error because very widespread and benign. -->
  </comment>

  <error id="1163">
    <title>Warn code <var ref="code"/> not in range 100—299</title>
    <explain><rfc num="7234" sect="5.5"/> defines two classes of warn codes: 1xx and 2xx. But this message’s <h>Warning</h> header contains a <var ref="code"/> code.</explain>
  </error>

  <error id="1164">
    <title><h>Warning</h> date must match the <h>Date</h> header</title>
    <explain>This message’s <h>Warning</h> header contains a warning (code <var ref="code"/>) with a date that does not match the <h>Date</h> header. This means that the warning was mistakenly kept after cache validation. As explained in <rfc num="7234" sect="5.5"/>, such warnings must be removed.</explain>
  </error>

  <error id="1165">
    <title>“<h>Warning</h>: <var ref="code"/>” is for responses</title>
    <explain>This request’s <h>Warning</h> header contains the <var ref="code"/> warn code. But, according to <rfc num="7234" sect="5.5"/>, 1xx warn codes can only be used on responses.</explain>
  </error>

  <error id="1166">
    <title>Response from cache needs an <h>Age</h> header</title>
    <explain>According to <rfc num="7234" sect="4"/>, a cache must add an <h>Age</h> header to every response that is served without contacting the origin server.</explain>
  </error>

  <error id="1167">
    <title>Status code <var ref="msg.status"/> not in range 100—599</title>
    <explain>According to <rfc num="7231" sect="6"/>, HTTP status codes can only range from 100 to 599.</explain>
  </error>

  <debug id="1168">
    <title><h>Age</h> header implies response from cache</title>
    <rfc num="7234" sect="5.1">
      The presence of an <h>Age</h> header field implies that the response was not
   generated or validated by the origin server for this request.
    </rfc>
  </debug>

  <debug id="1169">
    <title>“<h>Warning</h>: <var ref="code"/>” implies response from cache</title>
    <explain>This response’s <h>Warning</h> header contains the <var ref="code"/> warn code, which implies that it was served from a cache, without contacting the origin server. See <rfc num="7234" sect="5.5"/>.</explain>
  </debug>

  <comment id="1170">
    <title>Response from cache older than <cache>max-age</cache></title>
    <explain>This response’s <h>Age</h> of <var ref="msg.headers.age.value"/> is greater than the <cache>max-age</cache> of <var ref="msg.request.headers.cache_control.max_age"/> requested by the client’s <h ref="no">Cache-Control</h> header.</explain>
    <ref to="msg.request.headers.cache_control"/>
  </comment>

  <comment id="1171">
    <title><h>Cache-Control</h>: <var ref="directive"/> has no effect on <var ref="msg.method"/></title>
    <explain>The <var ref="msg.method"/> method is defined as non-cacheable, so the <var ref="directive"/> directive in this request’s <h>Cache-Control</h> header makes no difference.</explain>
  </comment>

  <error id="1172">
    <title>Response to <var ref="msg.request.method"/> can’t be served from cache</title>
    <explain>The <var ref="msg.request.method"/> method is defined as non-cacheable.</explain>
  </error>

  <error id="1173">
    <title>Response to “<h ref="no">Cache-Control</h>: <cache>no-cache</cache>” can’t be served from cache</title>
    <rfc num="7234" sect="5.2.1.4">
      The "no-cache" request directive indicates that a cache MUST NOT use
   a stored response to satisfy the request without successful
   validation on the origin server.
    </rfc>
    <ref to="msg.request.headers.cache_control"/>
  </error>

  <error id="1174">
    <title>Response to “<h ref="no">Pragma</h>: no-cache” can’t be served from cache</title>
    <rfc num="7234" sect="5.4">
      When the <h ref="no">Cache-Control</h> header field is not present in a request,
   caches MUST consider the no-cache request pragma-directive as having
   the same effect as if "Cache-Control: <cache>no-cache</cache>" were present
    </rfc>
    <ref to="msg.request.headers.pragma"/>
  </error>

  <error id="1175">
    <title>Response with “<h>Cache-Control</h>: <cache>no-cache</cache>” can’t be served from cache</title>
    <rfc num="7234" sect="5.2.2.2">
      The "no-cache" response directive indicates that the response MUST
   NOT be used to satisfy a subsequent request without successful
   validation on the origin server.
    </rfc>
  </error>

  <error id="1176">
    <title>Response with “<h>Cache-Control</h>: <cache>no-store</cache>” can’t be served from cache</title>
    <explain>According to <rfc num="7234" sect="3"/>, a cache cannot store a response that includes the <cache>no-store</cache> directive in its <h>Cache-Control</h> header.</explain>
  </error>

  <error id="1177">
    <title><var ref="msg.status"/> response can’t be served from cache by default</title>
    <explain>The <var ref="msg.status"/> status code is not defined as cacheable by default. According to <rfc num="7234" sect="3"/>, such a response can only be cached if it explicitly allows caching, with headers such as <h>Expires</h>. But this response has no such headers, so it is not cacheable.</explain>
  </error>

  <debug id="1178">
    <title>Heuristic freshness</title>
    <explain>Because this response has no explicit freshness controls (such as <h>Expires</h> or <cache>max-age</cache>), HTTPolice will assume that its expiration time was chosen heuristically by the cache. See <rfc num="7234" sect="4.2.2"/>.</explain>
  </debug>

  <debug id="1179">
    <title>“<h>Warning</h>: <warn>113</warn>” implies heuristic freshness</title>
    <explain>The <warn>113</warn> warn code in this response’s <h>Warning</h> header means that the expiration time for this response was chosen heuristically by the cache.</explain>
  </debug>

  <comment id="1180">
    <title>Heuristic freshness should have “<h>Warning</h>: <warn>113</warn>”</title>
    <rfc num="7234" sect="4.2.2">
      When a heuristic is used to calculate freshness lifetime, a cache
   SHOULD generate a <h>Warning</h> header field with a <warn>113</warn> warn-code (see
   Section 5.5.4) in the response if its current_age is more than 24
   hours and such a warning is not already present.
    </rfc>
    <ref to="msg.headers.age"/>
  </comment>

  <error id="1181">
    <title>Heuristic freshness can’t be used when <h>Expires</h> is present</title>
    <rfc num="7234" sect="4.2.2">
      A cache MUST NOT use heuristics to determine freshness when an
   explicit expiration time is present in the stored response.
    </rfc>
  </error>

  <error id="1182">
    <title>Heuristic freshness can’t be used when <cache>max-age</cache> is present</title>
    <rfc num="7234" sect="4.2.2">
      A cache MUST NOT use heuristics to determine freshness when an
   explicit expiration time is present in the stored response.
    </rfc>
    <ref to="msg.headers.cache_control"/>
  </error>

  <comment id="1183">
    <title>“<h>Warning</h>: <var ref="code"/>” implies response is stale</title>
    <explain>The <var ref="code"/> warn code in this response’s <h>Warning</h> header means that the response is stale, as defined by <rfc num="7234" sect="4.2"/>.</explain>
  </comment>

  <comment id="1184">
    <title>Response is stale because <h>Age</h> &gt; <cache>max-age</cache></title>
    <explain>This response’s <h>Age</h> is greater than the <cache>max-age</cache> specified in its <h>Cache-Control</h> header. This means that the response is stale, as defined by <rfc num="7234" sect="4.2"/>.</explain>
  </comment>

  <comment id="1185">
    <title>Response is stale because <h>Age</h> &gt; <h>Expires</h> − <h>Date</h></title>
    <explain>This response’s <h>Age</h> is greater than the difference between its <h>Expires</h> date and its <h>Date</h> header. This means that the response is stale, as defined by <rfc num="7234" sect="4.2"/>.</explain>
  </comment>

  <comment id="1186">
    <title>Stale response should have “<h ref="no">Warning</h>: <warn>110</warn>”</title>
    <rfc num="7234" sect="4.2.4">
      A cache SHOULD generate a Warning header field with the <warn>110</warn> warn-code
   (see Section 5.5.1) in stale responses.
    </rfc>
  </comment>

  <error id="1187">
    <title>Response with “<h>Cache-Control</h>: <cache>must-revalidate</cache>” can’t be served stale</title>
    <rfc num="7234" sect="5.2.2.1">
      The "must-revalidate" response directive indicates that once it has
   become stale, a cache MUST NOT use the response to satisfy subsequent
   requests without successful validation on the origin server.
    </rfc>
  </error>

  <comment id="1188">
    <title>Possibly wrong stale response</title>
    <rfc num="7234" sect="4.2.4">
      A cache MUST NOT send stale responses unless it is disconnected
   (i.e., it cannot contact the origin server or otherwise find a
   forward path) or doing so is explicitly allowed (e.g., by the
   <cache>max-stale</cache> request directive; see Section 5.2.1).
    </rfc>
    <explain>If the cache is disconnected, it should have added a <h ref="no">Warning</h> header with a <warn>112</warn> or <warn>111</warn> warn code to indicate that.</explain>
  </comment>

  <debug id="1189">
    <title>“<h>Warning</h>: <warn>214</warn>” means transformed by proxy</title>
    <explain>The <warn>214</warn> warn code in this message’s <h>Warning</h> header means that it was transformed by a proxy.</explain>
    <explain>See also <rfc num="7230" sect="5.7.2"/>.</explain>
  </debug>

  <debug id="1190">
    <title>Status <st>203</st> means transformed by proxy</title>
    <explain>The <st>203</st> status code means that this response was transformed by a proxy.</explain>
    <explain>See also <rfc num="7230" sect="5.7.2"/>.</explain>
  </debug>

  <error id="1191">
    <title>Transformed message needs “<h ref="no">Warning</h>: <warn>214</warn>”</title>
    <rfc num="7230" sect="5.7.2">
      A proxy that transforms a
   payload MUST add a Warning header field with the warn-code of <warn>214</warn>
   ("Transformation Applied") if one is not already in the message (see
   Section 5.5 of [RFC7234]).
    </rfc>
  </error>

  <error id="1192">
    <title>Transformation forbidden by “<h>Cache-Control</h>: <cache>no-transform</cache>”</title>
    <rfc num="7230" sect="5.7.2">
      A proxy MUST NOT transform the payload (Section 3.3 of [RFC7231]) of
   a message that contains a <cache>no-transform</cache> cache-control directive
   (Section 5.2 of [RFC7234]).
    </rfc>
  </error>

  <error id="1193">
    <title><h>Cache-Control</h>: <var ref="directive1"/> contradicts <var ref="directive2"/></title>
    <explain>This message’s <h>Cache-Control</h> header includes both the <var ref="directive1"/> and the <var ref="directive2"/> directives, which contradict each other.</explain>
  </error>

  <error id="1194">
    <title><st>401</st> response needs a <h>WWW-Authenticate</h> header</title>
    <rfc num="7235" sect="3.1">
      The server generating a 401 response MUST send
   a <h>WWW-Authenticate</h> header field (Section 4.1) containing at least one
   challenge applicable to the target resource.
    </rfc>
  </error>

  <error id="1195">
    <title><st>407</st> response needs a <h>Proxy-Authenticate</h> header</title>
    <rfc num="7235" sect="3.2">
      The proxy MUST send a
   <h>Proxy-Authenticate</h> header field (Section 4.3) containing a challenge
   applicable to that proxy for the target resource.
    </rfc>
  </error>

  <error id="1196">
    <title>‘realm’ parameter in <var ref="place"/> must be quoted</title>
    <explain>According to <rfc num="7235" sect="2.2"/>, the value of the ‘realm’ parameter must be enclosed in double quotes.</explain>
  </error>

  <comment id="1197">
    <title>Deprecated header <var ref="header"/></title>
    <explain>This message has the <var ref="header"/> header, which is listed as “obsoleted” or “deprecated” in the <cite title="IANA message headers registry" url="https://www.iana.org/assignments/message-headers/message-headers.xhtml"/>.</explain>
  </comment>

  <error id="1198">
    <title>“<h>Connection</h>: close” makes no sense in <var ref="msg.status"/> response</title>
    <explain>The <var ref="msg.status"/> status code means that this is an interim response, and more responses will follow on the same connection. But the ‘close’ option in this response’s <h>Connection</h> header means that the server will close the connection after sending this response.</explain>
  </error>

  <error id="1199">
    <title>“<h>Connection</h>: close” makes no sense in <var ref="msg.status"/> response to <m>CONNECT</m></title>
    <explain>A <var ref="msg.status"/> response to a <m>CONNECT</m> request means that this connection is becoming a tunnel. But the ‘close’ option in this response’s <h>Connection</h> header means that the server will close the connection after sending this response.</explain>
  </error>

  <comment id="1200">
    <title><st>428</st> response, but request has a <var ref="header"/> precondition</title>
    <explain>The <st>428</st> status code means that the server refuses to handle an unconditional request. But this request is conditional, because it has the <var ref="header"/> header.</explain>
    <!-- This is not an error because the server might not recognize this particular header. -->
  </comment>

  <comment id="1201">
    <title><st>428</st> response should include an explanation</title>
    <rfc num="6585" sect="3">
      Responses using this status code SHOULD explain how to resubmit the
   request successfully.
    </rfc>
  </comment>

  <error id="1202">
    <title><var ref="msg.status"/> response can’t be served from cache</title>
    <explain>According to the specification, the <var ref="msg.status"/> status code cannot be served from a cache.</explain>
  </error>

  <comment id="1203">
    <title><st>429</st> response should include an explanation</title>
    <rfc num="6585" sect="4">
      The response representations SHOULD include details explaining the
   condition, and MAY include a <h ref="no">Retry-After</h> header indicating how long
   to wait before making a new request.
    </rfc>
  </comment>

  <comment id="1204">
    <title><st>511</st> response should have a body</title>
    <rfc num="6585" sect="6">
      The response representation SHOULD contain a link to a resource that
   allows the user to submit credentials (e.g., with an HTML form).
    </rfc>
  </comment>

  <comment id="1205">
    <title><st>308</st> response should have a <h>Location</h> header</title>
    <rfc num="7538" sect="3">
      The server SHOULD generate a <h>Location</h> header field ([RFC7231],
   Section 7.1.2) in the response containing a preferred URI reference
   for the new permanent URI.
    </rfc>
  </comment>

  <error id="1206">
    <title><var ref="header"/>: <auth>Basic</auth> must have ‘realm’</title>
    <explain>The Basic authentication scheme requires a ‘realm’ parameter. See <rfc num="7617" sect="2"/>.</explain>
  </error>

  <error id="1207">
    <title><var ref="header"/>: <auth>Basic</auth> can’t have a ‘<var ref="param"/>’ parameter</title>
    <explain>No ‘<var ref="param"/>’ parameter is defined for the Basic authentication scheme. See <rfc num="7617" sect="2"/>.</explain>
  </error>

  <error id="1208">
    <title><var ref="header"/>: <auth>Basic</auth> can’t have a ‘<var ref="charset"/>’ charset</title>
    <explain>According to <rfc num="7617" sect="2.1"/>, the ‘charset’ parameter to the Basic authentication scheme can only have the value “UTF-8”.</explain>
  </error>

  <error id="1209">
    <title>Malformed <var ref="header"/>: <auth>Basic</auth></title>
    <explain>In the Basic authentication scheme, credentials are sent as a single Base64 string. See <rfc num="7617" sect="2"/>.</explain>
  </error>

  <error id="1210">
    <title>Malformed <var ref="header"/>: <auth>Basic</auth></title>
    <explain>In the Basic authentication scheme, the user ID and password are combined with a colon ‘:’ and packed into Base64. In this request’s <var ref="header"/> header, HTTPolice tried to decode them from Base64 and got the following error:</explain>
    <exception/>
    <explain>See <rfc num="7617" sect="2"/>.</explain>
  </error>

  <error id="1211">
    <title>Malformed <var ref="header"/>: <auth>Basic</auth></title>
    <explain>In the Basic authentication scheme, the user ID and password are combined with a colon ‘:’ and packed into Base64. But in this request’s <var ref="header"/> header, there is no ‘:’ after decoding from Base64. See <rfc num="7617" sect="2"/>.</explain>
  </error>

  <error id="1212">
    <title><var ref="header"/>: <auth>Basic</auth> can’t contain character <var ref="char"/></title>
    <rfc num="7617" sect="2">
      The user-id and password MUST NOT contain any control characters (see
   "CTL" in Appendix B.1 of [RFC5234]).
    </rfc>
  </error>

  <comment id="1213">
    <title><h>Content-Type</h>: <var ref="msg.headers.content_type.value"/> is not suitable for <m>PATCH</m></title>
    <explain>The <m>PATCH</m> method should only be used with media types that define how to apply the patch. <var ref="msg.headers.content_type.value"/> is not such a media type.</explain>
    <explain>See <rfc num="5789" errata="3169"/>.</explain>
    <explain>For example, <media>application/merge-patch+json</media> would be a suitable patch format for JSON.</explain>
  </comment>

  <comment id="1214">
    <title><var ref="msg.request.headers.content_type.value"/> patch should be rejected</title>
    <rfc num="5789" errata="3169">
      If a server receives a <m>PATCH</m>
   request with a media type whose specification does not define
   semantics specific to PATCH, the server SHOULD reject the request by
   returning the <st>415</st> Unsupported Media Type status code, unless a more
   specific error status code takes priority.
    </rfc>
    <ref to="msg.request.headers.content_type"/>
    <ref to="msg.status"/>
  </comment>

  <comment id="1215">
    <title><st>415</st> response to <m>PATCH</m> should have <h>Accept-Patch</h></title>
    <rfc num="5789" sect="2.2">
      Such a response SHOULD include an
      <h>Accept-Patch</h> response header as described in Section 3.1 to notify
      the client what patch document media types are supported.
    </rfc>
  </comment>

  <comment id="1216">
    <title>Should send <h>Accept-Patch</h> with “<h>Allow</h>: <m>PATCH</m>”</title>
    <explain>This <m>OPTIONS</m> response indicates in its <h>Allow</h> header that the <m>PATCH</m> method is supported. According to <rfc num="5789" sect="3.1"/>, in this case the server should also send an <h>Accept-Patch</h> header.</explain>
  </comment>

  <error id="1217">
    <title><h>Accept-Patch</h> implies “<h>Allow</h>: <m ref="no">PATCH</m>”</title>
    <explain>This response’s <h>Accept-Patch</h> header means that this resource supports the <m ref="no">PATCH</m> method, but it’s missing from the <h>Allow</h> header.</explain>
  </error>

  <error id="1218">
    <title>HSTS needs a ‘<hsts>max-age</hsts>’ directive</title>
    <explain>According to <rfc num="6797" sect="6.1.1"/>, a <h>Strict-Transport-Security</h> header must have a <hsts>max-age</hsts> directive.</explain>
  </error>

  <comment id="1219">
    <title>HSTS: <hsts>includeSubDomains</hsts> has no effect with <hsts>max-age</hsts>=0</title>
    <explain>The “<hsts>max-age</hsts>=0” directive in this response’s <h>Strict-Transport-Security</h> header tells the user agent to delete the HSTS policy for the domain. The <hsts>includeSubDomains</hsts> directive makes no difference in this case.</explain>
    <explain>See <rfc num="6797" sect="6.2"/>.</explain>
  </comment>

  <error id="1220">
    <title>Duplicate ‘<var ref="directive"/>’ directive in HSTS</title>
    <rfc num="6797" sect="6.1">
      All directives MUST appear only once in an STS header field.
    </rfc>
    <ref to="msg.headers.strict_transport_security"/>
  </error>

  <error id="1221">
    <title><h>Strict-Transport-Security</h> can’t be used without TLS</title>
    <rfc num="6797" sect="7.2">
      An HSTS Host MUST NOT include the STS header field in HTTP responses
   conveyed over non-secure transport.
    </rfc>
  </error>

  <error id="1222">
    <title>Impossible date in <var ref="place"/></title>
    <explain>“<var ref="date"/>” is not a valid date.</explain>
  </error>

  <error id="1223">
    <title>Impossible time in <var ref="place"/></title>
    <explain>“<var ref="time"/>” is not a valid time.</explain>
  </error>

  <error id="1224">
    <title>LF without CR in <var ref="place"/></title>
    <explain>Lines in HTTP message framing are terminated by two bytes: a carriage return (CR) followed by a line feed (LF). Some implementations accept a bare LF without CR, like in this message, but this is not reliable.</explain>
    <explain>See also <rfc num="7230" sect="3.5"/>.</explain>
  </error>

  <error id="1225">
    <title>Duplicate ‘<var ref="name"/>’ parameter in <var ref="place"/></title>
    <explain>According to <rfc num="8288" sect="3"/>, the ‘<var ref="name"/>’ parameter must not occur more than once in a single link.</explain>
  </error>

  <comment id="1226">
    <title>Deprecated ‘rev’ parameter in <var ref="place"/></title>
    <rfc num="8288" sect="3.3">
      rev is deprecated by this
   specification because it often confuses authors and readers; in most
   cases, using a separate relation type is preferable.
    </rfc>
  </comment>

  <comment id="1227">
    <title><var ref="patch_type"/> is not suitable for <h>Accept-Patch</h></title>
    <explain>The <m>PATCH</m> method should only be used with media types that define how to apply the patch. <var ref="patch_type"/> is not such a media type. But this response’s <h>Accept-Patch</h> header invites the client to send patches of type <var ref="patch_type"/>.</explain>
    <explain>See <rfc num="5789" errata="3169"/>.</explain>
    <explain>For example, <media>application/merge-patch+json</media> would be a suitable patch format for JSON.</explain>
  </comment>

  <error id="1228">
    <title><h>Upgrade</h>: h2 is wrong</title>
    <explain>This message’s <h>Upgrade</h> header includes the token ‘h2’, which normally refers to HTTP/2 over TLS. But HTTP/2 over TLS does not use the <h>Upgrade</h> mechanism, and cleartext HTTP/2 uses the ‘h2c’ token instead, so “Upgrade: h2” is wrong.</explain>
    <explain>See <rfc num="7540" sect="3"/>.</explain>
  </error>

  <error id="1230">
    <title><h>HTTP2-Settings</h> needs “<h>Connection</h>: http2-settings”</title>
    <rfc num="7540" sect="3.2.1">
      Since the upgrade is only intended to apply to the immediate
   connection, a client sending the <h>HTTP2-Settings</h> header field MUST
   also send "HTTP2-Settings" as a connection option in the <h>Connection</h>
   header field to prevent it from being forwarded
    </rfc>
  </error>

  <error id="1231">
    <title><h>Upgrade</h>: h2c needs <h>HTTP2-Settings</h></title>
    <rfc num="7540" sect="3.2.1">
      A request that upgrades from HTTP/1.1 to HTTP/2 MUST include exactly
   one "HTTP2-Settings" header field.
    </rfc>
  </error>

  <error id="1232">
    <title>Upgrading to HTTP/2 despite bad <h ref="no">HTTP2-Settings</h></title>
    <explain>According to <rfc num="7540" sect="3.2.1"/>, the server must not upgrade to HTTP/2 unless the request has exactly one valid <h ref="no">HTTP2-Settings</h> header.</explain>
    <ref to="msg.headers.upgrade"/>
    <ref to="msg.request.headers.http2_settings"/>
  </error>

  <error id="1233">
    <title><h>Upgrade</h>: h2c can’t be used on a TLS connection</title>
    <explain>An “<h>Upgrade</h>: h2c” header is used to switch to HTTP/2 from a cleartext HTTP/1.1 connection. But this message was sent on an encrypted (TLS) connection. HTTP/2 over TLS is negotiated by other means.</explain>
    <explain>See <rfc num="7540" sect="3"/>.</explain>
  </error>

  <error id="1234">
    <title>Malformed <h>HTTP2-Settings</h></title>
    <explain>According to <rfc num="7540" sect="3.2.1"/>, the <h>HTTP2-Settings</h> header must use the URL- and filename-safe Base64 encoding without padding. This means that it can only contain letters, digits, dash (-), and underscore (_).</explain>
  </error>

  <comment id="1235">
    <title><h>Vary</h>: <h ref="no">Host</h> is useless</title>
    <explain>There is no need to include <h ref="no">Host</h> in the <h>Vary</h> header, because Host is part of the request URI, and therefore, every HTTP response implicitly varies by Host already. “Vary: Host” can only scare caches away from storing the response.</explain>
    <explain>See <rfc num="7231" sect="7.1.4"/> and <rfc num="7234" sect="2"/>.</explain>
  </comment>

  <debug id="1236">
    <title>Absolute URI implies request to proxy</title>
    <explain>This request’s target is an absolute URI. According to <rfc num="7230" sect="5.3"/>, HTTP/1.1 clients only use this “absolute form” when connecting to proxies. Therefore, HTTPolice assumes that this request is to a proxy.</explain>
    <ref to="msg.target"/>
    <ref to="msg.version"/>
  </debug>

  <error id="1237">
    <title>Response to a direct request can’t be transformed by a proxy</title>
    <explain>It seems like this response was transformed by a proxy, but the request was not directed to a proxy.</explain>
  </error>

  <comment id="1238">
    <title><h>Cache-Control</h>: <var ref="directive1"/> has no effect with <var ref="directive2"/></title>
    <explain>This response’s <h>Cache-Control</h> header includes both the <var ref="directive1"/> and the <var ref="directive2"/> directives. But <var ref="directive1"/> makes no difference when <var ref="directive2"/> is present.</explain>
    <!-- This used to be part of no. 1193, but strictly speaking ``max-age`` does not contradict ``no-cache``, similarly ``s-maxage`` vs. ``private``, etc. -->
  </comment>

  <error id="1239">
    <title>Response to <m>HEAD</m> can’t have a body</title>
    <rfc num="7231" sect="4.3.2">
      The <m>HEAD</m> method is identical to <m>GET</m> except that the server MUST NOT
   send a message body in the response
    </rfc>
    <ref to="msg.displayable_body"/>
  </error>

  <error id="1240">
    <title><st>204</st> response can’t have a body</title>
    <rfc num="7231" sect="6.3.5">
      The 204 (No Content) status code indicates that the server has
   successfully fulfilled the request and that there is no additional
   content to send in the response payload body.
    </rfc>
    <ref to="msg.displayable_body"/>
  </error>

  <error id="1241">
    <title><h>Date</h> + <h>Age</h> is in the future</title>
    <explain>The <h>Date</h> header is the date and time when the response was originated. And the <h>Age</h> header is how long the response has been cached since then (or since it was revalidated). But in this response, the sum of <h>Date</h> + <h>Age</h> is in the future, so one of them must be wrong.</explain>
    <explain>This can happen when a cache mistakenly changes the <h>Date</h> header, or adds an <h>Age</h> header even though it is not a true HTTP cache (according to <rfc num="7234"/>).</explain>
    <explain>Also, this error can be caused by wrong timezone settings.</explain>
  </error>

  <comment id="1242">
    <title><st>451</st> response should include an explanation</title>
    <rfc num="7725" sect="3">
      Responses using this status code SHOULD include an explanation, in
   the response body, of the details of the legal demand: the party
   making it, the applicable legislation or regulation, and what classes
   of person and resource it applies to.
    </rfc>
  </comment>

  <comment id="1243">
    <title><st>451</st> response should have a ‘blocked-by’ link</title>
    <rfc num="7725" sect="4">
      When an entity blocks access to a resource and returns status 451, it
   SHOULD include a "<h>Link</h>" HTTP header field [RFC5988] whose value is a
   URI reference [RFC3986] identifying itself.  When used for this
   purpose, the "Link" header field MUST have a "rel" parameter whose
   value is "blocked-by".
    </rfc>
  </comment>

  <error id="1244">
    <title><var ref="header"/> header can’t be used in HTTP/2</title>
    <rfc num="7540" sect="8.1.2.2">
      An endpoint MUST NOT
   generate an HTTP/2 message containing connection-specific header
   fields
    </rfc>
    <rfc num="7540" sect="8.1.2.2">
      The only exception to this is the <h ref="no">TE</h> header field, which MAY be
   present in an HTTP/2 request; when it is, it MUST NOT contain any
   value other than "trailers".
    </rfc>
    <ref to="msg.version"/>
  </error>

  <error id="1245">
    <title><h>Upgrade</h> header can’t be used in HTTP/2</title>
    <rfc num="7540" sect="8.1.2.2">
      HTTP/2 purposefully does not support upgrade to another
      protocol.
    </rfc>
    <ref to="msg.version"/>
  </error>

  <error id="1246">
    <title><st>101</st> response can’t be used in HTTP/2</title>
    <rfc num="7540" sect="8.1.1">
      HTTP/2 removes support for the <st>101</st> (Switching Protocols)
   informational status code
    </rfc>
    <ref to="msg.version"/>
  </error>

  <error id="1247">
    <title>Duplicate ‘<var ref="param"/>’ parameter in <h>Content-Disposition</h></title>
    <rfc num="6266" sect="4.1">
      Content-Disposition header field values with multiple instances of
   the same parameter name are invalid.
    </rfc>
  </error>

  <comment id="1248">
    <title>Percent-encoded filename in <h>Content-Disposition</h> may cause problems</title>
    <rfc num="6266" appendix="D">
      Avoid including the percent character followed by two hexadecimal
      characters (e.g., %A9) in the filename parameter, since some
      existing implementations consider it to be an escape character,
      while others will pass it through unchanged.
    </rfc>
    <explain>Such a filename can be sent in the special ‘filename*’ parameter instead. See <rfc num="6266" sect="4.3"/>.</explain>
  </comment>

  <comment id="1249">
    <title>Backslash in filename in <h>Content-Disposition</h> may cause problems</title>
    <rfc num="6266" appendix="D">
      Avoid including the "\" character in the quoted-string form of the
      filename parameter, as escaping is not implemented by some user
      agents, and "\" can be considered an illegal path character.
    </rfc>
    <explain>Such a filename can be sent in the special ‘filename*’ parameter instead. See <rfc num="6266" sect="4.3"/>.</explain>
  </comment>

  <comment id="1250">
    <title>Non-ASCII filename in <h>Content-Disposition</h> may cause problems</title>
    <rfc num="6266" appendix="D">
      Avoid using non-ASCII characters in the filename parameter.
      Although most existing implementations will decode them as
      ISO-8859-1, some will apply heuristics to detect UTF-8, and thus
      might fail on certain names.
    </rfc>
    <explain>Such a filename can be sent in the special ‘filename*’ parameter instead. See <rfc num="6266" sect="4.3"/>.</explain>
  </comment>

  <comment id="1251">
    <title><h>Content-Disposition</h>: ‘filename*’ should also have ‘filename’ as fallback</title>
    <rfc num="6266" appendix="D">
      When a "filename*" parameter is sent, to also generate a
      "filename" parameter as a fallback for user agents that do not
      support the "filename*" form, if possible.
    </rfc>
  </comment>

  <comment id="1252">
    <title><h>Content-Disposition</h>: ‘filename*’ should come after ‘filename’</title>
    <rfc num="6266" appendix="D">
      When a "filename" parameter is included as a fallback (as per
      above), "filename" should occur first, due to parsing problems in
      some existing implementations.
    </rfc>
  </comment>

  <error id="1253">
    <title>Bad charset ‘<var ref="charset"/>’ in <var ref="place"/></title>
    <rfc num="8187" sect="3.2.1">
      Producers MUST use the "UTF-8" ([RFC3629]) character encoding.
   Extension character encodings (mime-charset) are reserved for future
   use.
    </rfc>
  </error>

  <error id="1254">
    <title>Bad <var ref="charset"/> value in <var ref="place"/></title>
    <explain>This message’s <var ref="place"/> contains a <var ref="charset"/> encoded value in the form defined by <rfc num="8187"/>. But HTTPolice tried to decode it from <var ref="charset"/> and got the following error:</explain>
    <exception/>
  </error>

  <error id="1256">
    <title>Bad encoding of protocol ID in <h>Alt-Svc</h></title>
    <explain>This message’s <h>Alt-Svc</h> contains a protocol ID encoded as “<var ref="actual"/>”. But according to <rfc num="7838" sect="3"/>, it must be encoded as “<var ref="correct"/>”.</explain>
  </error>

  <error id="1257">
    <title>Malformed authority in <h>Alt-Svc</h></title>
    <explain>“<var ref="authority"/>” is not a valid <h>Alt-Svc</h> authority, according to <rfc num="7838" sect="3"/>.</explain>
    <exception/>
  </error>

  <comment id="1258">
    <title>HTTP/2 should use ALTSVC frame instead of <h>Alt-Svc</h> header</title>
    <explain><rfc num="7838" sect="3"/> recommends using ALTSVC frames instead of the <h>Alt-Svc</h> header on HTTP/2 connections.</explain>
    <ref to="msg.version"/>
  </comment>

  <error id="1260">
    <title><st>421</st> response can’t have <h>Alt-Svc</h></title>
    <rfc num="7838" sect="6">
      An <h>Alt-Svc</h> header field in a <st>421</st> (Misdirected Request) response MUST
   be ignored.
    </rfc>
  </error>

  <error id="1261">
    <title><h>Authorization</h>: <auth>Bearer</auth> requires TLS</title>
    <rfc num="6750" sect="5.3">
      Clients MUST always use TLS [RFC5246]
      (https) or equivalent transport security when making requests with
      bearer tokens.  Failing to do so exposes the token to numerous
      attacks that could give attackers unintended access.
    </rfc>
  </error>

  <error id="1262">
    <title>Malformed <h>Authorization</h>: <auth>Bearer</auth></title>
    <explain>In the Bearer authentication scheme, credentials are sent as a single token. See <rfc num="6750" sect="2.1"/>.</explain>
  </error>

  <error id="1263">
    <title><h>WWW-Authenticate</h>: <auth>Bearer</auth> requires TLS</title>
    <explain>According to <rfc num="6750" sect="5.3"/>, bearer tokens must not be used without TLS. Instead of prompting the client to send a token on an insecure connection, perhaps it would be better to redirect to an ‘https:’ URI first.</explain>
  </error>

  <error id="1264">
    <title>Malformed <h>WWW-Authenticate</h>: <auth>Bearer</auth></title>
    <explain>A Bearer authentication challenge must have “key=value” parameters. See <rfc num="6750" sect="3"/>.</explain>
  </error>

  <error id="1265">
    <title>Duplicate ‘<var ref="param"/>’ parameter in “<h>WWW-Authenticate</h>: <auth>Bearer</auth>”</title>
    <explain>According to <rfc num="6750" sect="3"/>, the ‘<var ref="param"/>’ parameter must not appear more than once.</explain>
  </error>

  <error id="1266">
    <title>Malformed ‘<var ref="param"/>’ parameter in <h>WWW-Authenticate</h></title>
    <explain>“<var ref="value"/>” is not a correct value for a ‘<var ref="param"/>’ parameter in a <auth>Bearer</auth> challenge. See <rfc num="6750" sect="3"/>.</explain>
    <exception/>
  </error>

  <comment id="1267">
    <title>Declined a <auth>Bearer</auth> token, but no ‘error’ parameter</title>
    <rfc num="6750" sect="3">
      If the protected resource request included an access token and failed
   authentication, the resource server SHOULD include the "error"
   attribute to provide the client with the reason why the access
   request was declined.
    </rfc>
    <ref to="msg.request.headers.authorization"/>
    <ref to="msg.status"/>
    <ref to="msg.headers.www_authenticate"/>
  </comment>

  <comment id="1268">
    <title>Response with “error=<var ref="error_code"/>” should be <var ref="expected_status"/></title>
    <explain>According to <rfc num="6750" sect="3.1"/>, when the server’s <auth>Bearer</auth> challenge has “error=<var ref="error_code"/>”, the status code should be <var ref="expected_status"/>.</explain>
    <ref to="msg.status"/>
    <ref to="msg.headers.www_authenticate"/>
  </comment>

  <comment id="1269">
    <title>Unneeded ‘<var ref="param"/>’ in <h>WWW-Authenticate</h></title>
    <rfc num="6750" sect="3.1">
      If the request lacks any authentication information (e.g., the client
   was unaware that authentication is necessary or attempted using an
   unsupported authentication method), the resource server SHOULD NOT
   include an error code or other error information.
    </rfc>
  </comment>

  <comment id="1270">
    <title>Access token in URI is insecure</title>
    <explain>The query string of this request’s URI contains an ‘access_token’ parameter. It’s probably a bearer token, as defined in <rfc num="6750"/>.</explain>
    <rfc num="6750" sect="5.3">
      Bearer tokens SHOULD NOT be
      passed in page URLs (for example, as query string parameters).
      Instead, bearer tokens SHOULD be passed in HTTP message headers or
      message bodies for which confidentiality measures are taken.
      Browsers, web servers, and other software may not adequately
      secure URLs in the browser history, web server logs, and other
      data structures.  If bearer tokens are passed in page URLs,
      attackers might be able to steal them from the history data, logs,
      or other unsecured locations.
    </rfc>
    <ref to="msg.target"/>
  </comment>

  <comment id="1271">
    <title>Access token may need TLS</title>
    <explain>This request has an ‘access_token’ parameter. It’s probably a bearer token, as defined in <rfc num="6750"/>.</explain>
    <rfc num="6750" sect="5.3">
      Clients MUST always use TLS [RFC5246]
      (https) or equivalent transport security when making requests with
      bearer tokens.  Failing to do so exposes the token to numerous
      attacks that could give attackers unintended access.
    </rfc>
    <ref to="where"/>
  </comment>

  <comment id="1272">
    <title>Access token in URI needs “<h ref="no">Cache-Control</h>: no-store”</title>
    <explain>According to <rfc num="6750" sect="2.3"/>, if an access token is sent in the request URI, then the request should at least have a “<h ref="no">Cache-Control</h>: no-store” header. This reduces the risk of caches saving this token.</explain>
    <ref to="msg.target"/>
  </comment>

  <error id="1273">
    <title>Malformed <var ref="header"/>: <auth>Basic</auth></title>
    <explain>A Basic authentication challenge must have parameters as “key=value” pairs. See <rfc num="7617" sect="2"/>.</explain>
  </error>

  <error id="1274">
    <title><var ref="header"/> header without credentials</title>
    <explain>An <var ref="header"/> header usually consists of two parts: the name of the authentication scheme, and the actual credentials. But in this request, it only contains the scheme (“<var ref="header.value.item"/>”).</explain>
    <explain>Was something like “<var ref="header"/>: <auth>Bearer</auth> <var ref="header.value.item"/>” intended?</explain>
    <explain>See also <rfc num="7235" sect="2"/>.</explain>
    <!-- This is an error, not a comment, because it's hard to imagine a conformant use of ``credentials`` consisting only of the ``auth-scheme`` (in particular, none of the schemes registered with IANA allow this), whereas forgetting the ``auth-scheme`` is a common mistake. -->
  </error>

  <comment id="1275">
    <title>Entity declarations in XML may cause problems</title>
    <explain>This message’s XML content includes entity declarations (&lt;!ENTITY&gt;). Many XML applications do not process such declarations because they can lead to denial-of-service attacks.</explain>
    <ref to="msg.displayable_body"/>
  </comment>

  <comment id="1276">
    <title><var ref="header"/>: <var ref="wildcard"/> is as good as <var ref="value"/></title>
    <explain>The <var ref="header"/> header is not an ordered list. Whether <var ref="wildcard"/> comes before or after <var ref="value"/>, does not affect its priority. Only explicit quality values (q=) count.</explain>
    <explain>In other words, this request says that any <var ref="wildcard"/> is as acceptable as <var ref="value"/>.</explain>
    <explain>If <var ref="wildcard"/> is intended to be a fallback, it should have a lower quality value, for example: <var ref="wildcard"/>;q=0.1</explain>
    <explain>See <rfc num="7231" sect="5.3.1"/>.</explain>
    <!-- This is a comment, not an error, because e.g. Chrome, when fetching images, sends "Accept: image/webp,*/*", which makes perfect sense as "give me whatever you got, and btw I can do webp, too". -->
  </comment>

  <comment id="1277">
    <title>Obsolete ‘X-’ prefix in headers</title>
    <explain>Adding an ‘X-’ prefix to “experimental” headers is an old practice that is now considered obsolete. See <rfc num="6648" sect="3"/>.</explain>
    <explain>For custom headers that may be generally useful, it’s best to drop the ‘X-’ prefix (but check the <cite title="IANA message headers registry" url="https://www.iana.org/assignments/message-headers/message-headers.xhtml"/> to avoid collisions with existing names).</explain>
    <explain>For private headers not intended to be used by others, ‘X-’ can be replaced with something like the organization’s name.</explain>
    <ref to="headers"/>
  </comment>

  <comment id="1278">
    <title>Missing reverse stream</title>
    <explain>There is a stream file <var ref="path"/>, but there is no corresponding stream file for the reverse direction. HTTPolice will try to process this file on its own.</explain>
  </comment>

  <error id="1279">
    <title>Unprocessable streams</title>
    <explain>HTTPolice has found the following stream files:</explain>
    <explain>file 1: <var ref="path1"/></explain>
    <explain>file 2: <var ref="path2"/></explain>
    <explain>but cannot detect which of them is the inbound stream and which is the outbound.</explain>
    <explain>This means that the connection was not HTTP/1.x, or was encrypted, or that the files are somehow malformed. They will not be processed.</explain>
  </error>

  <comment id="1280">
    <title>‘charset’ parameter is undefined for <media>application/json</media></title>
    <explain>The <media>application/json</media> media type does not have a ‘charset’ parameter. <rfc num="8259" sect="11">Adding one really has no effect on compliant recipients.</rfc></explain>
    <ref to="header"/>
    <explain>See also <rfc num="8259" sect="8.1"/>.</explain>
  </comment>

  <error id="1281">
    <title><var ref="msg.guessed_charset"/> is a bad encoding for JSON</title>
    <rfc num="8259" sect="8.1">
      JSON text exchanged between systems that are not part of a closed
   ecosystem MUST be encoded using UTF-8
    </rfc>
    <ref to="msg.headers.content_type"/>
    <ref to="msg.displayable_body"/>
  </error>

  <error id="1282">
    <title>Wrong media type <var ref="bad"/> in <var ref="place"/></title>
    <explain>There is no such media type <var ref="bad"/>. Probably <var ref="good"/> was intended.</explain>
  </error>

  <comment id="1283">
    <title>Cacheable <st>421</st> response may cause problems</title>
    <explain><st>421</st> responses are defined as cacheable by default. However, because of how an HTTP cache works (<rfc num="7234" sect="2"/>), it is harmful to cache a 421 response, as it would be returned on subsequent requests to the same URI, without even trying to connect to the right server.</explain>
    <explain>To avoid this, a 421 response to <var ref="msg.request.method"/> should be marked as non-cacheable with a header like “<h>Cache-Control</h>: <cache>no-store</cache>”.</explain>
    <explain>See <rfc num="7540" errata="4666"/>.</explain>
  </comment>

  <comment id="1284">
    <title><st>202</st> response should have a body</title>
    <rfc num="7231" sect="6.3.3">
      The representation sent with this
   response ought to describe the request's current status and point to
   (or embed) a status monitor that can provide the user with an
   estimate of when the request will be fulfilled.
    </rfc>
  </comment>

  <comment id="1285">
    <title>Duplicate ‘<var ref="name"/>’ token in <h>Prefer</h></title>
    <rfc num="7240" sect="2">
      To avoid any possible ambiguity, individual preference tokens SHOULD
   NOT appear multiple times within a single request.
    </rfc>
  </comment>

  <error id="1286">
    <title><h>Preference-Applied</h>: <var ref="name"/><var ref="value"/> was not requested</title>
    <explain>“<h>Preference-Applied</h>: <var ref="name"/><var ref="value"/>” means that the server honored the client’s preference <var ref="name"/><var ref="value"/>. But the client did not request <var ref="name"/><var ref="value"/> in its <h>Prefer</h> header.</explain>
    <ref to="msg.request.headers.prefer"/>
  </error>

  <error id="1287">
    <title><var ref="msg.method"/> request cannot <h>Prefer</h>: <prefer>respond-async</prefer></title>
    <explain>The whole point of a <var ref="msg.method"/> request is to retrieve information from the server. It’s impossible to respond asynchronously to such a request: the response would not contain the requested information.</explain>
    <explain>If the intention was to submit a task that would eventually send the results somewhere, this submission itself should probably be a <m>POST</m>.</explain>
  </error>

  <error id="1288">
    <title><m>GET</m> request cannot <h>Prefer</h>: <prefer>return</prefer>=minimal</title>
    <explain>The whole point of a <m>GET</m> request is to retrieve a representation of the resource (as in “<prefer>return</prefer>=representation”). There is no “minimal” response that could satisfy this request.</explain>
    <explain>Instead, the <h>Accept</h> header could be used to select the desired kind of representation.</explain>
  </error>

  <error id="1289">
    <title><h>Prefer</h>: <prefer>return</prefer>=minimal contradicts <prefer>return</prefer>=representation</title>
    <rfc num="7240" sect="4.2">
      The "return=minimal" and "return=representation" preferences are
   mutually exclusive directives.
    </rfc>
  </error>

  <error id="1290">
    <title><h>Prefer</h>: <prefer>handling</prefer>=strict contradicts <prefer>handling</prefer>=lenient</title>
    <rfc num="7240" sect="4.4">
      The "handling=strict" and "handling=lenient" preferences are mutually
   exclusive directives.
    </rfc>
  </error>

  <comment id="1291">
    <title>Response with <h>Preference-Applied</h> may need “<h>Vary</h>: <h>Prefer</h>”</title>
    <rfc num="7240" sect="2">
      If a server supports the optional
   application of a preference that might result in a variance to a
   cache's handling of a response entity, a <h>Vary</h> header field MUST be
   included in the response listing the <h>Prefer</h> header field
    </rfc>
    <ref to="msg.request.headers.prefer"/>
  </comment>

  <error id="1292">
    <title>Invalid method ‘<var ref="msg.method"/>’</title>
    <exception/>
  </error>

  <error id="1293">
    <title>Invalid field name ‘<var ref="header"/>’</title>
    <exception/>
  </error>

  <error id="1294">
    <title>Syntax error in reason phrase</title>
    <exception/>
    <ref to="msg.status"/>
  </error>

  <error id="1295">
    <title>Method ‘<var ref="msg.method"/>’ should probably be ‘<var ref="uppercase"/>’</title>
    <rfc num="7231" sect="4.1">The method token is case-sensitive</rfc>
  </error>

  <error id="1296">
    <title>Duplicate ‘<var ref="param"/>’ parameter in <var ref="entry"/></title>
    <rfc num="7239" sect="4">
      Each parameter MUST NOT occur more than once per field-value.
    </rfc>
  </error>

  <comment id="1297">
    <title>Possibly bad syntax in <var ref="entry"/></title>
    <explain>The <h ref="no">Forwarded</h> header here contains <var ref="n_elements"/> elements, describing <var ref="n_elements"/> proxy hops, with only one parameter for each proxy — yet all parameters have different names.</explain>
    <explain>If this was intended to be <var ref="n_elements"/> parameters for a single proxy hop, then the pairs must be separated with semicolons, not commas.</explain>
  </comment>

  <debug id="1298">
    <title>Body is too long to be checked</title>
    <explain>This message’s <var ref="place"/> indicates that the body is at least <var ref="size"/> bytes long. HTTPolice does not attempt to process bodies longer than <var ref="max_size"/> bytes. The rest of the stream will not be processed either.</explain>
  </debug>

  <comment id="1299">
    <title>Quoted comma in <var ref="entry"/> might confuse a naive parser</title>
    <explain>This message’s <var ref="entry"/> header contains a comma inside a quoted string. But experience shows that headers like <var ref="entry"/> are often parsed without regard for quoted strings—such a naive parser might interpret this comma as a separator between <var ref="entry"/> elements. If possible, avoiding this comma might help interoperability.</explain>
  </comment>

  <comment id="1300">
    <title>Quoted semicolon in <var ref="entry"/> might confuse a naive parser</title>
    <explain>This message’s <var ref="entry"/> header contains a semicolon inside a quoted string. But experience shows that headers like <var ref="entry"/> are often parsed without regard for quoted strings—such a naive parser might interpret this semicolon as a separator between <var ref="entry"/> parameters. If possible, avoiding this semicolon might help interoperability.</explain>
  </comment>

  <comment id="1301">
    <title><h>Cache-Control</h>: <cache>immutable</cache> probably needs <cache>max-age</cache></title>
    <explain>“<h>Cache-Control</h>: <cache>immutable</cache>” is typically only useful with a large <cache>max-age</cache> or an <h>Expires</h> far in the future, because immutable applies only for as long as the response is considered fresh. Without explicit max-age or Expires, most caches will consider this response fresh only for a brief period or not at all.</explain>
  </comment>

  <comment id="1302">
    <title><h>Cache-Control</h>: <cache>immutable</cache> may be ignored without TLS</title>
    <rfc num="8246" section="3">
      Clients SHOULD ignore the <cache>immutable</cache> extension from resources that
      are not part of an authenticated context such as HTTPS.
    </rfc>
  </comment>

  <comment id="1303">
    <title><h>Cache-Control</h>: <cache>immutable</cache> may be ignored without response length</title>
    <rfc num="8246" section="3">
      Clients SHOULD ignore the <cache>immutable</cache> extension for resources that
      do not provide a strong indication that the stored response size
      is the correct response size such as responses delimited by
      connection close.
    </rfc>
  </comment>

  <error id="1304">
    <title><var ref="msg.status"/> response after <var ref="previous.status"/></title>
    <explain>It appears like this <var ref="msg.status"/> response was preceded by a <var ref="previous.status"/> response to the same request. But a <var ref="previous.status"/> response can only be the final response to a request. See also <rfc num="7231" sect="6.2"/>.</explain>
    <explain>This is more likely to be a bug in your HTTPolice integration than in the actual HTTP traffic being inspected. For example, responses to different requests may have been mixed up somehow.</explain>
  </error>

  <error id="1305">
    <title>Expected <st>100</st> (Continue) before switching protocols</title>
    <rfc num="7230" sect="6.7">
      If a server receives both an <h ref="no">Upgrade</h> and an <h>Expect</h> header field with
   the "100-continue" expectation (Section 5.1.1 of [RFC7231]), the
   server MUST send a <st>100</st> (Continue) response before sending a <st>101</st>
   (Switching Protocols) response.
    </rfc>
    <ref to="msg.request.headers.expect"/>
  </error>

  <error id="1306">
    <title>Response to <var ref="msg.request.version"/> can’t have <h>Transfer-Encoding</h></title>
    <rfc num="7231" sect="3.3.1">
      A server MUST NOT send a
   response containing Transfer-Encoding unless the corresponding
   request indicates HTTP/1.1 (or later).
    </rfc>
  </error>

  <comment id="1307">
    <title>Unquoted ‘title’ parameter in <var ref="place"/> may cause problems</title>
    <rfc num="8288" sect="3">
      Previous definitions of the Link header did not equate the token and
   quoted-string forms explicitly; the title parameter was always
   quoted, and the hreflang parameter was always a token.  Senders
   wishing to maximize interoperability will send them in those forms.
    </rfc>
  </comment>

  <comment id="1308">
    <title>Quoted ‘hreflang’ parameter in <var ref="place"/> may cause problems</title>
    <rfc num="8288" sect="3">
      Previous definitions of the Link header did not equate the token and
   quoted-string forms explicitly; the title parameter was always
   quoted, and the hreflang parameter was always a token.  Senders
   wishing to maximize interoperability will send them in those forms.
    </rfc>
  </comment>

  <error id="1309">
    <title>Missing ‘rel’ parameter in <var ref="place"/></title>
    <rfc num="8288" sect="3.3">
      The rel parameter MUST be
   present
    </rfc>
  </error>

  <error id="1310">
    <title><h>Accept-Post</h> implies “<h>Allow</h>: <m ref="no">POST</m>”</title>
    <explain>This response’s <h>Accept-Post</h> header means that this resource supports the <m ref="no">POST</m> method, but it’s missing from the <h>Allow</h> header.</explain>
  </error>

</notices>
