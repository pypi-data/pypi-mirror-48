import shutil
import json
import os

from pathlib import Path, PosixPath
from subprocess import run, PIPE, STDOUT, CalledProcessError
from pkg_resources import resource_filename
from uuid import uuid1

from foliant.utils import spinner
from foliant.backends.base import BaseBackend

from .sidebars import generate_sidebars, SideBars
from .index import INDEX_HTML

ASSETS_DIR_NAME = 'DOCUSAURUS_ASSETS'


def flatten_seq(seq):
    """convert a sequence of embedded sequences into a plain list"""
    result = []
    vals = seq.values() if type(seq) == dict else seq
    for i in vals:
        if type(i) in (dict, list):
            result.extend(flatten_seq(i))
        else:
            result.append(i)
    return result


class FlatChapters:
    """
    Helper class converting chapter list of complicated structure
    into a plain list of chapter names or path to actual md files
    in the src dir.
    """

    def __init__(self,
                 chapters: list,
                 parent_dir: PosixPath = Path('src')):
        self._chapters = chapters
        self._parent_dir = parent_dir

    def __len__(self):
        return len(self.flat)

    def __getitem__(self, ind: int):
        return self.flat[ind]

    def __contains__(self, item: str):
        return item in self.flat

    def __iter__(self):
        return iter(self.flat)

    @property
    def flat(self):
        """Flat list of chapter file names"""
        return flatten_seq(self._chapters)

    @property
    def list(self):
        """Original chapters list"""
        return self._chapters

    @property
    def paths(self):
        """Flat list of PosixPath objects relative to project root."""
        return (self._parent_dir / chap for chap in self.flat)


class Backend(BaseBackend):
    targets = ('site', 'docus')

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

        self._docus_config = self.config.get('backend_config', {}).get('docus', {})
        self._cachedir = Path(self._docus_config.get('cache_dir', '.docuscache'))
        self._srcdir = self.project_path / self.config['src_dir']
        self._docus_site_dir_name = f'{self._docus_config.get("slug", self.get_slug())}.docus'

        self._docus_project_dir_name = f'{self._docus_site_dir_name}.src'

        self.required_preprocessors_after = {
            'docus': {
                'docus_cachedir': self._cachedir
            }
        },

        self.logger = self.logger.getChild('docus')

        self.logger.debug(f'Backend inited: {self.__dict__}')

    def _process_config(self, config: dict):
        FILE_FIELDS = ['favicon', 'headerIcon', 'footerIcon',
                       'ogImage', 'twitterImage']
        WEBSITE_ASSETS_DIR_NAME = 'assets'

        def copy_asset(file: PosixPath or str) -> str:
            '''copy file to assets dir and return path to copied file'''
            new_filename = str(uuid1()) + os.path.splitext(file)[1]
            shutil.copyfile(file, assets_dir / new_filename)
            return str(Path(WEBSITE_ASSETS_DIR_NAME) / new_filename)

        assets_dir = self._cachedir / 'website' / 'static' / WEBSITE_ASSETS_DIR_NAME
        shutil.rmtree(assets_dir, ignore_errors=True)
        assets_dir.mkdir()

        result = dict(config)
        for k, v in config.items():
            if k in FILE_FIELDS and not v.startswith('http'):
                result[k] = copy_asset(v)
        return result

    def _create_cache_dir(self):
        if self._cachedir.exists() and\
                (self._cachedir / 'docs').exists() and\
                (self._cachedir / 'website').exists():
            return  # docus project already inited
        else:
            self._cachedir.mkdir(exist_ok=True)
            try:
                run(
                    'docusaurus-init',
                    shell=True,
                    check=True,
                    stdout=PIPE,
                    stderr=STDOUT,
                    cwd=str(self._cachedir)
                )
                return
            except CalledProcessError as exception:
                raise RuntimeError(f'Build failed: {exception.output.decode()}')

    def _sync_docs(self):
        # preparing docs
        docs_path = self._cachedir / 'docs'
        shutil.rmtree(docs_path, ignore_errors=True)  # cleaning docs
        docs_path.mkdir()

        title = self.config.get('title', 'main')

        chapters = FlatChapters(self.config['chapters'])
        for chapter in chapters:
            file_to_copy = self.working_dir / chapter
            dest_folder = (docs_path / chapter).parent
            if not dest_folder.exists():
                dest_folder.mkdir(parents=True)
            shutil.copy(str(file_to_copy), str(dest_folder))

        # copy assets (generated by Docus preprocessor)
        shutil.copytree(self.working_dir / ASSETS_DIR_NAME,
                        docs_path / 'assets')

        # generate sidebars.json
        sidebars = generate_sidebars(title,
                                     self.config['chapters'],
                                     chapters_root=self.working_dir)
        with open(self._cachedir / 'website' / 'sideBars.json',
                  'w', encoding='utf8') as f:
            json.dump(sidebars.as_obj(), f, indent=4)

        # replace siteConfig.js
        shutil.copyfile(resource_filename(__name__,
                                          'assets/siteConfig.js'),
                        self._cachedir / 'website/siteConfig.js')
        config = {'title': title,
                  'headerLinks': self.create_header_links(sidebars),
                  **self._process_config(self._docus_config)}

        # replace Footer.js
        if 'footer' in self._docus_config:
            new_footer = self._docus_config['footer']
        else:
            new_footer = resource_filename(__name__,
                                           'assets/Footer.js')
        shutil.copyfile(new_footer,
                        self._cachedir / 'website/core/Footer.js')

        # generate siteConf.json
        with open(self._cachedir / 'website' / 'siteConf.json', 'w') as f:
            json.dump(config, f, indent=4)

        # copy pages
        pages_path = self._cachedir / 'website' / 'pages'
        shutil.rmtree(pages_path, ignore_errors=True)
        pages_path.mkdir()
        if 'pages' in self._docus_config:
            for page in self._docus_config['pages']:
                shutil.copyfile(page,
                                pages_path)

        # copy styles
        styles_path = self._cachedir / 'website' / 'static' / 'css'
        shutil.rmtree(styles_path, ignore_errors=True)
        styles_path.mkdir()
        if 'styles' in self._docus_config:
            for style in self._docus_config['styles']:
                shutil.copyfile(style,
                                styles_path)

        # add new redirect index page
        with open(self._cachedir / 'website' / 'static' / 'index.html', 'w') as f:
            f.write(INDEX_HTML.format(title=title,
                                      doc_id=sidebars.get_first_doc().as_obj()))

    def create_header_links(self, sidebars: SideBars):
        result = [{'doc': sb.get_first_doc().as_obj(), 'label': sb.name}
                  for sb in sidebars]

        # algolia is external search service used by Docusaurus. If its config
        # is specified, we assume that user wants search bar added to header
        if 'algolia' in self._docus_config:
            result.append({'search': True})
        return result

    def make(self, target: str) -> str:
        with spinner(f'Making {target} with Docusaurus', self.logger, self.quiet, self.debug):
            try:
                self._create_cache_dir()
                self._sync_docs()
                if target == 'docus':
                    shutil.rmtree(self._docus_project_dir_name, ignore_errors=True)
                    shutil.copytree(self._cachedir, self._docus_project_dir_name)

                    return self._docus_project_dir_name

                elif target == 'site':
                    try:
                        shutil.rmtree(self._docus_site_dir_name, ignore_errors=True)
                        run(
                            'docusaurus-build',
                            shell=True,
                            check=True,
                            stdout=PIPE,
                            stderr=STDOUT,
                            cwd=str(self._cachedir / 'website')
                        )
                        shutil.copytree(self._cachedir / 'website' / 'build',
                                        self._docus_site_dir_name)

                        return self._docus_site_dir_name

                    except CalledProcessError as exception:
                        raise RuntimeError(f'Build failed: {exception.output.decode()}')
                else:
                    raise ValueError(f'Docusaurus cannot make {target}')

            except Exception as exception:
                raise type(exception)(f'Build failed: {exception}')
