# coding: utf-8

#
# Copyright 2018 Radiant Solutions
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#         http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

"""
    DeepCore Server
    A server that runs object detection models

    OpenAPI spec version: 1.3.2-SNAPSHOT
    Contact: deepcore-support@digitalglobe.com
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from deepcore_server.api_client import ApiClient


class RunnerApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def delete_runner(self, runner_id, **kwargs):  # noqa: E501
        """Delete a job runner and logs, stopping it if necessary  # noqa: E501

        This is used to delete a runner.  Any jobs that are in progress on that runner are marked as FAILED.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_runner(runner_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str runner_id: ID of the job runner (required)
        :return: DeletedMessage
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_runner_with_http_info(runner_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_runner_with_http_info(runner_id, **kwargs)  # noqa: E501
            return data

    def delete_runner_with_http_info(self, runner_id, **kwargs):  # noqa: E501
        """Delete a job runner and logs, stopping it if necessary  # noqa: E501

        This is used to delete a runner.  Any jobs that are in progress on that runner are marked as FAILED.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_runner_with_http_info(runner_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str runner_id: ID of the job runner (required)
        :return: DeletedMessage
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['runner_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_runner" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'runner_id' is set
        if ('runner_id' not in params or
                params['runner_id'] is None):
            raise ValueError("Missing the required parameter `runner_id` when calling `delete_runner`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'runner_id' in params:
            path_params['runnerId'] = params['runner_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/runner/{runnerId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DeletedMessage',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_capacity(self, **kwargs):  # noqa: E501
        """Maximum number of runners  # noqa: E501

        This is to obtain the maximum number of runners that may be loaded at the same time.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_capacity(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: int
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_capacity_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_capacity_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_capacity_with_http_info(self, **kwargs):  # noqa: E501
        """Maximum number of runners  # noqa: E501

        This is to obtain the maximum number of runners that may be loaded at the same time.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_capacity_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: int
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_capacity" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/runners/capacity', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='int',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_log(self, runner_id, **kwargs):  # noqa: E501
        """Get the runner log  # noqa: E501

        This obtains the logs from runner processing.  Logs are unstructured.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_log(runner_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str runner_id: ID of the job runner (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_log_with_http_info(runner_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_log_with_http_info(runner_id, **kwargs)  # noqa: E501
            return data

    def get_log_with_http_info(self, runner_id, **kwargs):  # noqa: E501
        """Get the runner log  # noqa: E501

        This obtains the logs from runner processing.  Logs are unstructured.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_log_with_http_info(runner_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str runner_id: ID of the job runner (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['runner_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_log" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'runner_id' is set
        if ('runner_id' not in params or
                params['runner_id'] is None):
            raise ValueError("Missing the required parameter `runner_id` when calling `get_log`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'runner_id' in params:
            path_params['runnerId'] = params['runner_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/runner/{runnerId}/log', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_runner(self, runner_id, **kwargs):  # noqa: E501
        """Get status of a job runner  # noqa: E501

        This is used to get the status of the runner.  While alive, the runner alternates between Running and Idle.  Additionally, Starting and Stopping states are used during the beginning and end of life of the runner.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_runner(runner_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str runner_id: ID of the job runner (required)
        :return: RunnerStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_runner_with_http_info(runner_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_runner_with_http_info(runner_id, **kwargs)  # noqa: E501
            return data

    def get_runner_with_http_info(self, runner_id, **kwargs):  # noqa: E501
        """Get status of a job runner  # noqa: E501

        This is used to get the status of the runner.  While alive, the runner alternates between Running and Idle.  Additionally, Starting and Stopping states are used during the beginning and end of life of the runner.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_runner_with_http_info(runner_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str runner_id: ID of the job runner (required)
        :return: RunnerStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['runner_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_runner" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'runner_id' is set
        if ('runner_id' not in params or
                params['runner_id'] is None):
            raise ValueError("Missing the required parameter `runner_id` when calling `get_runner`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'runner_id' in params:
            path_params['runnerId'] = params['runner_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/runner/{runnerId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RunnerStatus',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_runners(self, **kwargs):  # noqa: E501
        """Lists job runners  # noqa: E501

        This is used to obtain a list of ids for the runners which are loaded into the system.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_runners(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: IdList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_runners_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_runners_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_runners_with_http_info(self, **kwargs):  # noqa: E501
        """Lists job runners  # noqa: E501

        This is used to obtain a list of ids for the runners which are loaded into the system.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_runners_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: IdList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_runners" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/runners', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='IdList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def shutdown_runner(self, runner_id, **kwargs):  # noqa: E501
        """Shutdown a job runner  # noqa: E501

        This is used to stop a runner in progress.  Any jobs that are in progress on that runner are marked as FAILED.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.shutdown_runner(runner_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str runner_id: ID of the job runner (required)
        :return: DeletedMessage
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.shutdown_runner_with_http_info(runner_id, **kwargs)  # noqa: E501
        else:
            (data) = self.shutdown_runner_with_http_info(runner_id, **kwargs)  # noqa: E501
            return data

    def shutdown_runner_with_http_info(self, runner_id, **kwargs):  # noqa: E501
        """Shutdown a job runner  # noqa: E501

        This is used to stop a runner in progress.  Any jobs that are in progress on that runner are marked as FAILED.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.shutdown_runner_with_http_info(runner_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str runner_id: ID of the job runner (required)
        :return: DeletedMessage
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['runner_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method shutdown_runner" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'runner_id' is set
        if ('runner_id' not in params or
                params['runner_id'] is None):
            raise ValueError("Missing the required parameter `runner_id` when calling `shutdown_runner`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'runner_id' in params:
            path_params['runnerId'] = params['runner_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/runner/{runnerId}/process', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DeletedMessage',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
