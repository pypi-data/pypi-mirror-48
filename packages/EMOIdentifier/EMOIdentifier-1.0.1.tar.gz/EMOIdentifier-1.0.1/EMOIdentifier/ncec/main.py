'''
This file contains main function of segmentation approach. Implementation of the approach is distributed across multiple python files.

1. Input graph file must start its vertex label from 0. labels written in input are taken as it is.
2. All nested edges are included in Adj matrix at the end of segmentation process. Label for such edges is 3.
3. Output					:	Three files are generated by this program.

		a) *Input_ncec.dot	:	It is input graph in dot format
		b) *_ncec.dot		:	It is segment graph in dot format
		c) *_dump			:	It contains whole output like nested seg list and detailed segment vertex labels
		d) *_compound		:	It contains list of each segment one per line

4. How to run 				:	python main.py Input_file (generated by sdgExtractor)

'''

import sys
import os
import config	#	contains global variables
import graph	#	contains code realted to graph reading/display
import dotGenerator	#	code for generating dot file
import populateVHash as pvh	#	vHash is populated by reading "*ctrlLoc" file and source vertices present in the graph
import output	#	code for producing final output and removing temporary files
import segmentation as sg	#	code for segmentation approach
import precomputation as pc
from subprocess import call
import sdgExtractor as sdg
import generateParameters as gp	#	for parameter generation



def formattedOutput(fname):
	fp = open(fname+".result", "w")
	loc = 0
	config.segList.sort()
	for key in config.segment.keys():
		if loc<len(config.segList) and key == config.segList[loc] and len(config.segment[key]) >1:
			config.segment[key]
			config.segment[key].sort()
			loc = loc +1
			for elt in config.segment[key]:
				fp.write(str(elt) + " ")
			fp.write("\n")
	fp.close()



def clean(fpath):
	os.remove(fpath+"CtrlLoc")
	os.remove(fpath+".tk1")
#	os.remove(fpath+"_parmtr")
def extractMethods(fpath):

	config.log = open(fpath+ "log","w")

	config.init()	#	Initialize all the global variables
	adj = graph.read_graph(fpath)
#	dotGenerator.generate_dot(adj,fpath+"Input")
	config.log.write("\n----- Main()\n")
	config.log.write("\t\t Input File Name : "+ fpath + "\n")

	ctrList = pvh.read_CtrlLoc(fpath)
	pvh.InsertSource(adj) # used in get_iter_p_index
	config.log.write("\t\tVertexHash Contents :\t"  + str(config.vHash) +"\n")

	pc.precomputations(adj, ctrList)

	if config.flag['InGr']!=0:
		config.log.write("\t\tInput Graph:\n")
		graph.write(adj, config.log)

	adj = sg.segmentation(adj,ctrList)

#	commented the call to gp.generate(adj,fpath) method on June 10, 2019. Reason: Generates error.
#	config.log.write("Calling argument generator\n")
#	gp.generate(adj,fpath)	#Added on January 9, 2019

#	output.dump_output(adj)

#	remove_help_files(sys.argv[1])	#added on 4 July
#	subprocess.call(["rm", "*.pyc")
	config.log.write("This is last of log.\n")
	config.log.close()

	formattedOutput(sys.argv[1])
#	clean(fpath)
#----------------------------Main method is below----------------------
def main():

	if len(sys.argv)<2:
		print "Insufficient number of arguments supplied"
		print "Program terminating ..."
		sys.exit(0)
	
	sdg.extractSDG(sys.argv[1])	#	This is required only if you have to parse xyz.tk file and generate SDG.
	extractMethods(sys.argv[1])

if __name__=="__main__":
	main()
