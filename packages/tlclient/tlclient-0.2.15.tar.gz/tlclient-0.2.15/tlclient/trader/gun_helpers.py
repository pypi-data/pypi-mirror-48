# auto generated by update_py.py
import json
import os
import time

import tlclient.linker.message_comm as message
from tlclient.linker.constant import FistType, MsgType
from tlclient.linker.fist import Fist
from tlclient.linker.frame import Frame
from tlclient.linker.timer import Timer
from tlclient.linker.utility import bytify

FIST_READY_MARK = '$FIST_READY$'
DEFAULT_LATEST_CONFIG_VERSION = "0.3"


class GunStartHelper(object):

    proc_types = {
        FistType.MARKET_GATEWAY: 'mg',
        FistType.TRADE_GATEWAY: 'tg',
        FistType.MARKET_ROUTER: 'mr',
        FistType.TRADE_ROUTER: 'tr',
        FistType.ORDER_MANAGER: 'oms',
        FistType.RISK_MANAGER: 'rr',
    }

    @classmethod
    def to_proc_type(cls, fist_type):
        fist_type_code = FistType.parse(fist_type)
        return cls.proc_types.get(fist_type_code)

    @classmethod
    def to_gun_start_cmd(cls, config):
        cmd = 'gun start -t {} -f {} -a {} -g {} -r {} -d'
        cmd = cmd.format(
            cls.to_proc_type(config['fist_type']),  # -t
            config['fist_name'],                    # -f
            config['fist_name'],                    # -a
            config.get('gateway_name'),             # -g
            config.get('router_name'),              # -r
        )
        return cmd


class GunClientHelper(object):

    def __init__(self, fist_name, config_path=None, env_name=None, master_addr=None):
        if env_name is None or master_addr is None:
            j = json.load(open(config_path))
            # init recorder
            env_name = j['env']
            master_addr = j['master_rep']
        self.fist_client = Fist(fist_name, FistType.BASE, env_name, master_addr)
        self.fist_client.reg_req_master()
        # force to set LINGER=0
        import zmq
        self.fist_client.req_master_sock.setsockopt(zmq.LINGER, 0)

    def stop(self, fist_name):
        req = message.ReqFistSuicide()
        req.fist_name = bytify(fist_name)
        f = Frame()
        f.set_msg_type(MsgType.CMD_SUICIDE)
        f.set_nano(Timer.nano())
        f.set_data(req)
        try:
            self.fist_client.req_master(f)
        except:
            pass

    def get_status(self):
        f = Frame()
        f.set_msg_type(MsgType.GET_STATUS)
        f.set_nano(Timer.nano())
        f.set_string('')
        rsp = self.fist_client.req_master(f)
        return rsp.get_string()

    def join(self, fist_name, join_wait_seconds):
        is_running = True
        try:
            while is_running:
                is_running = False
                js = json.loads(self.get_status())
                for item in js:
                    if fist_name == item['fist_name'] and item['is_running']:
                        time.sleep(join_wait_seconds)
                        is_running = True
                        break
            print('{} is not running'.format(fist_name))
        except:
            print('master invalid')


class ConfigHelper(object):

    def __init__(self, config_dir, latest_config_version=DEFAULT_LATEST_CONFIG_VERSION):
        self.config_dir = config_dir
        self.config_path = os.path.join(config_dir, 'config.json')
        self.config = json.load(open(self.config_path))
        self.config_version = self.config.get("config_version", "0.1")
        self.latest_config_version = latest_config_version

        self.current_backup_path = None

    def run_sys_cmd(self, cmd):
        print(cmd)
        os.system(cmd)

    def backup_config(self):
        backup_path = os.path.join(self.config_dir, 'config.json.bak.{}'.format(len(os.listdir(self.config_dir))))
        cmd = "cp {} {}".format(self.config_path, backup_path)
        self.run_sys_cmd(cmd)
        self.current_backup_path = backup_path

    def _extract_port(self, addr):
        return int(addr.split(':')[-1])

    def _update_config_0_1(self, config):
        config['config_version'] = '0.2'
        config['master_rep_port'] = self._extract_port(config["master_rep"])
        config['master_rep'] = "tcp://127.0.0.1:{}".format(config['master_rep_port'])
        config['env'] = 'env1'
        config["env_infos"] = [
            {
                "env_name": "env1",
                "private_ip": "192.168.108.177",
                "public_ip": "36.110.14.214"
            },
            {
                "env_name": "env2",
                "private_ip": "192.168.108.177",
                "public_ip": "36.110.14.214"
            }
        ]
        for module in config['modules']:
            for comm_type, value in module['addrs'].items():
                if value.startswith("tcp"):
                    module['addrs'][comm_type] = {
                        'comm_method': "TCP",
                        "port": self._extract_port(value)
                    }
                else:
                    print('[ERROR] unhandled addr (key){} (value){}'.format(comm_type, value))

    def _update_config_0_2(self, config):
        config['config_version'] = '0.3'
        new_accounts = {
            'ctp_test': {
                'gateway_name': 'ctp',
                'gateway_type': 'TRADE_GATEWAY'
            },
            'ctp1': {
                'gateway_name': 'ctp',
                'gateway_type': 'MARKET_GATEWAY'
            }
        }
        for gw_name, gw_accounts in config['accounts'].items():
            for acc_tag, acc_info in gw_accounts.items():
                new_acc_tag = acc_tag
                while new_acc_tag in new_accounts:
                    new_acc_tag += "1"
                new_accounts[new_acc_tag] = acc_info
                new_accounts[new_acc_tag]['gateway_name'] = gw_name
                new_accounts[new_acc_tag]['gateway_type'] = 'MARKET_GATEWAY' if 'market' in new_acc_tag or 'qts' in new_acc_tag else 'TRADE_GATEWAY'
        config['accounts'] = new_accounts

    def update_config(self):
        if self.config_version == self.latest_config_version:
            print('already in latest version: {}'.format(self.latest_config_version))
            if self.current_backup_path is not None:
                os.remove(self.current_backup_path)
                print('removed backup file {}'.format(self.current_backup_path))
                self.current_backup_path = None
        while self.config_version != self.latest_config_version:
            print('current_version: {}'.format(self.config_version))
            eval('self._update_config_{}(self.config)'.format(self.config_version.replace('.', '_')))
            self.config_version = self.config['config_version']

    def dump_config(self):
        json.dump(self.config, open(self.config_path, "w+"), indent=4)

    def check_version(self):
        if self.config_version != self.latest_config_version:
            print("[ERROR] outdated config version: {}. the latest version is {}".format(self.config_version, self.latest_config_version))
            return False
        else:
            print("already in latest version {}".format(self.config_version))
            return True


# FISTS


class Router(object):

    def __init__(self, tag, fist_name):
        import libtrader
        if tag == 'tr':
            if fist_name is None:
                fist_name = 'trade1'
            self._obj = libtrader.TradeRouter(fist_name)
        elif tag == 'mr':
            if fist_name is None:
                fist_name = 'market1'
            self._obj = libtrader.MarketRouter(fist_name)
        else:
            raise Exception("unexpected tag: " + tag)
        self._obj.init()

    def run(self):
        self._obj.start()
        print(FIST_READY_MARK)
        self._obj.join()


class Gateway(object):

    def __init__(self, gw_tag, gw_name, acc_tag, router_name, secondary_router_name=None):
        import libtrader
        assert gw_tag == "tg" or gw_tag == "mg", "unexpected gateway tag tg/mg"
        if gw_tag == 'tg' and gw_name == 'mock':
            if secondary_router_name is None:
                raise Exception('[MISSING_ARGS] {} also requires -s'.format(gw_tag))
            self._obj = libtrader.MockGateway(acc_tag)
            self._obj.init_market(secondary_router_name)
        elif gw_tag == 'mg' and gw_name == 'replay':
            self._obj = libtrader.ReplayGateway(acc_tag)
        else:
            lib_name = 'lib{}{}'.format(gw_tag, gw_name)
            imported_lib = None
            try:
                imported_lib = __import__(lib_name)
                globals()[lib_name] = imported_lib
            except:
                raise Exception("cannot find lib named {}".format(lib_name))
            self._obj = imported_lib.Gateway(acc_tag)
        self._obj.set_account()
        self._obj.init(router_name)

    def run(self):
        self._obj.start()
        print(FIST_READY_MARK)
        self._obj.join()


class OrderService(object):

    def __init__(self, fist_name=None, router_name=None, with_db=False):
        fist_name = fist_name or 'oms1'
        router_name = router_name or 'trade1'

        if with_db:
            lib_name = 'liboms'
            imported_lib = None
            try:
                imported_lib = __import__(lib_name)
                globals()[lib_name] = imported_lib
            except:
                raise Exception('cannot find lib named {}'.format(lib_name))
            self._obj = imported_lib.OrderService(fist_name)
        else:
            import libtrader
            self._obj = libtrader.OrderManagerService(fist_name)
        self._obj.init(router_name)

    def run(self):
        self._obj.start()
        print(FIST_READY_MARK)
        self._obj.join()


class RiskManagementService(object):

    def __init__(self, fist_name=None, router1=None):
        fist_name = fist_name or 'rms1'
        router1 = router1 or 'trade1'

        import libtrader
        self._obj = libtrader.RiskManager(fist_name)
        self._obj.init(router1)

    def run(self):
        self._obj.start()
        print(FIST_READY_MARK)
        self._obj.join()
