# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.11qdk
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_binary_polynomial')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_binary_polynomial')
    _binary_polynomial = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_binary_polynomial', [dirname(__file__)])
        except ImportError:
            import _binary_polynomial
            return _binary_polynomial
        try:
            _mod = imp.load_module('_binary_polynomial', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _binary_polynomial = swig_import_helper()
    del swig_import_helper
else:
    import _binary_polynomial
del _swig_python_version_info
try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except __builtin__.Exception:
    class _object:
        pass
    _newclass = 0

try:
    import weakref
    weakref_proxy = weakref.proxy
except __builtin__.Exception:
    weakref_proxy = lambda x: x


class SwigPyIterator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _binary_polynomial.delete_SwigPyIterator
    __del__ = lambda self: None

    def value(self):
        return _binary_polynomial.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _binary_polynomial.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _binary_polynomial.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _binary_polynomial.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _binary_polynomial.SwigPyIterator_equal(self, x)

    def copy(self):
        return _binary_polynomial.SwigPyIterator_copy(self)

    def next(self):
        return _binary_polynomial.SwigPyIterator_next(self)

    def __next__(self):
        return _binary_polynomial.SwigPyIterator___next__(self)

    def previous(self):
        return _binary_polynomial.SwigPyIterator_previous(self)

    def advance(self, n):
        return _binary_polynomial.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _binary_polynomial.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _binary_polynomial.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _binary_polynomial.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _binary_polynomial.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _binary_polynomial.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _binary_polynomial.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _binary_polynomial.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

SHARED_PTR_DISOWN = _binary_polynomial.SHARED_PTR_DISOWN
class PairUInt(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PairUInt, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PairUInt, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _binary_polynomial.new_PairUInt(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_setmethods__["first"] = _binary_polynomial.PairUInt_first_set
    __swig_getmethods__["first"] = _binary_polynomial.PairUInt_first_get
    if _newclass:
        first = _swig_property(_binary_polynomial.PairUInt_first_get, _binary_polynomial.PairUInt_first_set)
    __swig_setmethods__["second"] = _binary_polynomial.PairUInt_second_set
    __swig_getmethods__["second"] = _binary_polynomial.PairUInt_second_get
    if _newclass:
        second = _swig_property(_binary_polynomial.PairUInt_second_get, _binary_polynomial.PairUInt_second_set)
    def __len__(self):
        return 2
    def __repr__(self):
        return str((self.first, self.second))
    def __getitem__(self, index): 
        if not (index % 2):
            return self.first
        else:
            return self.second
    def __setitem__(self, index, val):
        if not (index % 2):
            self.first = val
        else:
            self.second = val
    __swig_destroy__ = _binary_polynomial.delete_PairUInt
    __del__ = lambda self: None
PairUInt_swigregister = _binary_polynomial.PairUInt_swigregister
PairUInt_swigregister(PairUInt)

class VectorPair(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, VectorPair, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, VectorPair, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _binary_polynomial.VectorPair_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _binary_polynomial.VectorPair___nonzero__(self)

    def __bool__(self):
        return _binary_polynomial.VectorPair___bool__(self)

    def __len__(self):
        return _binary_polynomial.VectorPair___len__(self)

    def __getslice__(self, i, j):
        return _binary_polynomial.VectorPair___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _binary_polynomial.VectorPair___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _binary_polynomial.VectorPair___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _binary_polynomial.VectorPair___delitem__(self, *args)

    def __getitem__(self, *args):
        return _binary_polynomial.VectorPair___getitem__(self, *args)

    def __setitem__(self, *args):
        return _binary_polynomial.VectorPair___setitem__(self, *args)

    def pop(self):
        return _binary_polynomial.VectorPair_pop(self)

    def append(self, x):
        return _binary_polynomial.VectorPair_append(self, x)

    def empty(self):
        return _binary_polynomial.VectorPair_empty(self)

    def size(self):
        return _binary_polynomial.VectorPair_size(self)

    def swap(self, v):
        return _binary_polynomial.VectorPair_swap(self, v)

    def begin(self):
        return _binary_polynomial.VectorPair_begin(self)

    def end(self):
        return _binary_polynomial.VectorPair_end(self)

    def rbegin(self):
        return _binary_polynomial.VectorPair_rbegin(self)

    def rend(self):
        return _binary_polynomial.VectorPair_rend(self)

    def clear(self):
        return _binary_polynomial.VectorPair_clear(self)

    def get_allocator(self):
        return _binary_polynomial.VectorPair_get_allocator(self)

    def pop_back(self):
        return _binary_polynomial.VectorPair_pop_back(self)

    def erase(self, *args):
        return _binary_polynomial.VectorPair_erase(self, *args)

    def __init__(self, *args):
        this = _binary_polynomial.new_VectorPair(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _binary_polynomial.VectorPair_push_back(self, x)

    def front(self):
        return _binary_polynomial.VectorPair_front(self)

    def back(self):
        return _binary_polynomial.VectorPair_back(self)

    def assign(self, n, x):
        return _binary_polynomial.VectorPair_assign(self, n, x)

    def resize(self, *args):
        return _binary_polynomial.VectorPair_resize(self, *args)

    def insert(self, *args):
        return _binary_polynomial.VectorPair_insert(self, *args)

    def reserve(self, n):
        return _binary_polynomial.VectorPair_reserve(self, n)

    def capacity(self):
        return _binary_polynomial.VectorPair_capacity(self)
    __swig_destroy__ = _binary_polynomial.delete_VectorPair
    __del__ = lambda self: None
VectorPair_swigregister = _binary_polynomial.VectorPair_swigregister
VectorPair_swigregister(VectorPair)

class VectorUint(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, VectorUint, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, VectorUint, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _binary_polynomial.VectorUint_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _binary_polynomial.VectorUint___nonzero__(self)

    def __bool__(self):
        return _binary_polynomial.VectorUint___bool__(self)

    def __len__(self):
        return _binary_polynomial.VectorUint___len__(self)

    def __getslice__(self, i, j):
        return _binary_polynomial.VectorUint___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _binary_polynomial.VectorUint___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _binary_polynomial.VectorUint___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _binary_polynomial.VectorUint___delitem__(self, *args)

    def __getitem__(self, *args):
        return _binary_polynomial.VectorUint___getitem__(self, *args)

    def __setitem__(self, *args):
        return _binary_polynomial.VectorUint___setitem__(self, *args)

    def pop(self):
        return _binary_polynomial.VectorUint_pop(self)

    def append(self, x):
        return _binary_polynomial.VectorUint_append(self, x)

    def empty(self):
        return _binary_polynomial.VectorUint_empty(self)

    def size(self):
        return _binary_polynomial.VectorUint_size(self)

    def swap(self, v):
        return _binary_polynomial.VectorUint_swap(self, v)

    def begin(self):
        return _binary_polynomial.VectorUint_begin(self)

    def end(self):
        return _binary_polynomial.VectorUint_end(self)

    def rbegin(self):
        return _binary_polynomial.VectorUint_rbegin(self)

    def rend(self):
        return _binary_polynomial.VectorUint_rend(self)

    def clear(self):
        return _binary_polynomial.VectorUint_clear(self)

    def get_allocator(self):
        return _binary_polynomial.VectorUint_get_allocator(self)

    def pop_back(self):
        return _binary_polynomial.VectorUint_pop_back(self)

    def erase(self, *args):
        return _binary_polynomial.VectorUint_erase(self, *args)

    def __init__(self, *args):
        this = _binary_polynomial.new_VectorUint(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _binary_polynomial.VectorUint_push_back(self, x)

    def front(self):
        return _binary_polynomial.VectorUint_front(self)

    def back(self):
        return _binary_polynomial.VectorUint_back(self)

    def assign(self, n, x):
        return _binary_polynomial.VectorUint_assign(self, n, x)

    def resize(self, *args):
        return _binary_polynomial.VectorUint_resize(self, *args)

    def insert(self, *args):
        return _binary_polynomial.VectorUint_insert(self, *args)

    def reserve(self, n):
        return _binary_polynomial.VectorUint_reserve(self, n)

    def capacity(self):
        return _binary_polynomial.VectorUint_capacity(self)
    __swig_destroy__ = _binary_polynomial.delete_VectorUint
    __del__ = lambda self: None
VectorUint_swigregister = _binary_polynomial.VectorUint_swigregister
VectorUint_swigregister(VectorUint)

class VectorInt(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, VectorInt, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, VectorInt, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _binary_polynomial.VectorInt_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _binary_polynomial.VectorInt___nonzero__(self)

    def __bool__(self):
        return _binary_polynomial.VectorInt___bool__(self)

    def __len__(self):
        return _binary_polynomial.VectorInt___len__(self)

    def __getslice__(self, i, j):
        return _binary_polynomial.VectorInt___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _binary_polynomial.VectorInt___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _binary_polynomial.VectorInt___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _binary_polynomial.VectorInt___delitem__(self, *args)

    def __getitem__(self, *args):
        return _binary_polynomial.VectorInt___getitem__(self, *args)

    def __setitem__(self, *args):
        return _binary_polynomial.VectorInt___setitem__(self, *args)

    def pop(self):
        return _binary_polynomial.VectorInt_pop(self)

    def append(self, x):
        return _binary_polynomial.VectorInt_append(self, x)

    def empty(self):
        return _binary_polynomial.VectorInt_empty(self)

    def size(self):
        return _binary_polynomial.VectorInt_size(self)

    def swap(self, v):
        return _binary_polynomial.VectorInt_swap(self, v)

    def begin(self):
        return _binary_polynomial.VectorInt_begin(self)

    def end(self):
        return _binary_polynomial.VectorInt_end(self)

    def rbegin(self):
        return _binary_polynomial.VectorInt_rbegin(self)

    def rend(self):
        return _binary_polynomial.VectorInt_rend(self)

    def clear(self):
        return _binary_polynomial.VectorInt_clear(self)

    def get_allocator(self):
        return _binary_polynomial.VectorInt_get_allocator(self)

    def pop_back(self):
        return _binary_polynomial.VectorInt_pop_back(self)

    def erase(self, *args):
        return _binary_polynomial.VectorInt_erase(self, *args)

    def __init__(self, *args):
        this = _binary_polynomial.new_VectorInt(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _binary_polynomial.VectorInt_push_back(self, x)

    def front(self):
        return _binary_polynomial.VectorInt_front(self)

    def back(self):
        return _binary_polynomial.VectorInt_back(self)

    def assign(self, n, x):
        return _binary_polynomial.VectorInt_assign(self, n, x)

    def resize(self, *args):
        return _binary_polynomial.VectorInt_resize(self, *args)

    def insert(self, *args):
        return _binary_polynomial.VectorInt_insert(self, *args)

    def reserve(self, n):
        return _binary_polynomial.VectorInt_reserve(self, n)

    def capacity(self):
        return _binary_polynomial.VectorInt_capacity(self)
    __swig_destroy__ = _binary_polynomial.delete_VectorInt
    __del__ = lambda self: None
VectorInt_swigregister = _binary_polynomial.VectorInt_swigregister
VectorInt_swigregister(VectorInt)

class VectorByte(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, VectorByte, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, VectorByte, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _binary_polynomial.VectorByte_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _binary_polynomial.VectorByte___nonzero__(self)

    def __bool__(self):
        return _binary_polynomial.VectorByte___bool__(self)

    def __len__(self):
        return _binary_polynomial.VectorByte___len__(self)

    def __getslice__(self, i, j):
        return _binary_polynomial.VectorByte___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _binary_polynomial.VectorByte___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _binary_polynomial.VectorByte___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _binary_polynomial.VectorByte___delitem__(self, *args)

    def __getitem__(self, *args):
        return _binary_polynomial.VectorByte___getitem__(self, *args)

    def __setitem__(self, *args):
        return _binary_polynomial.VectorByte___setitem__(self, *args)

    def pop(self):
        return _binary_polynomial.VectorByte_pop(self)

    def append(self, x):
        return _binary_polynomial.VectorByte_append(self, x)

    def empty(self):
        return _binary_polynomial.VectorByte_empty(self)

    def size(self):
        return _binary_polynomial.VectorByte_size(self)

    def swap(self, v):
        return _binary_polynomial.VectorByte_swap(self, v)

    def begin(self):
        return _binary_polynomial.VectorByte_begin(self)

    def end(self):
        return _binary_polynomial.VectorByte_end(self)

    def rbegin(self):
        return _binary_polynomial.VectorByte_rbegin(self)

    def rend(self):
        return _binary_polynomial.VectorByte_rend(self)

    def clear(self):
        return _binary_polynomial.VectorByte_clear(self)

    def get_allocator(self):
        return _binary_polynomial.VectorByte_get_allocator(self)

    def pop_back(self):
        return _binary_polynomial.VectorByte_pop_back(self)

    def erase(self, *args):
        return _binary_polynomial.VectorByte_erase(self, *args)

    def __init__(self, *args):
        this = _binary_polynomial.new_VectorByte(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _binary_polynomial.VectorByte_push_back(self, x)

    def front(self):
        return _binary_polynomial.VectorByte_front(self)

    def back(self):
        return _binary_polynomial.VectorByte_back(self)

    def assign(self, n, x):
        return _binary_polynomial.VectorByte_assign(self, n, x)

    def resize(self, *args):
        return _binary_polynomial.VectorByte_resize(self, *args)

    def insert(self, *args):
        return _binary_polynomial.VectorByte_insert(self, *args)

    def reserve(self, n):
        return _binary_polynomial.VectorByte_reserve(self, n)

    def capacity(self):
        return _binary_polynomial.VectorByte_capacity(self)
    __swig_destroy__ = _binary_polynomial.delete_VectorByte
    __del__ = lambda self: None
VectorByte_swigregister = _binary_polynomial.VectorByte_swigregister
VectorByte_swigregister(VectorByte)

class MapUIntBool(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, MapUIntBool, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, MapUIntBool, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _binary_polynomial.MapUIntBool_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _binary_polynomial.MapUIntBool___nonzero__(self)

    def __bool__(self):
        return _binary_polynomial.MapUIntBool___bool__(self)

    def __len__(self):
        return _binary_polynomial.MapUIntBool___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key):
        return _binary_polynomial.MapUIntBool___getitem__(self, key)

    def __delitem__(self, key):
        return _binary_polynomial.MapUIntBool___delitem__(self, key)

    def has_key(self, key):
        return _binary_polynomial.MapUIntBool_has_key(self, key)

    def keys(self):
        return _binary_polynomial.MapUIntBool_keys(self)

    def values(self):
        return _binary_polynomial.MapUIntBool_values(self)

    def items(self):
        return _binary_polynomial.MapUIntBool_items(self)

    def __contains__(self, key):
        return _binary_polynomial.MapUIntBool___contains__(self, key)

    def key_iterator(self):
        return _binary_polynomial.MapUIntBool_key_iterator(self)

    def value_iterator(self):
        return _binary_polynomial.MapUIntBool_value_iterator(self)

    def __setitem__(self, *args):
        return _binary_polynomial.MapUIntBool___setitem__(self, *args)

    def asdict(self):
        return _binary_polynomial.MapUIntBool_asdict(self)

    def __init__(self, *args):
        this = _binary_polynomial.new_MapUIntBool(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def empty(self):
        return _binary_polynomial.MapUIntBool_empty(self)

    def size(self):
        return _binary_polynomial.MapUIntBool_size(self)

    def swap(self, v):
        return _binary_polynomial.MapUIntBool_swap(self, v)

    def begin(self):
        return _binary_polynomial.MapUIntBool_begin(self)

    def end(self):
        return _binary_polynomial.MapUIntBool_end(self)

    def rbegin(self):
        return _binary_polynomial.MapUIntBool_rbegin(self)

    def rend(self):
        return _binary_polynomial.MapUIntBool_rend(self)

    def clear(self):
        return _binary_polynomial.MapUIntBool_clear(self)

    def get_allocator(self):
        return _binary_polynomial.MapUIntBool_get_allocator(self)

    def count(self, x):
        return _binary_polynomial.MapUIntBool_count(self, x)

    def erase(self, *args):
        return _binary_polynomial.MapUIntBool_erase(self, *args)

    def find(self, x):
        return _binary_polynomial.MapUIntBool_find(self, x)

    def lower_bound(self, x):
        return _binary_polynomial.MapUIntBool_lower_bound(self, x)

    def upper_bound(self, x):
        return _binary_polynomial.MapUIntBool_upper_bound(self, x)
    __swig_destroy__ = _binary_polynomial.delete_MapUIntBool
    __del__ = lambda self: None
MapUIntBool_swigregister = _binary_polynomial.MapUIntBool_swigregister
MapUIntBool_swigregister(MapUIntBool)

class Hobo2Qubo_Constraint(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Hobo2Qubo_Constraint, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Hobo2Qubo_Constraint, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _binary_polynomial.Hobo2Qubo_Constraint_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _binary_polynomial.Hobo2Qubo_Constraint___nonzero__(self)

    def __bool__(self):
        return _binary_polynomial.Hobo2Qubo_Constraint___bool__(self)

    def __len__(self):
        return _binary_polynomial.Hobo2Qubo_Constraint___len__(self)

    def __getslice__(self, i, j):
        return _binary_polynomial.Hobo2Qubo_Constraint___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _binary_polynomial.Hobo2Qubo_Constraint___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _binary_polynomial.Hobo2Qubo_Constraint___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _binary_polynomial.Hobo2Qubo_Constraint___delitem__(self, *args)

    def __getitem__(self, *args):
        return _binary_polynomial.Hobo2Qubo_Constraint___getitem__(self, *args)

    def __setitem__(self, *args):
        return _binary_polynomial.Hobo2Qubo_Constraint___setitem__(self, *args)

    def pop(self):
        return _binary_polynomial.Hobo2Qubo_Constraint_pop(self)

    def append(self, x):
        return _binary_polynomial.Hobo2Qubo_Constraint_append(self, x)

    def empty(self):
        return _binary_polynomial.Hobo2Qubo_Constraint_empty(self)

    def size(self):
        return _binary_polynomial.Hobo2Qubo_Constraint_size(self)

    def swap(self, v):
        return _binary_polynomial.Hobo2Qubo_Constraint_swap(self, v)

    def begin(self):
        return _binary_polynomial.Hobo2Qubo_Constraint_begin(self)

    def end(self):
        return _binary_polynomial.Hobo2Qubo_Constraint_end(self)

    def rbegin(self):
        return _binary_polynomial.Hobo2Qubo_Constraint_rbegin(self)

    def rend(self):
        return _binary_polynomial.Hobo2Qubo_Constraint_rend(self)

    def clear(self):
        return _binary_polynomial.Hobo2Qubo_Constraint_clear(self)

    def get_allocator(self):
        return _binary_polynomial.Hobo2Qubo_Constraint_get_allocator(self)

    def pop_back(self):
        return _binary_polynomial.Hobo2Qubo_Constraint_pop_back(self)

    def erase(self, *args):
        return _binary_polynomial.Hobo2Qubo_Constraint_erase(self, *args)

    def __init__(self, *args):
        this = _binary_polynomial.new_Hobo2Qubo_Constraint(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _binary_polynomial.Hobo2Qubo_Constraint_push_back(self, x)

    def front(self):
        return _binary_polynomial.Hobo2Qubo_Constraint_front(self)

    def back(self):
        return _binary_polynomial.Hobo2Qubo_Constraint_back(self)

    def assign(self, n, x):
        return _binary_polynomial.Hobo2Qubo_Constraint_assign(self, n, x)

    def resize(self, *args):
        return _binary_polynomial.Hobo2Qubo_Constraint_resize(self, *args)

    def insert(self, *args):
        return _binary_polynomial.Hobo2Qubo_Constraint_insert(self, *args)

    def reserve(self, n):
        return _binary_polynomial.Hobo2Qubo_Constraint_reserve(self, n)

    def capacity(self):
        return _binary_polynomial.Hobo2Qubo_Constraint_capacity(self)
    __swig_destroy__ = _binary_polynomial.delete_Hobo2Qubo_Constraint
    __del__ = lambda self: None
Hobo2Qubo_Constraint_swigregister = _binary_polynomial.Hobo2Qubo_Constraint_swigregister
Hobo2Qubo_Constraint_swigregister(Hobo2Qubo_Constraint)

class IsingJ(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IsingJ, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IsingJ, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _binary_polynomial.IsingJ_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _binary_polynomial.IsingJ___nonzero__(self)

    def __bool__(self):
        return _binary_polynomial.IsingJ___bool__(self)

    def __len__(self):
        return _binary_polynomial.IsingJ___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key):
        return _binary_polynomial.IsingJ___getitem__(self, key)

    def __delitem__(self, key):
        return _binary_polynomial.IsingJ___delitem__(self, key)

    def has_key(self, key):
        return _binary_polynomial.IsingJ_has_key(self, key)

    def keys(self):
        return _binary_polynomial.IsingJ_keys(self)

    def values(self):
        return _binary_polynomial.IsingJ_values(self)

    def items(self):
        return _binary_polynomial.IsingJ_items(self)

    def __contains__(self, key):
        return _binary_polynomial.IsingJ___contains__(self, key)

    def key_iterator(self):
        return _binary_polynomial.IsingJ_key_iterator(self)

    def value_iterator(self):
        return _binary_polynomial.IsingJ_value_iterator(self)

    def __setitem__(self, *args):
        return _binary_polynomial.IsingJ___setitem__(self, *args)

    def asdict(self):
        return _binary_polynomial.IsingJ_asdict(self)

    def __init__(self, *args):
        this = _binary_polynomial.new_IsingJ(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def empty(self):
        return _binary_polynomial.IsingJ_empty(self)

    def size(self):
        return _binary_polynomial.IsingJ_size(self)

    def swap(self, v):
        return _binary_polynomial.IsingJ_swap(self, v)

    def begin(self):
        return _binary_polynomial.IsingJ_begin(self)

    def end(self):
        return _binary_polynomial.IsingJ_end(self)

    def rbegin(self):
        return _binary_polynomial.IsingJ_rbegin(self)

    def rend(self):
        return _binary_polynomial.IsingJ_rend(self)

    def clear(self):
        return _binary_polynomial.IsingJ_clear(self)

    def get_allocator(self):
        return _binary_polynomial.IsingJ_get_allocator(self)

    def count(self, x):
        return _binary_polynomial.IsingJ_count(self, x)

    def erase(self, *args):
        return _binary_polynomial.IsingJ_erase(self, *args)

    def find(self, x):
        return _binary_polynomial.IsingJ_find(self, x)

    def lower_bound(self, x):
        return _binary_polynomial.IsingJ_lower_bound(self, x)

    def upper_bound(self, x):
        return _binary_polynomial.IsingJ_upper_bound(self, x)
    __swig_destroy__ = _binary_polynomial.delete_IsingJ
    __del__ = lambda self: None
IsingJ_swigregister = _binary_polynomial.IsingJ_swigregister
IsingJ_swigregister(IsingJ)

class IsingH(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IsingH, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IsingH, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _binary_polynomial.IsingH_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _binary_polynomial.IsingH___nonzero__(self)

    def __bool__(self):
        return _binary_polynomial.IsingH___bool__(self)

    def __len__(self):
        return _binary_polynomial.IsingH___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key):
        return _binary_polynomial.IsingH___getitem__(self, key)

    def __delitem__(self, key):
        return _binary_polynomial.IsingH___delitem__(self, key)

    def has_key(self, key):
        return _binary_polynomial.IsingH_has_key(self, key)

    def keys(self):
        return _binary_polynomial.IsingH_keys(self)

    def values(self):
        return _binary_polynomial.IsingH_values(self)

    def items(self):
        return _binary_polynomial.IsingH_items(self)

    def __contains__(self, key):
        return _binary_polynomial.IsingH___contains__(self, key)

    def key_iterator(self):
        return _binary_polynomial.IsingH_key_iterator(self)

    def value_iterator(self):
        return _binary_polynomial.IsingH_value_iterator(self)

    def __setitem__(self, *args):
        return _binary_polynomial.IsingH___setitem__(self, *args)

    def asdict(self):
        return _binary_polynomial.IsingH_asdict(self)

    def __init__(self, *args):
        this = _binary_polynomial.new_IsingH(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def empty(self):
        return _binary_polynomial.IsingH_empty(self)

    def size(self):
        return _binary_polynomial.IsingH_size(self)

    def swap(self, v):
        return _binary_polynomial.IsingH_swap(self, v)

    def begin(self):
        return _binary_polynomial.IsingH_begin(self)

    def end(self):
        return _binary_polynomial.IsingH_end(self)

    def rbegin(self):
        return _binary_polynomial.IsingH_rbegin(self)

    def rend(self):
        return _binary_polynomial.IsingH_rend(self)

    def clear(self):
        return _binary_polynomial.IsingH_clear(self)

    def get_allocator(self):
        return _binary_polynomial.IsingH_get_allocator(self)

    def count(self, x):
        return _binary_polynomial.IsingH_count(self, x)

    def erase(self, *args):
        return _binary_polynomial.IsingH_erase(self, *args)

    def find(self, x):
        return _binary_polynomial.IsingH_find(self, x)

    def lower_bound(self, x):
        return _binary_polynomial.IsingH_lower_bound(self, x)

    def upper_bound(self, x):
        return _binary_polynomial.IsingH_upper_bound(self, x)
    __swig_destroy__ = _binary_polynomial.delete_IsingH
    __del__ = lambda self: None
IsingH_swigregister = _binary_polynomial.IsingH_swigregister
IsingH_swigregister(IsingH)

class IEvaluable(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IEvaluable, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IEvaluable, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _binary_polynomial.delete_IEvaluable
    __del__ = lambda self: None

    def _var_list(self):
        val = _binary_polynomial.IEvaluable__var_list(self)

        val = list(val)


        return val


    __swig_getmethods__["var_list"] = _var_list
    if _newclass: var_list = _swig_property(_var_list)

IEvaluable_swigregister = _binary_polynomial.IEvaluable_swigregister
IEvaluable_swigregister(IEvaluable)

class BinaryPolynomialTerm(_object):
    """

    This class stores ``BinaryPolynomial`` terms. A term is a coefficient and a set
    of variable indices.

    Attributes:
        coefficient (float): The coefficient of the term.
        degree (int): The degree of the term.
        var_list (list): List of the indices \(int\) of the variables in this term.

    The constructor has the following signature: ::

        BinaryPolynomialTerm(self, coeff, var_list)

    Args:
        coeff (float): The coefficient of this term.
        var_list (list): The list of indices \(int\) of the variables of this term.

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, BinaryPolynomialTerm, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, BinaryPolynomialTerm, name)

    def __init__(self, coeff, var_list):
        this = _binary_polynomial.new_BinaryPolynomialTerm(coeff, var_list)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __eq__(self, other):
        return _binary_polynomial.BinaryPolynomialTerm___eq__(self, other)

    def __ne__(self, other):
        return _binary_polynomial.BinaryPolynomialTerm___ne__(self, other)

    def __repr__(self):
        return _binary_polynomial.BinaryPolynomialTerm___repr__(self)
    __swig_destroy__ = _binary_polynomial.delete_BinaryPolynomialTerm
    __del__ = lambda self: None

    def _var_list(self):
        val = _binary_polynomial.BinaryPolynomialTerm__var_list(self)

        return list(val)


        return val


    def clone(self):
        """

        Clones the polynomial term.

        This function has the following signature: ::

            clone(self)

        returns:
            BinaryPolynomialTerm: Clone of the BinaryPolynomialTerm.

        """
        return _binary_polynomial.BinaryPolynomialTerm_clone(self)


    def multiply(self, constant):
        """

        Multiply the term by a factor.

        This function has the following signature: ::

            multiply(self, constant)

        Args:
            constant (float): The factor to be multiplied.

        """
        return _binary_polynomial.BinaryPolynomialTerm_multiply(self, constant)


    __swig_getmethods__["var_list"] = _var_list
    if _newclass: var_list = _swig_property(_var_list)

    __swig_setmethods__["coefficient"] = _binary_polynomial.BinaryPolynomialTerm_coefficient_set
    __swig_getmethods__["coefficient"] = _binary_polynomial.BinaryPolynomialTerm_coefficient_get
    if _newclass:
        coefficient = _swig_property(_binary_polynomial.BinaryPolynomialTerm_coefficient_get, _binary_polynomial.BinaryPolynomialTerm_coefficient_set)
    __swig_getmethods__["degree"] = _binary_polynomial.BinaryPolynomialTerm_degree_get
    if _newclass:
        degree = _swig_property(_binary_polynomial.BinaryPolynomialTerm_degree_get)
BinaryPolynomialTerm_swigregister = _binary_polynomial.BinaryPolynomialTerm_swigregister
BinaryPolynomialTerm_swigregister(BinaryPolynomialTerm)

class UPBinaryPolynomial(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, UPBinaryPolynomial, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, UPBinaryPolynomial, name)
    __repr__ = _swig_repr

    def release(self):
        return _binary_polynomial.UPBinaryPolynomial_release(self)
    __swig_destroy__ = _binary_polynomial.delete_UPBinaryPolynomial
    __del__ = lambda self: None

    def __init__(self):
        this = _binary_polynomial.new_UPBinaryPolynomial()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
UPBinaryPolynomial_swigregister = _binary_polynomial.UPBinaryPolynomial_swigregister
UPBinaryPolynomial_swigregister(UPBinaryPolynomial)

class BPConstantIterator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, BPConstantIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, BPConstantIterator, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _binary_polynomial.new_BPConstantIterator()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def inc(self):
        return _binary_polynomial.BPConstantIterator_inc(self)

    def deref(self):
        return _binary_polynomial.BPConstantIterator_deref(self)

    def equals(self, other):
        return _binary_polynomial.BPConstantIterator_equals(self, other)
    __swig_destroy__ = _binary_polynomial.delete_BPConstantIterator
    __del__ = lambda self: None
BPConstantIterator_swigregister = _binary_polynomial.BPConstantIterator_swigregister
BPConstantIterator_swigregister(BPConstantIterator)

class BinaryPolynomial(_object):
    """

    This class represents polynomial structures and is
    used for binary polynomials of degree greater than 2. For
    degree 2 polynomials, please use QuadraticBinaryPolynomial.

    Attributes:
        degree (int): The maximum degree among all the terms.
        constant_term (float): The value of the constant term.
        term_count (int): The number of terms in the polynomial.
        var_count (int): The number of variables occurring in the terms.
        var_list (list): The list of variable indices \(int\).

    The constructor has the following signature: ::

        BinaryPolynomial(self)


    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, BinaryPolynomial, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, BinaryPolynomial, name)

    def __init__(self):
        """

        This class represents polynomial structures and is
        used for binary polynomials of degree greater than 2. For
        degree 2 polynomials, please use QuadraticBinaryPolynomial.

        Attributes:
            degree (int): The maximum degree among all the terms.
            constant_term (float): The value of the constant term.
            term_count (int): The number of terms in the polynomial.
            var_count (int): The number of variables occurring in the terms.
            var_list (list): The list of variable indices \(int\).

        The constructor has the following signature: ::

            BinaryPolynomial(self)


        """
        this = _binary_polynomial.new_BinaryPolynomial()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _binary_polynomial.delete_BinaryPolynomial
    __del__ = lambda self: None

    def equals(self, other, epsilon=1e-9):
        """

        Equality checking between BinaryPolynomial instances.

        This function has the following signature: ::

            equals(self, other, epsilon)

        Args:
            other (BinaryPolynomial): The binary polynomial to compare.
            epsilon (float): The precision used in comparing the coefficients (default '1e-9').

        Returns:
            bool: True if this == other, False otherwise.

        """
        return _binary_polynomial.BinaryPolynomial_equals(self, other, epsilon)


    def has_term(self, indices):
        """

        Checks whether the polynomial has a term with the given indices.

        This function has the following signature: ::

            has_term(self, indices)

        Args:
            indices (list): List of variable indices \(int\) of the requested term.
              ``[index_A, index_B, ...]``

        Returns:
            bool: True if there is a term with variables specified in indices
            (with any non-zero coefficient).

        """
        return _binary_polynomial.BinaryPolynomial_has_term(self, indices)


    def get_term(self, indices):
        """

        Returns a term from the polynomial with the specified indices.

        This function has the following signature: ::

            get_term(self, indices)

        Args:
            indices (list): The variable indices of the requested term.

        Returns:
            BinaryPolynomialTerm: A BinaryPolynomialTerm with variables
            matching the specified indices.


        """
        return _binary_polynomial.BinaryPolynomial_get_term(self, indices)


    def get_term_by_number(self, term_number):
        """

        Returns the N-th term of this polynomial.

        This function has the following signature: ::

            get_term_by_number(self, n)

        Args:
            n (int): The term number between 0 and get_terms_count() - 1.

        Returns:
            BinaryPolynomialTerm: The term retrieved at the given index.

        """
        return _binary_polynomial.BinaryPolynomial_get_term_by_number(self, term_number)


    def remove_term(self, indices):
        """

        Removes a term from the BinaryPolynomial with the specified indices.

        This function has the following signature: ::

            remove_term(self, indices)

        Args:
            indices (list): The variable indices of a term to be removed.

        """
        return _binary_polynomial.BinaryPolynomial_remove_term(self, indices)


    def get_coefficient(self, indices):
        """

        Returns the coefficient of a term from the BinaryPolynomial.

        This function has the following signature: ::

            get_coefficient(self, indices)

        Args:
            indices (list): The variable indices of the requested term.

        Returns:
            float: The coefficient of the term, with variables specified by the `indices`.
            Returns 0 if there is no term in the polynomial with the requested indices.

        """
        return _binary_polynomial.BinaryPolynomial_get_coefficient(self, indices)


    def set_coefficient(self, new_coeff, indices):
        """

        Sets the coefficient of a term specified by its variable indices.

        This function has the following signature: ::

            set_coefficient(self, new_coeff, indices)

        Args:
            new_coeff (float): The value of the new coefficient.
            indices (list): The variable indices of the term to be changed.

        """
        return _binary_polynomial.BinaryPolynomial_set_coefficient(self, new_coeff, indices)


    def add_constant_term(self, constant):
        """

        Adds to the value of the current constant term.

        This function has the following signature: ::

            add_constant_term(self, constant)

        Args:
            constant (float): The value to be added to the constant term..


        """
        return _binary_polynomial.BinaryPolynomial_add_constant_term(self, constant)


    def remove_var(self, index):
        """

        Remove all terms containing the corresponding variable index.

        This function has the following signature: ::

            remove_var(self, index)

        Args:
            index (int): Removes all terms containing the corresponding variable index.

        """
        return _binary_polynomial.BinaryPolynomial_remove_var(self, index)


    def _cbegin(self):
        return _binary_polynomial.BinaryPolynomial__cbegin(self)

    def _cend(self):
        return _binary_polynomial.BinaryPolynomial__cend(self)

    def Sum(self, other):
        """

        Adds another BinaryPolnomial to this instance.

        This function has the following signature: ::

            sum(self, other)

        Args:
            other (BinaryPolynomial): The BinaryPolynomial to be added.

        """
        return _binary_polynomial.BinaryPolynomial_Sum(self, other)


    def to_string(self, meta_data=False):
        """

        Converts this polynomial into a string.

        This function has the following signature: ::

            to_string(self)
            to_string(self, meta_data)

        Args:
            meta_data (bool): If True, the string will contain meta data such as degree
              and term count (default 'False').

        Returns:
            string: The string representation of this polynomial. If meta data is not
              set to true, the string is 0 if the polynomial is empty.

        """
        return _binary_polynomial.BinaryPolynomial_to_string(self, meta_data)


    def _multiply(self, *args):
        return _binary_polynomial.BinaryPolynomial__multiply(self, *args)

    def _power(self, exponent):
        return _binary_polynomial.BinaryPolynomial__power(self, exponent)

    def _sum(self, bp):
        return _binary_polynomial.BinaryPolynomial__sum(self, bp)

    def clone(self):
        """

        Clones the BinaryPolynomial.

        This function has the following signature: ::

            clone(self)

        Returns:
            The cloned BinaryPolynomial instance.

        """
        return _binary_polynomial.BinaryPolynomial_clone(self)


    def add_term(self, *args):
        """

        Add a term to the polynomial.

        This function has the following signature: ::

            add_term(self, coeff, sorted_indices)
            add_term(self, term)

        Args:
            coeff (float): The coefficient of the term.
            sorted_indices (list): Sorted list of indices \(int\) of terms to be added.
            term (list): List of indices \(int\) of terms to be added.

        """
        return _binary_polynomial.BinaryPolynomial_add_term(self, *args)


    def __eq__(self, other):
        """

        Equality checking between BinaryPolynomial instances. Note that
        the tolerance for equality checking is 1e-9.

        This function has the following signature: ::

            __eq__(other)

        Args:
            other (BinaryPolynomial): The BinaryPolynomial to be checked against.

        Returns:
            bool: Returns true if the current instance is equal to the given
            BinaryPolynomial instance.

        """
        return _binary_polynomial.BinaryPolynomial___eq__(self, other)


    def __ne__(self, other):
        return _binary_polynomial.BinaryPolynomial___ne__(self, other)

    def __getitem__(self, term_number):
        """

        Returns the N-th term of this polynomial.

        This function has the following signature: ::

            __getitem__(term_number)

        Args:
            term_number (int): A number between 0 and ``term_count``.

        Returns:
            BinaryPolynomialTerm: Returns the BinaryPolynomialTerm at the position specified by
            the term_number.

        """
        return _binary_polynomial.BinaryPolynomial___getitem__(self, term_number)


    def __len__(self):
        """

        Returns the number of terms in the BinaryPolynomial.

        This function has the following signature: ::

            __len__()

        Returns:
            int: The number of terms in the polynomial.

        """
        return _binary_polynomial.BinaryPolynomial___len__(self)


    def __repr__(self):
        """

        This function returns the string representation of the BinaryPolynomial.

        This function has the following signature: ::

            __repr__(self)

        Returns:
            str: The string representation of all the terms in the BinaryPolynomial.

        """
        return _binary_polynomial.BinaryPolynomial___repr__(self)


    def _var_list(self):
        val = _binary_polynomial.BinaryPolynomial__var_list(self)

        val = list(val)


        return val


    def __iter__(self):
        it = self._cbegin()

        while not it.equals(self._cend()):
            yield it.deref()
            it.inc()

    def __reduce__(self):
        terms = []
        for term in self:
          terms.append({ "coefficient" : term.coefficient, "var_list" : tuple(term.var_list)})

        ret = {
            "terms" : terms,
        }
        return self.__class__, (), ret

    def __setstate__(self, state):
        for term in state["terms"]:
          if len(term["var_list"]) > 0:
            self.add_term(term["coefficient"], term["var_list"])
          else:
            self.constant_term = term["coefficient"]

    def multiply(self, x):
      return self._multiply(x)

    def power(self, x):
      return self._power(x)

    def sum(self, x):
      return self._sum(x)

    __swig_getmethods__["var_list"] = _var_list
    if _newclass: var_list = _swig_property(_var_list)

    __swig_getmethods__["var_count"] = _binary_polynomial.BinaryPolynomial_var_count_get
    if _newclass:
        var_count = _swig_property(_binary_polynomial.BinaryPolynomial_var_count_get)
    __swig_getmethods__["term_count"] = _binary_polynomial.BinaryPolynomial_term_count_get
    if _newclass:
        term_count = _swig_property(_binary_polynomial.BinaryPolynomial_term_count_get)
    __swig_getmethods__["degree"] = _binary_polynomial.BinaryPolynomial_degree_get
    if _newclass:
        degree = _swig_property(_binary_polynomial.BinaryPolynomial_degree_get)
    __swig_setmethods__["constant_term"] = _binary_polynomial.BinaryPolynomial_constant_term_set
    __swig_getmethods__["constant_term"] = _binary_polynomial.BinaryPolynomial_constant_term_get
    if _newclass:
        constant_term = _swig_property(_binary_polynomial.BinaryPolynomial_constant_term_get, _binary_polynomial.BinaryPolynomial_constant_term_set)
BinaryPolynomial_swigregister = _binary_polynomial.BinaryPolynomial_swigregister
BinaryPolynomial_swigregister(BinaryPolynomial)

class UPIsingModel(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, UPIsingModel, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, UPIsingModel, name)
    __repr__ = _swig_repr

    def release(self):
        return _binary_polynomial.UPIsingModel_release(self)
    __swig_destroy__ = _binary_polynomial.delete_UPIsingModel
    __del__ = lambda self: None

    def __init__(self):
        this = _binary_polynomial.new_UPIsingModel()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
UPIsingModel_swigregister = _binary_polynomial.UPIsingModel_swigregister
UPIsingModel_swigregister(UPIsingModel)

class IsingModel(_object):
    """

    This class represents an Isingmodel, which supports operations
    such as multiplying a scalar, arithmetic addition of Ising models, and scaling
    coefficients. The Ising model is represented as a set of quadratic (J)
    terms, a set of linear (H) terms, and a constant term.

    Attributes:
        constant_term (float): The constant term of the Ising model.
        j_terms (dict): The upper triangular J matrix which holds the mapping of the
          quadratic terms \(tuple of ints\) and their corresponding coefficients
          \(float\) ``{(term_A, term_B):coeff_AB, (term_B, term_C):coeff_BC, ... }``.
        h_terms (dict): A dictionary which holds the linear terms \(int\) mapped to their
          corresponding coefficient \(float\) ``{term:coeff}``.
        var_count (int): The number of variables in this IsingModel.

    The constructor has the following signature: ::

        IsingModel(self)


    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IsingModel, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IsingModel, name)

    def __repr__(self):
        return _binary_polynomial.IsingModel___repr__(self)

    def clone(self):
        """

        Clones the Ising model.

        This function has the following signature: ::

            clone(self)

        Returns:
            IsingModel: A deep copy of the Ising model.

        """
        return _binary_polynomial.IsingModel_clone(self)


    def __eq__(self, other):
        """

        Checks the equality of two Ising models.

        This function has the following signature: ::

            __eq__(self, other)

        Args:
            other (IsingModel): The other IsingModel to compare against.

        Returns:
            bool: Returns true if the Ising models are identical.

        """
        return _binary_polynomial.IsingModel___eq__(self, other)


    def __ne__(self, other):
        """

        Checks the non-equality of two Ising models.

        This function has the following signature: ::

            __ne__(self, other)

        Args:
            other (IsingModel): The other IsingModel to compare against.

        Returns:
            bool: Returns true if the Ising models are not identical.

        """
        return _binary_polynomial.IsingModel___ne__(self, other)


    def _get_j_terms(self):
        val = _binary_polynomial.IsingModel__get_j_terms(self)

        return val.asdict()


        return val


    def _get_h_terms(self):
        val = _binary_polynomial.IsingModel__get_h_terms(self)

        return val.asdict()


        return val


    def add_term(self, *args):
        """

        Add a term to the IsingModel.

        This function has the following signatures: ::

            add_term(self, coefficient, index)
            add_term(self, coefficient, index_i, index_j)

        Args:
            coefficient (float): The coefficient of this term.
            index (int): The variable index of the linear term.
            index_i (int): The first variable index of the quadratic term.
            index_j (int): The second variable index of the quadratic term.


        """
        return _binary_polynomial.IsingModel_add_term(self, *args)


    def get_coefficient(self, *args):
        """

        Get the coefficient for a given term in the IsingModel.

        This function has the following signature: ::

            get_coefficient(self, index)
            get_coefficient(self, index_i, index_j)

        Args:
            index (int): The variable index of the linear term.
            index_i (int): The first variable index of the quadratic term.
            index_j (int): The second variable index of the quadratic term.

        Returns:
            float: The coefficient of the given term.


        """
        return _binary_polynomial.IsingModel_get_coefficient(self, *args)


    def _set_j_terms(self, J):
        return _binary_polynomial.IsingModel__set_j_terms(self, J)

    def _set_h_terms(self, H):
        return _binary_polynomial.IsingModel__set_h_terms(self, H)

    def has_term(self, *args):
        """

        Determine whether a term exists in the IsingModel.

        This function has the following signature: ::

            has_term(self, index)
            has_term(self, index_i, index_j)

        Args:
            index (int): The variable index of the linear term.
            index_i (int): The first variable index of the quadratic term.
            index_j (int): The second variable index of the quadratic term.

        Returns:
            bool: Returns True if the term exists in the IsingModel.


        """
        return _binary_polynomial.IsingModel_has_term(self, *args)


    def sum(self, model):
        """

        Add an IsingModel to this model.
        this.H = this.H + model.H, this.J = this.J + model.J and
        this.constant_term = this.constant_term + model.constant_term.

        This function has the following signature: ::

            sum(self, model)

        Args:
            model (IsingModel): The IsingModel to add to this model.

        """
        return _binary_polynomial.IsingModel_sum(self, model)


    def multiply_scalar(self, value):
        """

        Multiplies a scalar value to each of the terms in the Ising model.

        This function has the following signature: ::

            multiply_scalar(self, scalar)

        Args:
            scalar (float): The value to multiply into the Ising model.

        """
        return _binary_polynomial.IsingModel_multiply_scalar(self, value)


    def fit_into_range(self, max_J, max_H):
        """

        Fits the coefficients of the Ising model into the range.
        This works under the assumption that the ranges are symmetric.
        If a negative value is passed in for either J, or H, its absolute
        value will be taken. If there are no J or H terms present in the Ising model,
        then its corresponding upper bound (max_J, or max_H) will have no effect.

        This function has the following signature: ::

            fit_into_range(self, model)

        Args:
            max_J (float): The upper bound for the allowable range of J.
            max_H (float): The upper bound for the allowable range of H.

        """
        return _binary_polynomial.IsingModel_fit_into_range(self, max_J, max_H)


    __swig_getmethods__["j_terms"] = _get_j_terms
    __swig_setmethods__["j_terms"] = (_set_j_terms)
    if _newclass: j_terms = _swig_property(_get_j_terms, _set_j_terms)

    __swig_getmethods__["h_terms"] = _get_h_terms
    __swig_setmethods__["h_terms"] = (_set_h_terms)
    if _newclass: h_terms = _swig_property(_get_h_terms, _set_h_terms)

    __swig_setmethods__["constant_term"] = _binary_polynomial.IsingModel_constant_term_set
    __swig_getmethods__["constant_term"] = _binary_polynomial.IsingModel_constant_term_get
    if _newclass:
        constant_term = _swig_property(_binary_polynomial.IsingModel_constant_term_get, _binary_polynomial.IsingModel_constant_term_set)
    __swig_getmethods__["var_count"] = _binary_polynomial.IsingModel_var_count_get
    if _newclass:
        var_count = _swig_property(_binary_polynomial.IsingModel_var_count_get)

    def __init__(self):
        """

        This class represents an Isingmodel, which supports operations
        such as multiplying a scalar, arithmetic addition of Ising models, and scaling
        coefficients. The Ising model is represented as a set of quadratic (J)
        terms, a set of linear (H) terms, and a constant term.

        Attributes:
            constant_term (float): The constant term of the Ising model.
            j_terms (dict): The upper triangular J matrix which holds the mapping of the
              quadratic terms \(tuple of ints\) and their corresponding coefficients
              \(float\) ``{(term_A, term_B):coeff_AB, (term_B, term_C):coeff_BC, ... }``.
            h_terms (dict): A dictionary which holds the linear terms \(int\) mapped to their
              corresponding coefficient \(float\) ``{term:coeff}``.
            var_count (int): The number of variables in this IsingModel.

        The constructor has the following signature: ::

            IsingModel(self)


        """
        this = _binary_polynomial.new_IsingModel()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _binary_polynomial.delete_IsingModel
    __del__ = lambda self: None
IsingModel_swigregister = _binary_polynomial.IsingModel_swigregister
IsingModel_swigregister(IsingModel)


import warnings
warnings.simplefilter('always', DeprecationWarning)

class UPQuadraticBinaryPolynomial(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, UPQuadraticBinaryPolynomial, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, UPQuadraticBinaryPolynomial, name)
    __repr__ = _swig_repr

    def release(self):
        return _binary_polynomial.UPQuadraticBinaryPolynomial_release(self)
    __swig_destroy__ = _binary_polynomial.delete_UPQuadraticBinaryPolynomial
    __del__ = lambda self: None

    def __init__(self):
        this = _binary_polynomial.new_UPQuadraticBinaryPolynomial()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
UPQuadraticBinaryPolynomial_swigregister = _binary_polynomial.UPQuadraticBinaryPolynomial_swigregister
UPQuadraticBinaryPolynomial_swigregister(UPQuadraticBinaryPolynomial)

class EvalIterator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, EvalIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, EvalIterator, name)
    __repr__ = _swig_repr

    def __init__(self, eval):
        this = _binary_polynomial.new_EvalIterator(eval)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __iter__(self):
        return _binary_polynomial.EvalIterator___iter__(self)

    def next(self):
        return _binary_polynomial.EvalIterator_next(self)
    __swig_destroy__ = _binary_polynomial.delete_EvalIterator
    __del__ = lambda self: None
EvalIterator_swigregister = _binary_polynomial.EvalIterator_swigregister
EvalIterator_swigregister(EvalIterator)

class QuadraticBinaryPolynomial(IEvaluable):
    """

    Quadratic binary polynomial has terms of the form c * x_i * x_j and c * x_i.

    Attributes:
        constant_term (float): The constant offset.
        degree (int): The degree of the polynomial.
        density (float): The density of the polynomial.
        is_connected (bool): True if the induced graph is connected, False otherwise.
        is_complete_bipartite (bool): Whether or not the QUBO is complete bipartite.
        storage_type (string): The underlying storage type of the matrix representation
          of the polynomial. Can be either ``'SPARSE'`` or ``'DENSE'``.
        term_count (int): The number of terms in the polynomial, including the
          quadratic terms.
        var_count (int): The number of variables occurring in the terms.
        var_list (list): List of variable indices \(int\) ``[index_A, index_B, ...]``.
          Note: Do not call var_list inside of loops.  It invokes an expensive copy
          constructor in SWIG.

    Deprecated Attributes:
        ising_model (IsingModel): Gets an equivalent IsingModel for this QBP. Use
          qdk.binary_polynomial.ising_from_qbp instead.

    """

    __swig_setmethods__ = {}
    for _s in [IEvaluable]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, QuadraticBinaryPolynomial, name, value)
    __swig_getmethods__ = {}
    for _s in [IEvaluable]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, QuadraticBinaryPolynomial, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")

    def equals(self, other, epsilon=1e-9):
        """

        Compare two QUBOs, deep equality.

        The function has the following signature: ::

            equals(self, other)
            equals(self, other, epsilon)

        Args:
            other (QuadraticBinaryPolynomial): The polynomial to compare.
            epsilon (float): The precision used in comparing the coefficients
              (default '1e-9').

        """
        return _binary_polynomial.QuadraticBinaryPolynomial_equals(self, other, epsilon)


    def export_json(self):
        """

        Retrieves the JSON representation of the QUBO to be used with the GRPC endpoint.

        The function has the following signature: ::

            export_json(self)

        Returns:
            str: A string representation of the QUBO in JSON.


        """
        return _binary_polynomial.QuadraticBinaryPolynomial_export_json(self)


    def has_term(self, i, j):
        """

        Check whether the polynomial has a term.

        The function has the following signature: ::

            has_term(self, i, j)

        Args:
            i (int): The index of first variable.
            j (int): The index of second variable. Use same value for i, j if the term has
              one variable only.

        Return:
            bool: True if the term with the given indices exist.

        """
        return _binary_polynomial.QuadraticBinaryPolynomial_has_term(self, i, j)


    def remove_var(self, index):
        """

        Remove a variable and all its associated terms from the polynomial.

        The function has the following signature: ::

            remove_var(self, index)

        Args:
            index (int): The index of the variable to be removed.

        """
        return _binary_polynomial.QuadraticBinaryPolynomial_remove_var(self, index)


    def remove_term(self, i, j):
        """

        Remove a term from the polynomial.

        The function has the following signature: ::

            remove_term(self, i, j)

        Args:
            i (int): The index of first variable.
            j (int): The index of second variable. Use same value for i, j if the term has
              only one variable.

        """
        return _binary_polynomial.QuadraticBinaryPolynomial_remove_term(self, i, j)


    def remove_terms(self, terms):
        """

        Removes a list of terms from the QuadraticBinaryPolynomial.

        The function has the following signature: ::

            remove_terms(terms)

        Args:
            terms (list): A list of term pair tuples. Each pair is (i, j) where i is
                          the index of the first variable and j is the index of the
                          second variable.

        """
        return _binary_polynomial.QuadraticBinaryPolynomial_remove_terms(self, terms)


    def get_coefficient(self, i, j):
        """

        Returns the coefficient of a term.

        The function has the following signature: ::

            get_coefficient(self, i, j)

        Args:
            i (int): The index of first variable.
            j (int): The Index of second variable. Use same value for i, j if the term has
                     only one variable.

        Returns:
            float: coefficient of x_i x_j.

        """
        return _binary_polynomial.QuadraticBinaryPolynomial_get_coefficient(self, i, j)


    def get_ising_coefficient(self, i, j):
        """

        Returns the coefficient of a term in the equivalent ising model.

        The function has the following signature: ::

            get_ising_coefficient(self, i, j)

        Args:
            i (int): The index of first variable.
            j (int): The index of second variable. Use same value for i, j if the term has
                     only one variable.

        Returns:
            float: coefficient of x_i x_j in the equivalent ising model.

        Deprecated:
            Use qdk.binary_polynomial.ising_from_qbp to retrieve an IsingModel and then get
            the coefficients from that model.

        """
        return _binary_polynomial.QuadraticBinaryPolynomial_get_ising_coefficient(self, i, j)


    def _ising_model(self):
        return _binary_polynomial.QuadraticBinaryPolynomial__ising_model(self)

    def get_var_frequency(self, index):
        """

        Get the frequency (the number of occurrences) of a variable in the polynomial.

        The function has the following signature: ::

            get_var_frequency(self, index)

        Args:
            index (int): Variable to lookup.

        Return:
            int: Number of terms containing `index`

        """
        return _binary_polynomial.QuadraticBinaryPolynomial_get_var_frequency(self, index)


    def set_coefficient(self, coeff, i, j):
        """

        Sets the coefficient of a term.

        The function has the following signature: ::

            set_coefficient(self, coeff, j)

        Args:
            coeff (float): The coefficient of the term.
            i (int): The index of first variable.
            j (int): The index of second variable. Use same value for i, j if the term has
                     only one variable.

        """
        return _binary_polynomial.QuadraticBinaryPolynomial_set_coefficient(self, coeff, i, j)


    def _multiply_by_factor(self, constant):
        """

        Multiply the current terms by a factor.

        The function has the following signature: ::

            multiply_by_factor(self, constant)

        Args:
            constant (float): The multiplication factor.

        """
        return _binary_polynomial.QuadraticBinaryPolynomial__multiply_by_factor(self, constant)


    def fit_into_range(self, range=1):
        """

        Normalizes the coefficients of the quadratic binary polynomial.

        The function has the following signature: ::

            fit_into_range(self, range)

        Args:
            range (float): The upper bound of the range to fit into (default '1').

        """
        return _binary_polynomial.QuadraticBinaryPolynomial_fit_into_range(self, range)


    def Sum(self, other):
        """

        Add another polynomial to this polynomial. The coefficients of common terms
        will be added together.

        The function has the following signature: ::

            sum(self, other)

        Args:
            other (QuadraticBinaryPolynomial): The polynomial to be added.


        """
        return _binary_polynomial.QuadraticBinaryPolynomial_Sum(self, other)


    def _multiply_quad_poly_inplace(self, other):
        """

        Multiply this QuadraticBinaryPolynomial with another.

        The function has the following signature: ::

            multiply_quad_poly_inplace(other)

        Args:
            other (QuadraticBinaryPolynomial): The QuadraticBinaryPolynomial to be
                                               multiplied.

        """
        return _binary_polynomial.QuadraticBinaryPolynomial__multiply_quad_poly_inplace(self, other)


    def _power(self, exponent):
        """

        Raise the QuadraticBinaryPolynomial to a power.
        The order of the resulting polynomial must not be greater than 2.

        The function has the following signature: ::

            power(other)

        Args:
            exponent (int): The exponent value.

        Raises:
            RuntimeError: If the order of the resulting polynomial
              is greater than 2. This instance will be the same as it was before
              this function was called.

        Deprecated:
            To square the contents of a QuadraticBinaryPolynomial, use the square function.
            If you wish to raise a QuadraticBinaryPolynomial to a power higher than 2,
            create a BinaryPolynomial and use its power function instead.

        """
        return _binary_polynomial.QuadraticBinaryPolynomial__power(self, exponent)


    def _multiply_quad_poly(self, other):
        """

        multiply two quadratic binary polynomials.

        The function has the following signature: ::

            multiply_quad_poly(other)

        Args:
            other (QuadraticBinaryPolynomial): the other polynomial to multiply this one against.

        Returns:
            BinaryPolynomial: The resulting polynomial.

        """
        return _binary_polynomial.QuadraticBinaryPolynomial__multiply_quad_poly(self, other)


    def clone(self):
        """

        Clones the polynomial.

        The function has the following signature: ::

            clone(self)

        Return:
            QuadraticBinaryPolynomial: Clone of the QUBO.

        """
        return _binary_polynomial.QuadraticBinaryPolynomial_clone(self)


    def project(self, indices):
        """

        Project the polynomial into smaller polynomial.

        The function has the following signature: ::

            project(self, indices)

        Args:
            indices (list): A list of indices \(int\) of the original QUBO
             to include in the new QUBO ``[index_A, index_B, ...]``

        Return:
            QuadraticBinaryPolynomial: The projected QUBO.

        """
        return _binary_polynomial.QuadraticBinaryPolynomial_project(self, indices)


    def _multiply(self, *args):
        return _binary_polynomial.QuadraticBinaryPolynomial__multiply(self, *args)

    def _square(self):
        return _binary_polynomial.QuadraticBinaryPolynomial__square(self)

    def _sum(self, qbp):
        return _binary_polynomial.QuadraticBinaryPolynomial__sum(self, qbp)

    def to_string(self, meta_data=False):
        """

        Converts this polynomial into a string.

        The function has the following signatures: ::

            to_string(self)
            to_string(self, meta_data)

        Args:
            meta_data (bool): If True, the string will contain meta data such as degree
              and term count (default 'False').

        Return:
            string: The string representation of this polynomial. If meta data is not
              set to true, the string is 0 if the polynomial is empty.

        """
        return _binary_polynomial.QuadraticBinaryPolynomial_to_string(self, meta_data)


    def _storage_type(self):
        return _binary_polynomial.QuadraticBinaryPolynomial__storage_type(self)

    def get_term_by_number(self, n):
        """

        Get the Nth term of this polynomial. This function gets called by the object's
        ``__getitem()__`` method.

        The function has the following signature: ::

            get_term_by_number(self, n)

        Args:
            n (int): Term number between 0 and get_terms_count() - 1.

        Return:
            BinaryPolynomialTerm: The term retrieved at the given index.

        """
        return _binary_polynomial.QuadraticBinaryPolynomial_get_term_by_number(self, n)


    def __eq__(self, other):
        return _binary_polynomial.QuadraticBinaryPolynomial___eq__(self, other)

    def __ne__(self, other):
        return _binary_polynomial.QuadraticBinaryPolynomial___ne__(self, other)

    def __repr__(self):
        """

        This function returns the string representation of the
        QuadraticBinaryPolynomial.

        The function has the following signature: ::

            __repr__(self)

        Returns:
            str: The string representation of all the terms in the
              QuadraticBinaryPolynomial.

        """
        return _binary_polynomial.QuadraticBinaryPolynomial___repr__(self)


    def __iter__(self):
        return _binary_polynomial.QuadraticBinaryPolynomial___iter__(self)

    def __getitem__(self, term_number):
        """

        Called to implement evaluation of self[key]. This function calls ``self.get_term_by_counter()``
        and returns the term by its index.

        The function has the following signature: ::

            __getitem__(self, term_number)

        Args:
            term_number (int): number between 0 and get_terms_count() - 1.

        Return:
            BinaryPolynomialTerm: term.

        """
        return _binary_polynomial.QuadraticBinaryPolynomial___getitem__(self, term_number)


    def export_matrix(self):
        """
        Returns an upper triangular matrix representation of the polynomial.
        Each term becomes an entry in the matrix.

        Columns correspond to sorted variable indices.

        Column 0 corresponds to the smallest variable index.

        Column n - 1 corresponds to the largest variable index.

        This function has the following signature: ::

            export_matrix(self)

        Returns:
            numpy.matrix: A matrix representation of the
            ``QuadraticBinaryPolynomial``, whose shape is
            (``var_count``, ``var_count``)

        """

        try:
            import numpy as np
        except:
            raise Exception('Cannot import numpy')
            return

        num_count = self.var_count
        var_index_list = self.var_list
        var_size = len(var_index_list)

        array = np.zeros((num_count, num_count))

        for i in range(0, var_size):
            for j in range(i, var_size):
                coeff = self.get_coefficient(var_index_list[i], var_index_list[j])
                if coeff != 0:
                    array[i, j] = coeff

        return np.asmatrix(array)


    def export_array(self):
        """
        Returns an upper triangular matrix representation of the polynomial.
        Each term becomes an entry in the array.

        Columns correspond to sorted variable indices.

        Column 0 corresponds to the smallest variable index.

        Column n - 1 corresponds to the largest variable index.

        This function has the following signature: ::

            export_array(self)

        Returns:
            numpy.array: A 2D array representation of the
            ``QuadraticBinaryPolynomial``, whose shape is
            (``var_count``, ``var_count``)

        """

        try:
            import numpy as np
        except:
            raise Exception('Cannot import numpy')
            return

        num_count = self.var_count
        var_index_list = self.var_list
        var_size = len(var_index_list)

        array = np.zeros((num_count, num_count))

        for i in range(0, var_size):
            for j in range(i, var_size):
                coeff = self.get_coefficient(var_index_list[i], var_index_list[j])
                if coeff != 0:
                    array[i, j] = coeff

        return array


    def __reduce__(self):
        builder = QuadraticBinaryPolynomialBuilder()
        terms = []
        for term in self:
          terms.append({ "coefficient" : term.coefficient, "var_list" : tuple(term.var_list)})

        ret = {
            "storage": self.storage_type,
            "terms" : terms,
            "builder" : builder
        }
        return _qdk.QuadraticBinaryPolynomialBuilder_build_polynomial, (builder,), ret

    def __setstate__(self, state):
        storage = state["storage"]
        builder = state["builder"]
        for term in state["terms"]:
          if len(term["var_list"]) == 2:
            builder.add_term(term["coefficient"], term["var_list"][0], term["var_list"][1])
          elif len(term["var_list"]) == 1:
            builder.add_term(term["coefficient"], term["var_list"][0], term["var_list"][0])
          elif len(term["var_list"]) > 2:
            raise Exception('Cannot unpickle QUBO with terms that have more than 2 variables')
          else:
            builder.constant_term = term["coefficient"]
        poly = builder.build_polynomial(storage)
        self.__class__ = poly.__class__
        self.__dict__.update(poly.__dict__)

    def power(self, exp):
      return self._power(exp)
      raise DeprecationWarning("quadratic_binary_polynomial power is deprecated, use the square function, or use binary_polynomial power")

    def square(self):
      return self._square()

    def sum(self, x):
      return self._sum(x)

    def multiply(self, x):
      return self._multiply(x)

    def multiply_quad_poly(self, x):
      warnings.warn("quadratic_binary_polynomial multiply_quad_poly is deprecated, use the multiply() function", DeprecationWarning)
      return self._multiply_quad_poly(x)

    def multiply_quad_poly_inplace(self, x):
      warnings.warn("quadratic_binary_polynomial multiply_quad_poly_inplace is deprecated, use the multiply() function", DeprecationWarning)
      return self._multiply_quad_poly_inplace(x)

    def multiply_by_factor(self, x):
      warnings.warn("quadratic_binary_polynomial multiply_by_factor is deprecated, use the multiply() function", DeprecationWarning)
      return self._multiply_by_factor(x)



    __swig_getmethods__["storage_type"] = _storage_type
    if _newclass: storage_type = _swig_property(_storage_type)

    __swig_getmethods__["ising_model"] = _ising_model
    if _newclass: ising_model = _swig_property(_ising_model)

    __swig_setmethods__["constant_term"] = _binary_polynomial.QuadraticBinaryPolynomial_constant_term_set
    __swig_getmethods__["constant_term"] = _binary_polynomial.QuadraticBinaryPolynomial_constant_term_get
    if _newclass:
        constant_term = _swig_property(_binary_polynomial.QuadraticBinaryPolynomial_constant_term_get, _binary_polynomial.QuadraticBinaryPolynomial_constant_term_set)
    __swig_getmethods__["degree"] = _binary_polynomial.QuadraticBinaryPolynomial_degree_get
    if _newclass:
        degree = _swig_property(_binary_polynomial.QuadraticBinaryPolynomial_degree_get)
    __swig_getmethods__["density"] = _binary_polynomial.QuadraticBinaryPolynomial_density_get
    if _newclass:
        density = _swig_property(_binary_polynomial.QuadraticBinaryPolynomial_density_get)
    __swig_getmethods__["is_complete_bipartite"] = _binary_polynomial.QuadraticBinaryPolynomial_is_complete_bipartite_get
    if _newclass:
        is_complete_bipartite = _swig_property(_binary_polynomial.QuadraticBinaryPolynomial_is_complete_bipartite_get)
    __swig_getmethods__["is_connected"] = _binary_polynomial.QuadraticBinaryPolynomial_is_connected_get
    if _newclass:
        is_connected = _swig_property(_binary_polynomial.QuadraticBinaryPolynomial_is_connected_get)
    __swig_getmethods__["term_count"] = _binary_polynomial.QuadraticBinaryPolynomial_term_count_get
    if _newclass:
        term_count = _swig_property(_binary_polynomial.QuadraticBinaryPolynomial_term_count_get)
    __swig_getmethods__["var_count"] = _binary_polynomial.QuadraticBinaryPolynomial_var_count_get
    if _newclass:
        var_count = _swig_property(_binary_polynomial.QuadraticBinaryPolynomial_var_count_get)
    __swig_destroy__ = _binary_polynomial.delete_QuadraticBinaryPolynomial
    __del__ = lambda self: None
QuadraticBinaryPolynomial_swigregister = _binary_polynomial.QuadraticBinaryPolynomial_swigregister
QuadraticBinaryPolynomial_swigregister(QuadraticBinaryPolynomial)

class VectorQbp(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, VectorQbp, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, VectorQbp, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _binary_polynomial.VectorQbp_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _binary_polynomial.VectorQbp___nonzero__(self)

    def __bool__(self):
        return _binary_polynomial.VectorQbp___bool__(self)

    def __len__(self):
        return _binary_polynomial.VectorQbp___len__(self)

    def __getslice__(self, i, j):
        return _binary_polynomial.VectorQbp___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _binary_polynomial.VectorQbp___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _binary_polynomial.VectorQbp___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _binary_polynomial.VectorQbp___delitem__(self, *args)

    def __getitem__(self, *args):
        return _binary_polynomial.VectorQbp___getitem__(self, *args)

    def __setitem__(self, *args):
        return _binary_polynomial.VectorQbp___setitem__(self, *args)

    def pop(self):
        return _binary_polynomial.VectorQbp_pop(self)

    def append(self, x):
        return _binary_polynomial.VectorQbp_append(self, x)

    def empty(self):
        return _binary_polynomial.VectorQbp_empty(self)

    def size(self):
        return _binary_polynomial.VectorQbp_size(self)

    def swap(self, v):
        return _binary_polynomial.VectorQbp_swap(self, v)

    def begin(self):
        return _binary_polynomial.VectorQbp_begin(self)

    def end(self):
        return _binary_polynomial.VectorQbp_end(self)

    def rbegin(self):
        return _binary_polynomial.VectorQbp_rbegin(self)

    def rend(self):
        return _binary_polynomial.VectorQbp_rend(self)

    def clear(self):
        return _binary_polynomial.VectorQbp_clear(self)

    def get_allocator(self):
        return _binary_polynomial.VectorQbp_get_allocator(self)

    def pop_back(self):
        return _binary_polynomial.VectorQbp_pop_back(self)

    def erase(self, *args):
        return _binary_polynomial.VectorQbp_erase(self, *args)

    def __init__(self, *args):
        this = _binary_polynomial.new_VectorQbp(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _binary_polynomial.VectorQbp_push_back(self, x)

    def front(self):
        return _binary_polynomial.VectorQbp_front(self)

    def back(self):
        return _binary_polynomial.VectorQbp_back(self)

    def assign(self, n, x):
        return _binary_polynomial.VectorQbp_assign(self, n, x)

    def resize(self, *args):
        return _binary_polynomial.VectorQbp_resize(self, *args)

    def insert(self, *args):
        return _binary_polynomial.VectorQbp_insert(self, *args)

    def reserve(self, n):
        return _binary_polynomial.VectorQbp_reserve(self, n)

    def capacity(self):
        return _binary_polynomial.VectorQbp_capacity(self)
    __swig_destroy__ = _binary_polynomial.delete_VectorQbp
    __del__ = lambda self: None
VectorQbp_swigregister = _binary_polynomial.VectorQbp_swigregister
VectorQbp_swigregister(VectorQbp)

class UPBuilder(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, UPBuilder, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, UPBuilder, name)
    __repr__ = _swig_repr

    def release(self):
        return _binary_polynomial.UPBuilder_release(self)
    __swig_destroy__ = _binary_polynomial.delete_UPBuilder
    __del__ = lambda self: None

    def __init__(self):
        this = _binary_polynomial.new_UPBuilder()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
UPBuilder_swigregister = _binary_polynomial.UPBuilder_swigregister
UPBuilder_swigregister(UPBuilder)

class QuadraticBinaryPolynomialBuilder(_object):
    """

    This class is a buffer for building quadratic polynomials.

    Attributes:
       constant_term (float): The value of the constant term.
       var_count (int): The number of variables in the builder.
       density_threshold (float): The density threshold of the builder.

    The constructor has the following signature: ::

        QuadraticBinaryPolynomialBuilder(self)
        QuadraticBinaryPolynomialBuilder(self, qbp)

    Raises:
        RuntimeError: If density_threshold is beyond the range [0,1].


    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, QuadraticBinaryPolynomialBuilder, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, QuadraticBinaryPolynomialBuilder, name)

    def __init__(self, *args):
        """

        This class is a buffer for building quadratic polynomials.

        Attributes:
           constant_term (float): The value of the constant term.
           var_count (int): The number of variables in the builder.
           density_threshold (float): The density threshold of the builder.

        The constructor has the following signature: ::

            QuadraticBinaryPolynomialBuilder(self)
            QuadraticBinaryPolynomialBuilder(self, qbp)

        Raises:
            RuntimeError: If density_threshold is beyond the range [0,1].


        """
        this = _binary_polynomial.new_QuadraticBinaryPolynomialBuilder(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def add_term(self, *args):
        """

        Add a term coeff * x_i * c_j to the current polynomial.

        The function has the following signature: ::

            add_term(self, coeff, i, j)

        Args:
            coeff (float): The coefficient of the term.
            i (int): The index of first variable.
            j (int): The index of second variable.
                     Use  same value for i, j if the term has only one variable.

        """
        return _binary_polynomial.QuadraticBinaryPolynomialBuilder_add_term(self, *args)


    def has_term(self, i, j):
        """

        This allows user to check if a certain term is already added to the builder.

        The function has the following signature: ::

            has_term(self, i, j)

        Args:
            i (int): The index of first variable.
            j (int): The index of second variable.
                     Use same value for i, j if the term has one only variable.

        Returns:
            bool: True if the term x_i * x_j is already added to the builder.

        """
        return _binary_polynomial.QuadraticBinaryPolynomialBuilder_has_term(self, i, j)


    def get_coefficient(self, i, j):
        """

        This allows user to get the current coefficient of a term in the builder.

        The function has the following signature: ::

            get_coefficient(self, i, j)

        Args:
            i (int): The Index of first variable.
            j (int): The Index of second variable.
                     Use same value for i, j if the term has only one variable.

        Returns:
            float: The current coefficient of the term.

        """
        return _binary_polynomial.QuadraticBinaryPolynomialBuilder_get_coefficient(self, i, j)


    def get_ising_coefficient(self, i, j):
        """

        Allows users to get the coefficient of a term in the equivalent ising model.

        The function has the following signature: ::

            get_ising_coefficient(self, i, j)

        Args:
            i (int): The Index of first variable.
            j (int): The Index of second variable.
                     Use same value for i, j if the term has only one variable.

        Returns:
            float: The coefficient of the term in the equivalent ising model.

        """
        return _binary_polynomial.QuadraticBinaryPolynomialBuilder_get_ising_coefficient(self, i, j)


    def set_coefficient(self, coeff, i, j):
        """

        This allows user to set the coefficient of a term in the builder.

        The function has the following signature: ::

            set_coefficient(self, coeff, i, j)

        Args:
            coeff (float): The new value of the coefficient.
            i (int): The index of first variable.
            j (int): The index of second variable.

        """
        return _binary_polynomial.QuadraticBinaryPolynomialBuilder_set_coefficient(self, coeff, i, j)


    def add_constant_term(self, value):
        """

        Increment the value of the constant term.

        The function has the following signature: ::

            add_constant_term(value)

        Args:
            value (float): The value added to the constant term.

        """
        return _binary_polynomial.QuadraticBinaryPolynomialBuilder_add_constant_term(self, value)


    def remove_term(self, i, j):
        """

        Remove a term from the current set of terms.

        The function has the following signature: ::

            remove_term(i, j)

        Args:
            i (int): The index of first variable.
            j (int): The index of second variable.
                     Use same value for i, j if the term has only one variable.

        """
        return _binary_polynomial.QuadraticBinaryPolynomialBuilder_remove_term(self, i, j)


    def remove_var(self, index):
        """

        Remove a variable and all its associated terms from the current terms.

        The function has the following signature: ::

            remove_var(self, index)

        Args:
            index (int): The index of the variable to be removed.

        """
        return _binary_polynomial.QuadraticBinaryPolynomialBuilder_remove_var(self, index)


    def multiply_by_factor(self, constant):
        """

        Multiply the current terms by a factor.

        The function has the following signature: ::

            multiply_by_factor(self, constant)

        Args:
            constant (float): The multiplication factor.

        """
        return _binary_polynomial.QuadraticBinaryPolynomialBuilder_multiply_by_factor(self, constant)


    def import_matrix(self, matrix, var_list=None):
        """
        Resets the buffer with terms imported from ``matrix``.

        All elements in the matrix will be read.

        If a list of variable indices is provided, the resulting polynomial's
        variable indices will be replaced with those in the list. The indices
        will be replaced in the same order as the list.

        This function has the following signature: ::

            import_matrix(self, matrix, var_list=None)

        Args:
            matrix (numpy.matrix): A matrix representation of the
             ``QuadraticBinaryPolynomial``.

            var_list (list): (optional) variable indices.

        Note:
            ``matrix`` must be a square matrix, and its dimensions must match
            number of variables in ``var_list`` (if provided).

        """

        try:
            import numpy
        except ImportError:
            raise ImportError('Cannot import numpy')
            return

        if not isinstance(matrix, numpy.matrix):
            raise Exception('Argument is not an object of type numpy.matrix')

        if (matrix.shape[0] != matrix.shape[1]):
            raise Exception('Matrix is not square')

        if (var_list == None):
            var_list = [i for i in range(matrix.shape[0])]

        if (matrix.shape[0] != len(var_list)):
            raise Exception('Matrix dimensions must equal number of variables')

        self.reset()

        var_count = matrix.shape[0] # add terms
        for i in xrange(var_count):
            x = var_list[i]
            for j in xrange(var_count):
                y = var_list[j]
                coeff = matrix[i, j]
                if coeff != 0:
                    self.add_term(coeff, x, y)


    def import_array(self, array, var_list=None):
        """
        Resets the buffer with terms imported from ``array``.

        All elements in the array will be read.

        If a list of variable indices is provided, the resulting polynomial's
        variable indices will be replaced with those in the list. The indices
        will be replaced in the same order as the list.

        This function has the following signature: ::

            import_array(self, array, var_list=None)

        Args:
            array (numpy.array): A 2D array representation of the
             ``QuadraticBinaryPolynomial``.

            var_list (list): (optional) variable indices.

        Note:
            ``array`` must be a N by N array, and its dimensions must match
            number of variables in ``var_list`` (if provided).

        """

        try:
            import numpy
        except ImportError:
            raise ImportError('Cannot import numpy')
            return

        if not isinstance(array, numpy.ndarray):
            raise Exception('Argument is not an object of type numpy.ndarray')

        if (array.shape[0] != array.shape[1]):
            raise Exception('2D is not N by N')

        if (var_list == None):
            var_list = [i for i in range(array.shape[0])]

        if (array.shape[0] != len(var_list)):
            raise Exception('Array dimensions must equal number of variables')

        self.reset()

        var_count = array.shape[0] # add terms
        for i in xrange(var_count):
            x = var_list[i]
            for j in xrange(var_count):
                y = var_list[j]
                coeff = array[i, j]
                if coeff != 0:
                    self.add_term(coeff, x, y)


    def build_polynomial(self, *args):
        """

        Build polynomial from the current set of terms.

        The function has the following signatures: ::

            build_polynomial(self, storage_type)
            build_polynomial(self, density_threshold=0.5)

        Args:
            storage_type (string): Specify the storage type: ``'SPARSE'`` or ``'DENSE'``
            density_threshold (float): Density threshold for the polynomial (default 0.5).
            Dense representation is used if
            ``(number of terms) / (max. number of possible terms) > density_threshold``.
            The density threshold is within the range [0, 1].

        Returns:
            QuadraticBinaryPolynomial: The final polynomial.

        """
        return _binary_polynomial.QuadraticBinaryPolynomialBuilder_build_polynomial(self, *args)


    def build_polynomial_from_ising(self, *args):
        """

        Deprecated:
            It is recommended to use ``IsingModel.qubo`` attribute.

        Build a binary polynomial from the current set of terms,
        assuming they are ising terms.

        The function has the following signature: ::

            build_polynomial_from_ising(self, storage_type='SPARSE')

        Args:
            storage_type (string): Specify the storage type, either ``'SPARSE'`` (default) or ``'DENSE'``.

        Returns:
            BinaryPolynomial: A binary polynomial that is equivalent to the ising terms given.

        """
        return _binary_polynomial.QuadraticBinaryPolynomialBuilder_build_polynomial_from_ising(self, *args)


    def __repr__(self):
        return _binary_polynomial.QuadraticBinaryPolynomialBuilder___repr__(self)

    def multiply_quadratic_binary_polynomial(self, other):
        """

        Multiply the polynomial in this builder with a QuadraticBinaryPolynomial.
        The order of the resulting polynomial must not be greater than 2.

        The function has the following signature: ::

            multiply_quadratic_binary_polynomial(self, other)

        Args:
            other (QuadraticBinaryPolynomial): The polynomial to be multiplied.

        """
        return _binary_polynomial.QuadraticBinaryPolynomialBuilder_multiply_quadratic_binary_polynomial(self, other)


    def _power(self, exponent):
        """

        Raise the QuadraticBinaryPolynomial in the builder to a power.
        The order of the resulting polynomial must not be greater than 2.

        The function has the following signature: ::

            power(other)

        Args:
            exponent (int): The exponent value.

        Deprecated:
            To square the contents of a QuadraticBinaryPolynomialBuilder, use
            build_polynomial to create a QuadraticBinaryPolynomial, and call square.
            If you wish to raise a QuadraticBinaryPolynomial to a power higher than 2,
            create a BinaryPolynomial and use its power function instead.

        """
        return _binary_polynomial.QuadraticBinaryPolynomialBuilder__power(self, exponent)


    def __reduce__(self):
        return self.__class__, ()

    def power(self, exp):
      self._power(exp)
      raise DeprecationWarning("quadratic_binary_polynomial power is deprecated, use the square function, or use binary_polynomial power")


    def reset(self):
        """

        Clears the builder buffer.

        The function has the following signature: ::
            reset()


        """
        return _binary_polynomial.QuadraticBinaryPolynomialBuilder_reset(self)

    __swig_setmethods__["constant_term"] = _binary_polynomial.QuadraticBinaryPolynomialBuilder_constant_term_set
    __swig_getmethods__["constant_term"] = _binary_polynomial.QuadraticBinaryPolynomialBuilder_constant_term_get
    if _newclass:
        constant_term = _swig_property(_binary_polynomial.QuadraticBinaryPolynomialBuilder_constant_term_get, _binary_polynomial.QuadraticBinaryPolynomialBuilder_constant_term_set)
    __swig_setmethods__["density_threshold"] = _binary_polynomial.QuadraticBinaryPolynomialBuilder_density_threshold_set
    __swig_getmethods__["density_threshold"] = _binary_polynomial.QuadraticBinaryPolynomialBuilder_density_threshold_get
    if _newclass:
        density_threshold = _swig_property(_binary_polynomial.QuadraticBinaryPolynomialBuilder_density_threshold_get, _binary_polynomial.QuadraticBinaryPolynomialBuilder_density_threshold_set)
    __swig_getmethods__["var_count"] = _binary_polynomial.QuadraticBinaryPolynomialBuilder_var_count_get
    if _newclass:
        var_count = _swig_property(_binary_polynomial.QuadraticBinaryPolynomialBuilder_var_count_get)
    __swig_destroy__ = _binary_polynomial.delete_QuadraticBinaryPolynomialBuilder
    __del__ = lambda self: None
QuadraticBinaryPolynomialBuilder_swigregister = _binary_polynomial.QuadraticBinaryPolynomialBuilder_swigregister
QuadraticBinaryPolynomialBuilder_swigregister(QuadraticBinaryPolynomialBuilder)

class Hobo2QuboAgent(_object):
    """

    An agent to interact between HOBO and QUBO.

    Attributes:
        constraint (list): Contains tuples of size 4. The tuple contains the auxiliary variable
            index \(int\), the two original variable indices \(int\), and the coefficient
            of the auxiliary variable \(float\).

    The constructor has the following signature: ::

        Hobo2QuboAgent(self, quad_builder)

    Args:
        quad_builder (QuadraticBinaryPolynomialBuilder): Used to build
            the QuadraticBinaryPolynomial.

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Hobo2QuboAgent, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Hobo2QuboAgent, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        if self.__class__ == Hobo2QuboAgent:
            _self = None
        else:
            _self = self
        this = _binary_polynomial.new_Hobo2QuboAgent(_self, *args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def translate(self, hobo):
        return _binary_polynomial.Hobo2QuboAgent_translate(self, hobo)

    def _get_constraint(self):
        return _binary_polynomial.Hobo2QuboAgent__get_constraint(self)

    __swig_getmethods__["constraint"] = _get_constraint
    if _newclass: constraint = _swig_property(_get_constraint)

    __swig_destroy__ = _binary_polynomial.delete_Hobo2QuboAgent
    __del__ = lambda self: None
    __swig_getmethods__["var_count"] = _binary_polynomial.Hobo2QuboAgent_var_count_get
    if _newclass:
        var_count = _swig_property(_binary_polynomial.Hobo2QuboAgent_var_count_get)
    def __disown__(self):
        self.this.disown()
        _binary_polynomial.disown_Hobo2QuboAgent(self)
        return weakref_proxy(self)
Hobo2QuboAgent_swigregister = _binary_polynomial.Hobo2QuboAgent_swigregister
Hobo2QuboAgent_swigregister(Hobo2QuboAgent)


def ising_from_qbp(qbp):
    """

    Gets an equivalent IsingModel from the given QuadraticBinaryPolynomial.

    This function has the following signatures: ::

        ising_from_qbp(qbp)

    Args:
        qbp (QuadraticBinaryPolynomial): The QuadraticBinaryPolynomial to convert.


    """
    return _binary_polynomial.ising_from_qbp(qbp)

def qbp_from_ising(ising):
    """

    Gets an equivalent QuadraticBinaryPolynomial from the given IsingModel.

    This function has the following signatures: ::

        qbp_from_ising(ising)

    Args:
        ising (IsingModel): The IsingModel to convert.


    """
    return _binary_polynomial.qbp_from_ising(ising)

def qbp_from_string(str):
    """

    Gets an equivalent QuadraticBinaryPolynomial from the given string

    The string representation supported is the same as the output from the to_string
        function of QuadraticBinaryPolynomial. An example is the string
        `2 x_2 x_3 + 4 x_4 - 7`. The whitespace between any terms is optional as are
        the underscores. The terms may be in any order.

    This function has the following signatures: ::

        qbp_from_string(string)

    Args:
        string (string): The string representation to convert.

    Raises:
        RuntimeError: If the input is not a valid string represnetation.


    """
    return _binary_polynomial.qbp_from_string(str)

def reduce_qbp_by_configuration(qbp, configuration):
    """

    Partially evaluate the passed in QuadraticBinaryPolynomial using values in the
        given configuration and returns a new QuadraticBinaryPolynomial.

    This function has the following signatures: ::

        reduce_qbp_by_configuration(qbp, configuration)

    Args:
        qbp (QuadraticBinaryPolynomial): The polynomial to reduce.
        configuration (dict): A dict containing integer keys mapped to boolean
            values specifying which variables to reduce and their final values.


    """
    return _binary_polynomial.reduce_qbp_by_configuration(qbp, configuration)
# This file is compatible with both classic and new-style classes.


