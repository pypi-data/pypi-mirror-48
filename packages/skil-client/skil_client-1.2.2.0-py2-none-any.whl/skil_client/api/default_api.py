# coding: utf-8

"""
    Endpoints

    Endpoints API for different services in SKIL  # noqa: E501

    The version of the OpenAPI document: 1.2.2
    Generated by: https://openapi-generator.tech
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from skil_client.api_client import ApiClient
from skil_client.exceptions import (
    ApiTypeError,
    ApiValueError
)


class DefaultApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def accumulated_results(self, **kwargs):  # noqa: E501
        """Tells how many retraining examples have labels associated with them.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.accumulated_results(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: AccumulatedResults
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.accumulated_results_with_http_info(**kwargs)  # noqa: E501

    def accumulated_results_with_http_info(self, **kwargs):  # noqa: E501
        """Tells how many retraining examples have labels associated with them.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.accumulated_results_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(AccumulatedResults, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method accumulated_results" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/accumulatedresults', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AccumulatedResults',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_credentials(self, add_credentials_request, **kwargs):  # noqa: E501
        """Adds credentials  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_credentials(add_credentials_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param AddCredentialsRequest add_credentials_request: Add credentials request object (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ResourceCredentials
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.add_credentials_with_http_info(add_credentials_request, **kwargs)  # noqa: E501

    def add_credentials_with_http_info(self, add_credentials_request, **kwargs):  # noqa: E501
        """Adds credentials  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_credentials_with_http_info(add_credentials_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param AddCredentialsRequest add_credentials_request: Add credentials request object (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ResourceCredentials, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['add_credentials_request']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_credentials" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'add_credentials_request' is set
        if ('add_credentials_request' not in local_var_params or
                local_var_params['add_credentials_request'] is None):
            raise ApiValueError("Missing the required parameter `add_credentials_request` when calling `add_credentials`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'add_credentials_request' in local_var_params:
            body_params = local_var_params['add_credentials_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/resources/credentials', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ResourceCredentials',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_evaluation_result(self, model_history_server_id, evaluation_results_entity, **kwargs):  # noqa: E501
        """Adds an evaluation result  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_evaluation_result(model_history_server_id, evaluation_results_entity, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str model_history_server_id: Process GUID of the model history server. Run `$SKIL_HOME/sbin/skil services` in a console to find out the model history server GUID. (required)
        :param EvaluationResultsEntity evaluation_results_entity: The evaluation result entity (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: EvaluationResultsEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.add_evaluation_result_with_http_info(model_history_server_id, evaluation_results_entity, **kwargs)  # noqa: E501

    def add_evaluation_result_with_http_info(self, model_history_server_id, evaluation_results_entity, **kwargs):  # noqa: E501
        """Adds an evaluation result  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_evaluation_result_with_http_info(model_history_server_id, evaluation_results_entity, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str model_history_server_id: Process GUID of the model history server. Run `$SKIL_HOME/sbin/skil services` in a console to find out the model history server GUID. (required)
        :param EvaluationResultsEntity evaluation_results_entity: The evaluation result entity (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(EvaluationResultsEntity, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['model_history_server_id', 'evaluation_results_entity']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_evaluation_result" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'model_history_server_id' is set
        if ('model_history_server_id' not in local_var_params or
                local_var_params['model_history_server_id'] is None):
            raise ApiValueError("Missing the required parameter `model_history_server_id` when calling `add_evaluation_result`")  # noqa: E501
        # verify the required parameter 'evaluation_results_entity' is set
        if ('evaluation_results_entity' not in local_var_params or
                local_var_params['evaluation_results_entity'] is None):
            raise ApiValueError("Missing the required parameter `evaluation_results_entity` when calling `add_evaluation_result`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model_history_server_id' in local_var_params:
            path_params['modelHistoryServerId'] = local_var_params['model_history_server_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'evaluation_results_entity' in local_var_params:
            body_params = local_var_params['evaluation_results_entity']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/rpc/{modelHistoryServerId}/model/revisions/evaluations/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EvaluationResultsEntity',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_example_for_batch(self, model_history_server_id, add_example_request, **kwargs):  # noqa: E501
        """Adds a number of examples to a minibatch ID given an AddExampleRequest.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_example_for_batch(model_history_server_id, add_example_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str model_history_server_id: Process GUID of the model history server. Run `$SKIL_HOME/sbin/skil services` in a console to find out the model history server GUID. (required)
        :param AddExampleRequest add_example_request: The add example request, encapsulating minibatch details and examples batch size (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: AddExampleRequest
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.add_example_for_batch_with_http_info(model_history_server_id, add_example_request, **kwargs)  # noqa: E501

    def add_example_for_batch_with_http_info(self, model_history_server_id, add_example_request, **kwargs):  # noqa: E501
        """Adds a number of examples to a minibatch ID given an AddExampleRequest.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_example_for_batch_with_http_info(model_history_server_id, add_example_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str model_history_server_id: Process GUID of the model history server. Run `$SKIL_HOME/sbin/skil services` in a console to find out the model history server GUID. (required)
        :param AddExampleRequest add_example_request: The add example request, encapsulating minibatch details and examples batch size (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(AddExampleRequest, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['model_history_server_id', 'add_example_request']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_example_for_batch" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'model_history_server_id' is set
        if ('model_history_server_id' not in local_var_params or
                local_var_params['model_history_server_id'] is None):
            raise ApiValueError("Missing the required parameter `model_history_server_id` when calling `add_example_for_batch`")  # noqa: E501
        # verify the required parameter 'add_example_request' is set
        if ('add_example_request' not in local_var_params or
                local_var_params['add_example_request'] is None):
            raise ApiValueError("Missing the required parameter `add_example_request` when calling `add_example_for_batch`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model_history_server_id' in local_var_params:
            path_params['modelHistoryServerId'] = local_var_params['model_history_server_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'add_example_request' in local_var_params:
            body_params = local_var_params['add_example_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/rpc/{modelHistoryServerId}/model/exampleForBatch', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AddExampleRequest',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_example_to_minibatch(self, model_history_server_id, example_entity, **kwargs):  # noqa: E501
        """Adds an example to a minibatch  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_example_to_minibatch(model_history_server_id, example_entity, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str model_history_server_id: Process GUID of the model history server. Run `$SKIL_HOME/sbin/skil services` in a console to find out the model history server GUID. (required)
        :param ExampleEntity example_entity: The example to add to the minibatch (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ExampleEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.add_example_to_minibatch_with_http_info(model_history_server_id, example_entity, **kwargs)  # noqa: E501

    def add_example_to_minibatch_with_http_info(self, model_history_server_id, example_entity, **kwargs):  # noqa: E501
        """Adds an example to a minibatch  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_example_to_minibatch_with_http_info(model_history_server_id, example_entity, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str model_history_server_id: Process GUID of the model history server. Run `$SKIL_HOME/sbin/skil services` in a console to find out the model history server GUID. (required)
        :param ExampleEntity example_entity: The example to add to the minibatch (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ExampleEntity, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['model_history_server_id', 'example_entity']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_example_to_minibatch" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'model_history_server_id' is set
        if ('model_history_server_id' not in local_var_params or
                local_var_params['model_history_server_id'] is None):
            raise ApiValueError("Missing the required parameter `model_history_server_id` when calling `add_example_to_minibatch`")  # noqa: E501
        # verify the required parameter 'example_entity' is set
        if ('example_entity' not in local_var_params or
                local_var_params['example_entity'] is None):
            raise ApiValueError("Missing the required parameter `example_entity` when calling `add_example_to_minibatch`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model_history_server_id' in local_var_params:
            path_params['modelHistoryServerId'] = local_var_params['model_history_server_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'example_entity' in local_var_params:
            body_params = local_var_params['example_entity']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/rpc/{modelHistoryServerId}/model/example', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ExampleEntity',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_experiment(self, model_history_server_id, experiment_entity, **kwargs):  # noqa: E501
        """Add an experiment, given an experiment entity  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_experiment(model_history_server_id, experiment_entity, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str model_history_server_id: Process GUID of the model history server. Run `$SKIL_HOME/sbin/skil services` in a console to find out the model history server GUID. (required)
        :param ExperimentEntity experiment_entity: The experiment entity to add (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ExperimentEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.add_experiment_with_http_info(model_history_server_id, experiment_entity, **kwargs)  # noqa: E501

    def add_experiment_with_http_info(self, model_history_server_id, experiment_entity, **kwargs):  # noqa: E501
        """Add an experiment, given an experiment entity  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_experiment_with_http_info(model_history_server_id, experiment_entity, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str model_history_server_id: Process GUID of the model history server. Run `$SKIL_HOME/sbin/skil services` in a console to find out the model history server GUID. (required)
        :param ExperimentEntity experiment_entity: The experiment entity to add (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ExperimentEntity, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['model_history_server_id', 'experiment_entity']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_experiment" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'model_history_server_id' is set
        if ('model_history_server_id' not in local_var_params or
                local_var_params['model_history_server_id'] is None):
            raise ApiValueError("Missing the required parameter `model_history_server_id` when calling `add_experiment`")  # noqa: E501
        # verify the required parameter 'experiment_entity' is set
        if ('experiment_entity' not in local_var_params or
                local_var_params['experiment_entity'] is None):
            raise ApiValueError("Missing the required parameter `experiment_entity` when calling `add_experiment`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model_history_server_id' in local_var_params:
            path_params['modelHistoryServerId'] = local_var_params['model_history_server_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'experiment_entity' in local_var_params:
            body_params = local_var_params['experiment_entity']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/rpc/{modelHistoryServerId}/experiment', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ExperimentEntity',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_feedback_binary(self, id, type, **kwargs):  # noqa: E501
        """add_feedback_binary  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_feedback_binary(id, type, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str id: Batch ID to retrain the model with and get feedback for. (required)
        :param str type: The type of the labels array. (required)
        :param file file: The labels file to upload.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: FeedbackResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.add_feedback_binary_with_http_info(id, type, **kwargs)  # noqa: E501

    def add_feedback_binary_with_http_info(self, id, type, **kwargs):  # noqa: E501
        """add_feedback_binary  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_feedback_binary_with_http_info(id, type, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str id: Batch ID to retrain the model with and get feedback for. (required)
        :param str type: The type of the labels array. (required)
        :param file file: The labels file to upload.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(FeedbackResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id', 'type', 'file']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_feedback_binary" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in local_var_params or
                local_var_params['id'] is None):
            raise ApiValueError("Missing the required parameter `id` when calling `add_feedback_binary`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in local_var_params or
                local_var_params['type'] is None):
            raise ApiValueError("Missing the required parameter `type` when calling `add_feedback_binary`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'type' in local_var_params:
            path_params['type'] = local_var_params['type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'file' in local_var_params:
            local_var_files['file'] = local_var_params['file']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/feedback/{id}/{type}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FeedbackResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_feedback_json(self, id, **kwargs):  # noqa: E501
        """Gets the retraining feedback for the given batch ID.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_feedback_json(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str id: Batch ID to retrain the model with and get feedback for. (required)
        :param list[list[float]] labels: The associated labels (one-hot vectors) with the batch for retraining.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: FeedbackResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.add_feedback_json_with_http_info(id, **kwargs)  # noqa: E501

    def add_feedback_json_with_http_info(self, id, **kwargs):  # noqa: E501
        """Gets the retraining feedback for the given batch ID.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_feedback_json_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str id: Batch ID to retrain the model with and get feedback for. (required)
        :param list[list[float]] labels: The associated labels (one-hot vectors) with the batch for retraining.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(FeedbackResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id', 'labels']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_feedback_json" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in local_var_params or
                local_var_params['id'] is None):
            raise ApiValueError("Missing the required parameter `id` when calling `add_feedback_json`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'labels' in local_var_params:
            body_params = local_var_params['labels']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/feedback/{id}/json', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FeedbackResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_minibatch(self, model_history_server_id, minibatch_entity, **kwargs):  # noqa: E501
        """Adds a minibatch  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_minibatch(model_history_server_id, minibatch_entity, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str model_history_server_id: Process GUID of the model history server. Run `$SKIL_HOME/sbin/skil services` in a console to find out the model history server GUID. (required)
        :param MinibatchEntity minibatch_entity: The minibatch entity to add (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: MinibatchEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.add_minibatch_with_http_info(model_history_server_id, minibatch_entity, **kwargs)  # noqa: E501

    def add_minibatch_with_http_info(self, model_history_server_id, minibatch_entity, **kwargs):  # noqa: E501
        """Adds a minibatch  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_minibatch_with_http_info(model_history_server_id, minibatch_entity, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str model_history_server_id: Process GUID of the model history server. Run `$SKIL_HOME/sbin/skil services` in a console to find out the model history server GUID. (required)
        :param MinibatchEntity minibatch_entity: The minibatch entity to add (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(MinibatchEntity, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['model_history_server_id', 'minibatch_entity']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_minibatch" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'model_history_server_id' is set
        if ('model_history_server_id' not in local_var_params or
                local_var_params['model_history_server_id'] is None):
            raise ApiValueError("Missing the required parameter `model_history_server_id` when calling `add_minibatch`")  # noqa: E501
        # verify the required parameter 'minibatch_entity' is set
        if ('minibatch_entity' not in local_var_params or
                local_var_params['minibatch_entity'] is None):
            raise ApiValueError("Missing the required parameter `minibatch_entity` when calling `add_minibatch`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model_history_server_id' in local_var_params:
            path_params['modelHistoryServerId'] = local_var_params['model_history_server_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'minibatch_entity' in local_var_params:
            body_params = local_var_params['minibatch_entity']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/rpc/{modelHistoryServerId}/model/minibatch', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MinibatchEntity',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_model_feedback(self, model_history_server_id, model_feed_back_request, **kwargs):  # noqa: E501
        """Adds an evaluation feedback to the model against a given minibatch id.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_model_feedback(model_history_server_id, model_feed_back_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str model_history_server_id: Process GUID of the model history server. Run `$SKIL_HOME/sbin/skil services` in a console to find out the model history server GUID. (required)
        :param ModelFeedBackRequest model_feed_back_request: The model feedback request object (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ModelFeedBackRequest
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.add_model_feedback_with_http_info(model_history_server_id, model_feed_back_request, **kwargs)  # noqa: E501

    def add_model_feedback_with_http_info(self, model_history_server_id, model_feed_back_request, **kwargs):  # noqa: E501
        """Adds an evaluation feedback to the model against a given minibatch id.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_model_feedback_with_http_info(model_history_server_id, model_feed_back_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str model_history_server_id: Process GUID of the model history server. Run `$SKIL_HOME/sbin/skil services` in a console to find out the model history server GUID. (required)
        :param ModelFeedBackRequest model_feed_back_request: The model feedback request object (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ModelFeedBackRequest, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['model_history_server_id', 'model_feed_back_request']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_model_feedback" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'model_history_server_id' is set
        if ('model_history_server_id' not in local_var_params or
                local_var_params['model_history_server_id'] is None):
            raise ApiValueError("Missing the required parameter `model_history_server_id` when calling `add_model_feedback`")  # noqa: E501
        # verify the required parameter 'model_feed_back_request' is set
        if ('model_feed_back_request' not in local_var_params or
                local_var_params['model_feed_back_request'] is None):
            raise ApiValueError("Missing the required parameter `model_feed_back_request` when calling `add_model_feedback`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model_history_server_id' in local_var_params:
            path_params['modelHistoryServerId'] = local_var_params['model_history_server_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'model_feed_back_request' in local_var_params:
            body_params = local_var_params['model_feed_back_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/rpc/{modelHistoryServerId}/model/feedback', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ModelFeedBackRequest',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_model_history(self, model_history_server_id, add_model_history_request, **kwargs):  # noqa: E501
        """Add a model history / workspace  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_model_history(model_history_server_id, add_model_history_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str model_history_server_id: Process GUID of the model history server. Run `$SKIL_HOME/sbin/skil services` in a console to find out the model history server GUID. (required)
        :param AddModelHistoryRequest add_model_history_request: The model history request object (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ModelHistoryEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.add_model_history_with_http_info(model_history_server_id, add_model_history_request, **kwargs)  # noqa: E501

    def add_model_history_with_http_info(self, model_history_server_id, add_model_history_request, **kwargs):  # noqa: E501
        """Add a model history / workspace  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_model_history_with_http_info(model_history_server_id, add_model_history_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str model_history_server_id: Process GUID of the model history server. Run `$SKIL_HOME/sbin/skil services` in a console to find out the model history server GUID. (required)
        :param AddModelHistoryRequest add_model_history_request: The model history request object (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ModelHistoryEntity, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['model_history_server_id', 'add_model_history_request']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_model_history" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'model_history_server_id' is set
        if ('model_history_server_id' not in local_var_params or
                local_var_params['model_history_server_id'] is None):
            raise ApiValueError("Missing the required parameter `model_history_server_id` when calling `add_model_history`")  # noqa: E501
        # verify the required parameter 'add_model_history_request' is set
        if ('add_model_history_request' not in local_var_params or
                local_var_params['add_model_history_request'] is None):
            raise ApiValueError("Missing the required parameter `add_model_history_request` when calling `add_model_history`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model_history_server_id' in local_var_params:
            path_params['modelHistoryServerId'] = local_var_params['model_history_server_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'add_model_history_request' in local_var_params:
            body_params = local_var_params['add_model_history_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/rpc/{modelHistoryServerId}/modelhistory', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ModelHistoryEntity',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_model_instance(self, model_history_server_id, model_instance_entity, **kwargs):  # noqa: E501
        """Adds a model  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_model_instance(model_history_server_id, model_instance_entity, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str model_history_server_id: Process GUID of the model history server. Run `$SKIL_HOME/sbin/skil services` in a console to find out the model history server GUID. (required)
        :param ModelInstanceEntity model_instance_entity: The object encapsulating the model instance id and evaluation type to aggregate (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ModelInstanceEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.add_model_instance_with_http_info(model_history_server_id, model_instance_entity, **kwargs)  # noqa: E501

    def add_model_instance_with_http_info(self, model_history_server_id, model_instance_entity, **kwargs):  # noqa: E501
        """Adds a model  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_model_instance_with_http_info(model_history_server_id, model_instance_entity, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str model_history_server_id: Process GUID of the model history server. Run `$SKIL_HOME/sbin/skil services` in a console to find out the model history server GUID. (required)
        :param ModelInstanceEntity model_instance_entity: The object encapsulating the model instance id and evaluation type to aggregate (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ModelInstanceEntity, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['model_history_server_id', 'model_instance_entity']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_model_instance" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'model_history_server_id' is set
        if ('model_history_server_id' not in local_var_params or
                local_var_params['model_history_server_id'] is None):
            raise ApiValueError("Missing the required parameter `model_history_server_id` when calling `add_model_instance`")  # noqa: E501
        # verify the required parameter 'model_instance_entity' is set
        if ('model_instance_entity' not in local_var_params or
                local_var_params['model_instance_entity'] is None):
            raise ApiValueError("Missing the required parameter `model_instance_entity` when calling `add_model_instance`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model_history_server_id' in local_var_params:
            path_params['modelHistoryServerId'] = local_var_params['model_history_server_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'model_instance_entity' in local_var_params:
            body_params = local_var_params['model_instance_entity']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/rpc/{modelHistoryServerId}/model', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ModelInstanceEntity',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_resource(self, add_resource_request, **kwargs):  # noqa: E501
        """Adds a resource  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_resource(add_resource_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param AddResourceRequest add_resource_request: The Add resource request object (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.add_resource_with_http_info(add_resource_request, **kwargs)  # noqa: E501

    def add_resource_with_http_info(self, add_resource_request, **kwargs):  # noqa: E501
        """Adds a resource  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_resource_with_http_info(add_resource_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param AddResourceRequest add_resource_request: The Add resource request object (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['add_resource_request']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_resource" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'add_resource_request' is set
        if ('add_resource_request' not in local_var_params or
                local_var_params['add_resource_request'] is None):
            raise ApiValueError("Missing the required parameter `add_resource_request` when calling `add_resource`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'add_resource_request' in local_var_params:
            body_params = local_var_params['add_resource_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/resources/add/resource', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_resource_group(self, group_name, **kwargs):  # noqa: E501
        """Adds a resource group  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_resource_group(group_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str group_name: Name of the resource group (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ResourceGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.add_resource_group_with_http_info(group_name, **kwargs)  # noqa: E501

    def add_resource_group_with_http_info(self, group_name, **kwargs):  # noqa: E501
        """Adds a resource group  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_resource_group_with_http_info(group_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str group_name: Name of the resource group (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ResourceGroup, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['group_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_resource_group" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'group_name' is set
        if ('group_name' not in local_var_params or
                local_var_params['group_name'] is None):
            raise ApiValueError("Missing the required parameter `group_name` when calling `add_resource_group`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'group_name' in local_var_params:
            body_params = local_var_params['group_name']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['text/plain; charset=utf-8'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/resources/add/group', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ResourceGroup',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_resource_to_group(self, resource_group_id, resource_id, **kwargs):  # noqa: E501
        """Adds a resource to a resource group  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_resource_to_group(resource_group_id, resource_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int resource_group_id: ID of the resource group (required)
        :param int resource_id: ID of the resource (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.add_resource_to_group_with_http_info(resource_group_id, resource_id, **kwargs)  # noqa: E501

    def add_resource_to_group_with_http_info(self, resource_group_id, resource_id, **kwargs):  # noqa: E501
        """Adds a resource to a resource group  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_resource_to_group_with_http_info(resource_group_id, resource_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int resource_group_id: ID of the resource group (required)
        :param int resource_id: ID of the resource (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['resource_group_id', 'resource_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_resource_to_group" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'resource_group_id' is set
        if ('resource_group_id' not in local_var_params or
                local_var_params['resource_group_id'] is None):
            raise ApiValueError("Missing the required parameter `resource_group_id` when calling `add_resource_to_group`")  # noqa: E501
        # verify the required parameter 'resource_id' is set
        if ('resource_id' not in local_var_params or
                local_var_params['resource_id'] is None):
            raise ApiValueError("Missing the required parameter `resource_id` when calling `add_resource_to_group`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'resource_group_id' in local_var_params:
            path_params['resourceGroupId'] = local_var_params['resource_group_id']  # noqa: E501
        if 'resource_id' in local_var_params:
            path_params['resourceId'] = local_var_params['resource_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/resources/add/resourcetogroup/{resourceGroupId}/{resourceId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def aggregate_model_results(self, model_history_server_id, aggregate_prediction, **kwargs):  # noqa: E501
        """Aggregates the evaluaition results of a model instance, based on the evaluation type  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.aggregate_model_results(model_history_server_id, aggregate_prediction, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str model_history_server_id: Process GUID of the model history server. Run `$SKIL_HOME/sbin/skil services` in a console to find out the model history server GUID. (required)
        :param AggregatePrediction aggregate_prediction: The object encapsulating the model instance id and evaluation type to aggregate (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: EvaluationResultsEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.aggregate_model_results_with_http_info(model_history_server_id, aggregate_prediction, **kwargs)  # noqa: E501

    def aggregate_model_results_with_http_info(self, model_history_server_id, aggregate_prediction, **kwargs):  # noqa: E501
        """Aggregates the evaluaition results of a model instance, based on the evaluation type  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.aggregate_model_results_with_http_info(model_history_server_id, aggregate_prediction, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str model_history_server_id: Process GUID of the model history server. Run `$SKIL_HOME/sbin/skil services` in a console to find out the model history server GUID. (required)
        :param AggregatePrediction aggregate_prediction: The object encapsulating the model instance id and evaluation type to aggregate (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(EvaluationResultsEntity, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['model_history_server_id', 'aggregate_prediction']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method aggregate_model_results" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'model_history_server_id' is set
        if ('model_history_server_id' not in local_var_params or
                local_var_params['model_history_server_id'] is None):
            raise ApiValueError("Missing the required parameter `model_history_server_id` when calling `aggregate_model_results`")  # noqa: E501
        # verify the required parameter 'aggregate_prediction' is set
        if ('aggregate_prediction' not in local_var_params or
                local_var_params['aggregate_prediction'] is None):
            raise ApiValueError("Missing the required parameter `aggregate_prediction` when calling `aggregate_model_results`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model_history_server_id' in local_var_params:
            path_params['modelHistoryServerId'] = local_var_params['model_history_server_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'aggregate_prediction' in local_var_params:
            body_params = local_var_params['aggregate_prediction']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/rpc/{modelHistoryServerId}/model/aggregateresults', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EvaluationResultsEntity',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def change_user_password(self, user_id, change_password_request, **kwargs):  # noqa: E501
        """Change user's password  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.change_user_password(user_id, change_password_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str user_id: User's ID (required)
        :param ChangePasswordRequest change_password_request: Password details. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: User
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.change_user_password_with_http_info(user_id, change_password_request, **kwargs)  # noqa: E501

    def change_user_password_with_http_info(self, user_id, change_password_request, **kwargs):  # noqa: E501
        """Change user's password  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.change_user_password_with_http_info(user_id, change_password_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str user_id: User's ID (required)
        :param ChangePasswordRequest change_password_request: Password details. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(User, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['user_id', 'change_password_request']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method change_user_password" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in local_var_params or
                local_var_params['user_id'] is None):
            raise ApiValueError("Missing the required parameter `user_id` when calling `change_user_password`")  # noqa: E501
        # verify the required parameter 'change_password_request' is set
        if ('change_password_request' not in local_var_params or
                local_var_params['change_password_request'] is None):
            raise ApiValueError("Missing the required parameter `change_password_request` when calling `change_user_password`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in local_var_params:
            path_params['userId'] = local_var_params['user_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'change_password_request' in local_var_params:
            body_params = local_var_params['change_password_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/user/{userId}/password', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='User',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def classify(self, deployment_name, version_name, model_name, body, **kwargs):  # noqa: E501
        """Use the deployed model to classify the input  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.classify(deployment_name, version_name, model_name, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str model_name: ID or name of the deployed model (required)
        :param Prediction body: The input NDArray (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ClassificationResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.classify_with_http_info(deployment_name, version_name, model_name, body, **kwargs)  # noqa: E501

    def classify_with_http_info(self, deployment_name, version_name, model_name, body, **kwargs):  # noqa: E501
        """Use the deployed model to classify the input  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.classify_with_http_info(deployment_name, version_name, model_name, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str model_name: ID or name of the deployed model (required)
        :param Prediction body: The input NDArray (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ClassificationResult, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['deployment_name', 'version_name', 'model_name', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method classify" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'deployment_name' is set
        if ('deployment_name' not in local_var_params or
                local_var_params['deployment_name'] is None):
            raise ApiValueError("Missing the required parameter `deployment_name` when calling `classify`")  # noqa: E501
        # verify the required parameter 'version_name' is set
        if ('version_name' not in local_var_params or
                local_var_params['version_name'] is None):
            raise ApiValueError("Missing the required parameter `version_name` when calling `classify`")  # noqa: E501
        # verify the required parameter 'model_name' is set
        if ('model_name' not in local_var_params or
                local_var_params['model_name'] is None):
            raise ApiValueError("Missing the required parameter `model_name` when calling `classify`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in local_var_params or
                local_var_params['body'] is None):
            raise ApiValueError("Missing the required parameter `body` when calling `classify`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'deployment_name' in local_var_params:
            path_params['deploymentName'] = local_var_params['deployment_name']  # noqa: E501
        if 'version_name' in local_var_params:
            path_params['versionName'] = local_var_params['version_name']  # noqa: E501
        if 'model_name' in local_var_params:
            path_params['modelName'] = local_var_params['model_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/endpoints/{deploymentName}/model/{modelName}/{versionName}/classify', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ClassificationResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def classifyarray(self, deployment_name, version_name, model_name, body, **kwargs):  # noqa: E501
        """Same as /classify but returns the output as Base64NDArrayBody  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.classifyarray(deployment_name, version_name, model_name, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str model_name: ID or name of the deployed model (required)
        :param Prediction body: The input NDArray (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Base64NDArrayBody
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.classifyarray_with_http_info(deployment_name, version_name, model_name, body, **kwargs)  # noqa: E501

    def classifyarray_with_http_info(self, deployment_name, version_name, model_name, body, **kwargs):  # noqa: E501
        """Same as /classify but returns the output as Base64NDArrayBody  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.classifyarray_with_http_info(deployment_name, version_name, model_name, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str model_name: ID or name of the deployed model (required)
        :param Prediction body: The input NDArray (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Base64NDArrayBody, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['deployment_name', 'version_name', 'model_name', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method classifyarray" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'deployment_name' is set
        if ('deployment_name' not in local_var_params or
                local_var_params['deployment_name'] is None):
            raise ApiValueError("Missing the required parameter `deployment_name` when calling `classifyarray`")  # noqa: E501
        # verify the required parameter 'version_name' is set
        if ('version_name' not in local_var_params or
                local_var_params['version_name'] is None):
            raise ApiValueError("Missing the required parameter `version_name` when calling `classifyarray`")  # noqa: E501
        # verify the required parameter 'model_name' is set
        if ('model_name' not in local_var_params or
                local_var_params['model_name'] is None):
            raise ApiValueError("Missing the required parameter `model_name` when calling `classifyarray`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in local_var_params or
                local_var_params['body'] is None):
            raise ApiValueError("Missing the required parameter `body` when calling `classifyarray`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'deployment_name' in local_var_params:
            path_params['deploymentName'] = local_var_params['deployment_name']  # noqa: E501
        if 'version_name' in local_var_params:
            path_params['versionName'] = local_var_params['version_name']  # noqa: E501
        if 'model_name' in local_var_params:
            path_params['modelName'] = local_var_params['model_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/endpoints/{deploymentName}/model/{modelName}/{versionName}/classifyarray', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Base64NDArrayBody',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def classifyimage(self, deployment_name, version_name, model_name, **kwargs):  # noqa: E501
        """Use the deployed model to classify the input, using input image file from multipart form data.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.classifyimage(deployment_name, version_name, model_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str model_name: ID or name of the deployed model (required)
        :param file image: The file to upload.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ClassificationResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.classifyimage_with_http_info(deployment_name, version_name, model_name, **kwargs)  # noqa: E501

    def classifyimage_with_http_info(self, deployment_name, version_name, model_name, **kwargs):  # noqa: E501
        """Use the deployed model to classify the input, using input image file from multipart form data.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.classifyimage_with_http_info(deployment_name, version_name, model_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str model_name: ID or name of the deployed model (required)
        :param file image: The file to upload.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ClassificationResult, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['deployment_name', 'version_name', 'model_name', 'image']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method classifyimage" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'deployment_name' is set
        if ('deployment_name' not in local_var_params or
                local_var_params['deployment_name'] is None):
            raise ApiValueError("Missing the required parameter `deployment_name` when calling `classifyimage`")  # noqa: E501
        # verify the required parameter 'version_name' is set
        if ('version_name' not in local_var_params or
                local_var_params['version_name'] is None):
            raise ApiValueError("Missing the required parameter `version_name` when calling `classifyimage`")  # noqa: E501
        # verify the required parameter 'model_name' is set
        if ('model_name' not in local_var_params or
                local_var_params['model_name'] is None):
            raise ApiValueError("Missing the required parameter `model_name` when calling `classifyimage`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'deployment_name' in local_var_params:
            path_params['deploymentName'] = local_var_params['deployment_name']  # noqa: E501
        if 'version_name' in local_var_params:
            path_params['versionName'] = local_var_params['version_name']  # noqa: E501
        if 'model_name' in local_var_params:
            path_params['modelName'] = local_var_params['model_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'image' in local_var_params:
            local_var_files['image'] = local_var_params['image']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/endpoints/{deploymentName}/model/{modelName}/{versionName}/classifyimage', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ClassificationResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def clear_state(self, **kwargs):  # noqa: E501
        """Clears the accumulated data for retraining.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.clear_state(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: FeedbackResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.clear_state_with_http_info(**kwargs)  # noqa: E501

    def clear_state_with_http_info(self, **kwargs):  # noqa: E501
        """Clears the accumulated data for retraining.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.clear_state_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(FeedbackResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method clear_state" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/clear', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FeedbackResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_job(self, job_id_or_type, create_job_request, **kwargs):  # noqa: E501
        """Create a job  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_job(job_id_or_type, create_job_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str job_id_or_type: Job Type (required)
        :param CreateJobRequest create_job_request: Create job request object (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: JobEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_job_with_http_info(job_id_or_type, create_job_request, **kwargs)  # noqa: E501

    def create_job_with_http_info(self, job_id_or_type, create_job_request, **kwargs):  # noqa: E501
        """Create a job  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_job_with_http_info(job_id_or_type, create_job_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str job_id_or_type: Job Type (required)
        :param CreateJobRequest create_job_request: Create job request object (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(JobEntity, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['job_id_or_type', 'create_job_request']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_job" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'job_id_or_type' is set
        if ('job_id_or_type' not in local_var_params or
                local_var_params['job_id_or_type'] is None):
            raise ApiValueError("Missing the required parameter `job_id_or_type` when calling `create_job`")  # noqa: E501
        # verify the required parameter 'create_job_request' is set
        if ('create_job_request' not in local_var_params or
                local_var_params['create_job_request'] is None):
            raise ApiValueError("Missing the required parameter `create_job_request` when calling `create_job`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'job_id_or_type' in local_var_params:
            path_params['jobIdOrType'] = local_var_params['job_id_or_type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'create_job_request' in local_var_params:
            body_params = local_var_params['create_job_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/jobs/{jobIdOrType}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='JobEntity',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_model_history(self, model_history_server_id, model_history_entity, **kwargs):  # noqa: E501
        """Creates model History  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_model_history(model_history_server_id, model_history_entity, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str model_history_server_id: Process GUID of the model history server. Run `$SKIL_HOME/sbin/skil services` in a console to find out the model history server GUID. (required)
        :param ModelHistoryEntity model_history_entity: The model history entity (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ModelHistoryEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_model_history_with_http_info(model_history_server_id, model_history_entity, **kwargs)  # noqa: E501

    def create_model_history_with_http_info(self, model_history_server_id, model_history_entity, **kwargs):  # noqa: E501
        """Creates model History  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_model_history_with_http_info(model_history_server_id, model_history_entity, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str model_history_server_id: Process GUID of the model history server. Run `$SKIL_HOME/sbin/skil services` in a console to find out the model history server GUID. (required)
        :param ModelHistoryEntity model_history_entity: The model history entity (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ModelHistoryEntity, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['model_history_server_id', 'model_history_entity']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_model_history" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'model_history_server_id' is set
        if ('model_history_server_id' not in local_var_params or
                local_var_params['model_history_server_id'] is None):
            raise ApiValueError("Missing the required parameter `model_history_server_id` when calling `create_model_history`")  # noqa: E501
        # verify the required parameter 'model_history_entity' is set
        if ('model_history_entity' not in local_var_params or
                local_var_params['model_history_entity'] is None):
            raise ApiValueError("Missing the required parameter `model_history_entity` when calling `create_model_history`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model_history_server_id' in local_var_params:
            path_params['modelHistoryServerId'] = local_var_params['model_history_server_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'model_history_entity' in local_var_params:
            body_params = local_var_params['model_history_entity']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/rpc/{modelHistoryServerId}/model/revisions', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ModelHistoryEntity',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_credentials_by_id(self, credential_id, **kwargs):  # noqa: E501
        """Delete credentials given an ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_credentials_by_id(credential_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int credential_id: Credentials ID (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_credentials_by_id_with_http_info(credential_id, **kwargs)  # noqa: E501

    def delete_credentials_by_id_with_http_info(self, credential_id, **kwargs):  # noqa: E501
        """Delete credentials given an ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_credentials_by_id_with_http_info(credential_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int credential_id: Credentials ID (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['credential_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_credentials_by_id" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'credential_id' is set
        if ('credential_id' not in local_var_params or
                local_var_params['credential_id'] is None):
            raise ApiValueError("Missing the required parameter `credential_id` when calling `delete_credentials_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'credential_id' in local_var_params:
            path_params['credentialId'] = local_var_params['credential_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/resources/credentials/{credentialId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_experiment(self, model_history_server_id, experiment_id, **kwargs):  # noqa: E501
        """Deletes an experiment, given an experiment entity  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_experiment(model_history_server_id, experiment_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str model_history_server_id: Process GUID of the model history server. Run `$SKIL_HOME/sbin/skil services` in a console to find out the model history server GUID. (required)
        :param str experiment_id: the GUID of the experiment to delete (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse200
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_experiment_with_http_info(model_history_server_id, experiment_id, **kwargs)  # noqa: E501

    def delete_experiment_with_http_info(self, model_history_server_id, experiment_id, **kwargs):  # noqa: E501
        """Deletes an experiment, given an experiment entity  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_experiment_with_http_info(model_history_server_id, experiment_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str model_history_server_id: Process GUID of the model history server. Run `$SKIL_HOME/sbin/skil services` in a console to find out the model history server GUID. (required)
        :param str experiment_id: the GUID of the experiment to delete (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse200, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['model_history_server_id', 'experiment_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_experiment" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'model_history_server_id' is set
        if ('model_history_server_id' not in local_var_params or
                local_var_params['model_history_server_id'] is None):
            raise ApiValueError("Missing the required parameter `model_history_server_id` when calling `delete_experiment`")  # noqa: E501
        # verify the required parameter 'experiment_id' is set
        if ('experiment_id' not in local_var_params or
                local_var_params['experiment_id'] is None):
            raise ApiValueError("Missing the required parameter `experiment_id` when calling `delete_experiment`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model_history_server_id' in local_var_params:
            path_params['modelHistoryServerId'] = local_var_params['model_history_server_id']  # noqa: E501
        if 'experiment_id' in local_var_params:
            path_params['experimentID'] = local_var_params['experiment_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/rpc/{modelHistoryServerId}/experiment/{experimentID}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_job_by_id(self, job_id_or_type, **kwargs):  # noqa: E501
        """Deletes a job given its ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_job_by_id(job_id_or_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int job_id_or_type: Job ID (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_job_by_id_with_http_info(job_id_or_type, **kwargs)  # noqa: E501

    def delete_job_by_id_with_http_info(self, job_id_or_type, **kwargs):  # noqa: E501
        """Deletes a job given its ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_job_by_id_with_http_info(job_id_or_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int job_id_or_type: Job ID (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['job_id_or_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_job_by_id" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'job_id_or_type' is set
        if ('job_id_or_type' not in local_var_params or
                local_var_params['job_id_or_type'] is None):
            raise ApiValueError("Missing the required parameter `job_id_or_type` when calling `delete_job_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'job_id_or_type' in local_var_params:
            path_params['jobIdOrType'] = local_var_params['job_id_or_type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/jobs/{jobIdOrType}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_model(self, deployment_id, model_id, **kwargs):  # noqa: E501
        """Delete a model by deployment and model id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_model(deployment_id, model_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str deployment_id: ID deployment group (required)
        :param str model_id: the id of the deployed model (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse200
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_model_with_http_info(deployment_id, model_id, **kwargs)  # noqa: E501

    def delete_model_with_http_info(self, deployment_id, model_id, **kwargs):  # noqa: E501
        """Delete a model by deployment and model id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_model_with_http_info(deployment_id, model_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str deployment_id: ID deployment group (required)
        :param str model_id: the id of the deployed model (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse200, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['deployment_id', 'model_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_model" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'deployment_id' is set
        if ('deployment_id' not in local_var_params or
                local_var_params['deployment_id'] is None):
            raise ApiValueError("Missing the required parameter `deployment_id` when calling `delete_model`")  # noqa: E501
        # verify the required parameter 'model_id' is set
        if ('model_id' not in local_var_params or
                local_var_params['model_id'] is None):
            raise ApiValueError("Missing the required parameter `model_id` when calling `delete_model`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'deployment_id' in local_var_params:
            path_params['deploymentId'] = local_var_params['deployment_id']  # noqa: E501
        if 'model_id' in local_var_params:
            path_params['modelId'] = local_var_params['model_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/deployment/{deploymentId}/model/{modelId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_model_history(self, model_history_server_id, model_history_id, **kwargs):  # noqa: E501
        """Deletes a model history / workspace, given its ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_model_history(model_history_server_id, model_history_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str model_history_server_id: Process GUID of the model history server. Run `$SKIL_HOME/sbin/skil services` in a console to find out the model history server GUID. (required)
        :param str model_history_id: the GUID of the model history / workspace to delete (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse200
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_model_history_with_http_info(model_history_server_id, model_history_id, **kwargs)  # noqa: E501

    def delete_model_history_with_http_info(self, model_history_server_id, model_history_id, **kwargs):  # noqa: E501
        """Deletes a model history / workspace, given its ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_model_history_with_http_info(model_history_server_id, model_history_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str model_history_server_id: Process GUID of the model history server. Run `$SKIL_HOME/sbin/skil services` in a console to find out the model history server GUID. (required)
        :param str model_history_id: the GUID of the model history / workspace to delete (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse200, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['model_history_server_id', 'model_history_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_model_history" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'model_history_server_id' is set
        if ('model_history_server_id' not in local_var_params or
                local_var_params['model_history_server_id'] is None):
            raise ApiValueError("Missing the required parameter `model_history_server_id` when calling `delete_model_history`")  # noqa: E501
        # verify the required parameter 'model_history_id' is set
        if ('model_history_id' not in local_var_params or
                local_var_params['model_history_id'] is None):
            raise ApiValueError("Missing the required parameter `model_history_id` when calling `delete_model_history`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model_history_server_id' in local_var_params:
            path_params['modelHistoryServerId'] = local_var_params['model_history_server_id']  # noqa: E501
        if 'model_history_id' in local_var_params:
            path_params['modelHistoryID'] = local_var_params['model_history_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/rpc/{modelHistoryServerId}/modelhistory/{modelHistoryID}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_model_instance(self, model_history_server_id, model_instance_id, **kwargs):  # noqa: E501
        """Deletes a model instance, given its ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_model_instance(model_history_server_id, model_instance_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str model_history_server_id: Process GUID of the model history server. Run `$SKIL_HOME/sbin/skil services` in a console to find out the model history server GUID. (required)
        :param str model_instance_id: GUID of the model instance to delete. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_model_instance_with_http_info(model_history_server_id, model_instance_id, **kwargs)  # noqa: E501

    def delete_model_instance_with_http_info(self, model_history_server_id, model_instance_id, **kwargs):  # noqa: E501
        """Deletes a model instance, given its ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_model_instance_with_http_info(model_history_server_id, model_instance_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str model_history_server_id: Process GUID of the model history server. Run `$SKIL_HOME/sbin/skil services` in a console to find out the model history server GUID. (required)
        :param str model_instance_id: GUID of the model instance to delete. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['model_history_server_id', 'model_instance_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_model_instance" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'model_history_server_id' is set
        if ('model_history_server_id' not in local_var_params or
                local_var_params['model_history_server_id'] is None):
            raise ApiValueError("Missing the required parameter `model_history_server_id` when calling `delete_model_instance`")  # noqa: E501
        # verify the required parameter 'model_instance_id' is set
        if ('model_instance_id' not in local_var_params or
                local_var_params['model_instance_id'] is None):
            raise ApiValueError("Missing the required parameter `model_instance_id` when calling `delete_model_instance`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model_history_server_id' in local_var_params:
            path_params['modelHistoryServerId'] = local_var_params['model_history_server_id']  # noqa: E501
        if 'model_instance_id' in local_var_params:
            path_params['modelInstanceID'] = local_var_params['model_instance_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/rpc/{modelHistoryServerId}/model/{modelInstanceID}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_resource_by_id(self, resource_id, **kwargs):  # noqa: E501
        """Delete the resource with the specified resource ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_resource_by_id(resource_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int resource_id: ID of the resource (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Resource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_resource_by_id_with_http_info(resource_id, **kwargs)  # noqa: E501

    def delete_resource_by_id_with_http_info(self, resource_id, **kwargs):  # noqa: E501
        """Delete the resource with the specified resource ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_resource_by_id_with_http_info(resource_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int resource_id: ID of the resource (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Resource, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['resource_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_resource_by_id" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'resource_id' is set
        if ('resource_id' not in local_var_params or
                local_var_params['resource_id'] is None):
            raise ApiValueError("Missing the required parameter `resource_id` when calling `delete_resource_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'resource_id' in local_var_params:
            path_params['resourceId'] = local_var_params['resource_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/resources/remove/resource/{resourceId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Resource',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_resource_from_group(self, resource_group_id, resource_id, **kwargs):  # noqa: E501
        """Removes a resource from a resource group  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_resource_from_group(resource_group_id, resource_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int resource_group_id: ID of the resource group (required)
        :param int resource_id: ID of the resource (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_resource_from_group_with_http_info(resource_group_id, resource_id, **kwargs)  # noqa: E501

    def delete_resource_from_group_with_http_info(self, resource_group_id, resource_id, **kwargs):  # noqa: E501
        """Removes a resource from a resource group  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_resource_from_group_with_http_info(resource_group_id, resource_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int resource_group_id: ID of the resource group (required)
        :param int resource_id: ID of the resource (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['resource_group_id', 'resource_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_resource_from_group" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'resource_group_id' is set
        if ('resource_group_id' not in local_var_params or
                local_var_params['resource_group_id'] is None):
            raise ApiValueError("Missing the required parameter `resource_group_id` when calling `delete_resource_from_group`")  # noqa: E501
        # verify the required parameter 'resource_id' is set
        if ('resource_id' not in local_var_params or
                local_var_params['resource_id'] is None):
            raise ApiValueError("Missing the required parameter `resource_id` when calling `delete_resource_from_group`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'resource_group_id' in local_var_params:
            path_params['resourceGroupId'] = local_var_params['resource_group_id']  # noqa: E501
        if 'resource_id' in local_var_params:
            path_params['resourceId'] = local_var_params['resource_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/resources/remove/resourcefromgroup/{resourceGroupId}/{resourceId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_resource_group_by_id(self, resource_group_id, **kwargs):  # noqa: E501
        """Delete the resource group with the specified resource group ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_resource_group_by_id(resource_group_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int resource_group_id: ID of the resource group (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ResourceGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_resource_group_by_id_with_http_info(resource_group_id, **kwargs)  # noqa: E501

    def delete_resource_group_by_id_with_http_info(self, resource_group_id, **kwargs):  # noqa: E501
        """Delete the resource group with the specified resource group ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_resource_group_by_id_with_http_info(resource_group_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int resource_group_id: ID of the resource group (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ResourceGroup, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['resource_group_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_resource_group_by_id" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'resource_group_id' is set
        if ('resource_group_id' not in local_var_params or
                local_var_params['resource_group_id'] is None):
            raise ApiValueError("Missing the required parameter `resource_group_id` when calling `delete_resource_group_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'resource_group_id' in local_var_params:
            path_params['resourceGroupId'] = local_var_params['resource_group_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/resources/remove/group/{resourceGroupId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ResourceGroup',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def deploy_model(self, deployment_id, body, **kwargs):  # noqa: E501
        """Deploy a model in a deployment group.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.deploy_model(deployment_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str deployment_id: ID deployment group (required)
        :param ImportModelRequest body: the model import request (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ModelEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.deploy_model_with_http_info(deployment_id, body, **kwargs)  # noqa: E501

    def deploy_model_with_http_info(self, deployment_id, body, **kwargs):  # noqa: E501
        """Deploy a model in a deployment group.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.deploy_model_with_http_info(deployment_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str deployment_id: ID deployment group (required)
        :param ImportModelRequest body: the model import request (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ModelEntity, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['deployment_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method deploy_model" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'deployment_id' is set
        if ('deployment_id' not in local_var_params or
                local_var_params['deployment_id'] is None):
            raise ApiValueError("Missing the required parameter `deployment_id` when calling `deploy_model`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in local_var_params or
                local_var_params['body'] is None):
            raise ApiValueError("Missing the required parameter `body` when calling `deploy_model`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'deployment_id' in local_var_params:
            path_params['deploymentId'] = local_var_params['deployment_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/deployment/{deploymentId}/model', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ModelEntity',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def deployment_create(self, body, **kwargs):  # noqa: E501
        """Create a new deployment group.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.deployment_create(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CreateDeploymentRequest body: the deployment request (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DeploymentResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.deployment_create_with_http_info(body, **kwargs)  # noqa: E501

    def deployment_create_with_http_info(self, body, **kwargs):  # noqa: E501
        """Create a new deployment group.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.deployment_create_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CreateDeploymentRequest body: the deployment request (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DeploymentResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method deployment_create" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in local_var_params or
                local_var_params['body'] is None):
            raise ApiValueError("Missing the required parameter `body` when calling `deployment_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/deployment', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DeploymentResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def deployment_delete(self, deployment_id, **kwargs):  # noqa: E501
        """Delete a deployment by id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.deployment_delete(deployment_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str deployment_id: Id of the deployment group (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse200
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.deployment_delete_with_http_info(deployment_id, **kwargs)  # noqa: E501

    def deployment_delete_with_http_info(self, deployment_id, **kwargs):  # noqa: E501
        """Delete a deployment by id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.deployment_delete_with_http_info(deployment_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str deployment_id: Id of the deployment group (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse200, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['deployment_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method deployment_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'deployment_id' is set
        if ('deployment_id' not in local_var_params or
                local_var_params['deployment_id'] is None):
            raise ApiValueError("Missing the required parameter `deployment_id` when calling `deployment_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'deployment_id' in local_var_params:
            path_params['deploymentId'] = local_var_params['deployment_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/deployment/{deploymentId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def deployment_get(self, deployment_id, **kwargs):  # noqa: E501
        """Get a deployment details by id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.deployment_get(deployment_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str deployment_id: Id of the deployment group (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DeploymentResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.deployment_get_with_http_info(deployment_id, **kwargs)  # noqa: E501

    def deployment_get_with_http_info(self, deployment_id, **kwargs):  # noqa: E501
        """Get a deployment details by id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.deployment_get_with_http_info(deployment_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str deployment_id: Id of the deployment group (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DeploymentResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['deployment_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method deployment_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'deployment_id' is set
        if ('deployment_id' not in local_var_params or
                local_var_params['deployment_id'] is None):
            raise ApiValueError("Missing the required parameter `deployment_id` when calling `deployment_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'deployment_id' in local_var_params:
            path_params['deploymentId'] = local_var_params['deployment_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/deployment/{deploymentId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DeploymentResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def deployments(self, **kwargs):  # noqa: E501
        """Get a list of deployments  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.deployments(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: list[DeploymentResponse]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.deployments_with_http_info(**kwargs)  # noqa: E501

    def deployments_with_http_info(self, **kwargs):  # noqa: E501
        """Get a list of deployments  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.deployments_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(list[DeploymentResponse], status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method deployments" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/deployments', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[DeploymentResponse]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def detectobjects(self, deployment_name, version_name, model_name, id, needs_preprocessing, threshold, file, **kwargs):  # noqa: E501
        """Detect the objects, given a (input) prediction request  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.detectobjects(deployment_name, version_name, model_name, id, needs_preprocessing, threshold, file, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str model_name: ID or name of the deployed model (required)
        :param str id: the GUID for mapping the results in the detections (required)
        :param bool needs_preprocessing: (true) if the image needs preprocessing (required)
        :param float threshold: A threshold, indicating the required surety for detecting a bounding box. For example, a threshold of 0.1 might give thousand bounding boxes for an image and a threshold of 0.99 might give none. (required)
        :param file file: the image file to detect objects from (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DetectionResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.detectobjects_with_http_info(deployment_name, version_name, model_name, id, needs_preprocessing, threshold, file, **kwargs)  # noqa: E501

    def detectobjects_with_http_info(self, deployment_name, version_name, model_name, id, needs_preprocessing, threshold, file, **kwargs):  # noqa: E501
        """Detect the objects, given a (input) prediction request  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.detectobjects_with_http_info(deployment_name, version_name, model_name, id, needs_preprocessing, threshold, file, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str model_name: ID or name of the deployed model (required)
        :param str id: the GUID for mapping the results in the detections (required)
        :param bool needs_preprocessing: (true) if the image needs preprocessing (required)
        :param float threshold: A threshold, indicating the required surety for detecting a bounding box. For example, a threshold of 0.1 might give thousand bounding boxes for an image and a threshold of 0.99 might give none. (required)
        :param file file: the image file to detect objects from (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DetectionResult, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['deployment_name', 'version_name', 'model_name', 'id', 'needs_preprocessing', 'threshold', 'file']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method detectobjects" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'deployment_name' is set
        if ('deployment_name' not in local_var_params or
                local_var_params['deployment_name'] is None):
            raise ApiValueError("Missing the required parameter `deployment_name` when calling `detectobjects`")  # noqa: E501
        # verify the required parameter 'version_name' is set
        if ('version_name' not in local_var_params or
                local_var_params['version_name'] is None):
            raise ApiValueError("Missing the required parameter `version_name` when calling `detectobjects`")  # noqa: E501
        # verify the required parameter 'model_name' is set
        if ('model_name' not in local_var_params or
                local_var_params['model_name'] is None):
            raise ApiValueError("Missing the required parameter `model_name` when calling `detectobjects`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in local_var_params or
                local_var_params['id'] is None):
            raise ApiValueError("Missing the required parameter `id` when calling `detectobjects`")  # noqa: E501
        # verify the required parameter 'needs_preprocessing' is set
        if ('needs_preprocessing' not in local_var_params or
                local_var_params['needs_preprocessing'] is None):
            raise ApiValueError("Missing the required parameter `needs_preprocessing` when calling `detectobjects`")  # noqa: E501
        # verify the required parameter 'threshold' is set
        if ('threshold' not in local_var_params or
                local_var_params['threshold'] is None):
            raise ApiValueError("Missing the required parameter `threshold` when calling `detectobjects`")  # noqa: E501
        # verify the required parameter 'file' is set
        if ('file' not in local_var_params or
                local_var_params['file'] is None):
            raise ApiValueError("Missing the required parameter `file` when calling `detectobjects`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'deployment_name' in local_var_params:
            path_params['deploymentName'] = local_var_params['deployment_name']  # noqa: E501
        if 'version_name' in local_var_params:
            path_params['versionName'] = local_var_params['version_name']  # noqa: E501
        if 'model_name' in local_var_params:
            path_params['modelName'] = local_var_params['model_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'id' in local_var_params:
            form_params.append(('id', local_var_params['id']))  # noqa: E501
        if 'needs_preprocessing' in local_var_params:
            form_params.append(('needsPreprocessing', local_var_params['needs_preprocessing']))  # noqa: E501
        if 'threshold' in local_var_params:
            form_params.append(('threshold', local_var_params['threshold']))  # noqa: E501
        if 'file' in local_var_params:
            local_var_files['file'] = local_var_params['file']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/endpoints/{deploymentName}/model/{modelName}/{versionName}/detectobjects', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DetectionResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def download_job_output_file(self, job_id, download_output_file_request, **kwargs):  # noqa: E501
        """Download the output file from the job's execution. This will ONLY work if the job's run status is 'COMPLETE'.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.download_job_output_file(job_id, download_output_file_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int job_id: Job ID (required)
        :param DownloadOutputFileRequest download_output_file_request: Download output file request object (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.download_job_output_file_with_http_info(job_id, download_output_file_request, **kwargs)  # noqa: E501

    def download_job_output_file_with_http_info(self, job_id, download_output_file_request, **kwargs):  # noqa: E501
        """Download the output file from the job's execution. This will ONLY work if the job's run status is 'COMPLETE'.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.download_job_output_file_with_http_info(job_id, download_output_file_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int job_id: Job ID (required)
        :param DownloadOutputFileRequest download_output_file_request: Download output file request object (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['job_id', 'download_output_file_request']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method download_job_output_file" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'job_id' is set
        if ('job_id' not in local_var_params or
                local_var_params['job_id'] is None):
            raise ApiValueError("Missing the required parameter `job_id` when calling `download_job_output_file`")  # noqa: E501
        # verify the required parameter 'download_output_file_request' is set
        if ('download_output_file_request' not in local_var_params or
                local_var_params['download_output_file_request'] is None):
            raise ApiValueError("Missing the required parameter `download_output_file_request` when calling `download_job_output_file`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'job_id' in local_var_params:
            path_params['jobId'] = local_var_params['job_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'download_output_file_request' in local_var_params:
            body_params = local_var_params['download_output_file_request']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/jobs/{jobId}/outputfile', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def generate_auth_token(self, token_generate_request, **kwargs):  # noqa: E501
        """Generate new auth token  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.generate_auth_token(token_generate_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param TokenGenerateRequest token_generate_request: Auth token details. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Token
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.generate_auth_token_with_http_info(token_generate_request, **kwargs)  # noqa: E501

    def generate_auth_token_with_http_info(self, token_generate_request, **kwargs):  # noqa: E501
        """Generate new auth token  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.generate_auth_token_with_http_info(token_generate_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param TokenGenerateRequest token_generate_request: Auth token details. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Token, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['token_generate_request']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method generate_auth_token" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'token_generate_request' is set
        if ('token_generate_request' not in local_var_params or
                local_var_params['token_generate_request'] is None):
            raise ApiValueError("Missing the required parameter `token_generate_request` when calling `generate_auth_token`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'token_generate_request' in local_var_params:
            body_params = local_var_params['token_generate_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/auth/token', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Token',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_jobs(self, **kwargs):  # noqa: E501
        """Get a list of all available jobs  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_jobs(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: list[JobEntity]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_all_jobs_with_http_info(**kwargs)  # noqa: E501

    def get_all_jobs_with_http_info(self, **kwargs):  # noqa: E501
        """Get a list of all available jobs  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_jobs_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(list[JobEntity], status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_jobs" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/jobs', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[JobEntity]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_array(self, accept, array_type, **kwargs):  # noqa: E501
        """Get the memory mapped array based on the array type.  # noqa: E501

        The array is specified through a file path, in the configuration object, during model server deployment.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_array(accept, array_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str accept: (required)
        :param str array_type: The format in which the memory mapped array is returned. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_array_with_http_info(accept, array_type, **kwargs)  # noqa: E501

    def get_array_with_http_info(self, accept, array_type, **kwargs):  # noqa: E501
        """Get the memory mapped array based on the array type.  # noqa: E501

        The array is specified through a file path, in the configuration object, during model server deployment.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_array_with_http_info(accept, array_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str accept: (required)
        :param str array_type: The format in which the memory mapped array is returned. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['accept', 'array_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_array" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'accept' is set
        if ('accept' not in local_var_params or
                local_var_params['accept'] is None):
            raise ApiValueError("Missing the required parameter `accept` when calling `get_array`")  # noqa: E501
        # verify the required parameter 'array_type' is set
        if ('array_type' not in local_var_params or
                local_var_params['array_type'] is None):
            raise ApiValueError("Missing the required parameter `array_type` when calling `get_array`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'array_type' in local_var_params:
            path_params['arrayType'] = local_var_params['array_type']  # noqa: E501

        query_params = []

        header_params = {}
        if 'accept' in local_var_params:
            header_params['accept'] = local_var_params['accept']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/array/{arrayType}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_array_indices(self, content_type, accept, array_type, **kwargs):  # noqa: E501
        """Get the memory mapped array indices based on the array type.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_array_indices(content_type, accept, array_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str content_type: The `Content-Type` should always be `application/json`. (required)
        :param str accept: (required)
        :param str array_type: Format in which the memory mapped array is returned in. (required)
        :param str input: Input indices array
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_array_indices_with_http_info(content_type, accept, array_type, **kwargs)  # noqa: E501

    def get_array_indices_with_http_info(self, content_type, accept, array_type, **kwargs):  # noqa: E501
        """Get the memory mapped array indices based on the array type.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_array_indices_with_http_info(content_type, accept, array_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str content_type: The `Content-Type` should always be `application/json`. (required)
        :param str accept: (required)
        :param str array_type: Format in which the memory mapped array is returned in. (required)
        :param str input: Input indices array
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['content_type', 'accept', 'array_type', 'input']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_array_indices" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'content_type' is set
        if ('content_type' not in local_var_params or
                local_var_params['content_type'] is None):
            raise ApiValueError("Missing the required parameter `content_type` when calling `get_array_indices`")  # noqa: E501
        # verify the required parameter 'accept' is set
        if ('accept' not in local_var_params or
                local_var_params['accept'] is None):
            raise ApiValueError("Missing the required parameter `accept` when calling `get_array_indices`")  # noqa: E501
        # verify the required parameter 'array_type' is set
        if ('array_type' not in local_var_params or
                local_var_params['array_type'] is None):
            raise ApiValueError("Missing the required parameter `array_type` when calling `get_array_indices`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'array_type' in local_var_params:
            path_params['arrayType'] = local_var_params['array_type']  # noqa: E501

        query_params = []

        header_params = {}
        if 'content_type' in local_var_params:
            header_params['Content-Type'] = local_var_params['content_type']  # noqa: E501
        if 'accept' in local_var_params:
            header_params['accept'] = local_var_params['accept']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'input' in local_var_params:
            body_params = local_var_params['input']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/array/indices/{arrayType}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_array_range(self, accept, array_type, _from, to, **kwargs):  # noqa: E501
        """Get the memory mapped array within a range based on the array type.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_array_range(accept, array_type, _from, to, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str accept: (required)
        :param str array_type: Format in which the memory mapped array is returned in. (required)
        :param int _from: (required)
        :param int to: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_array_range_with_http_info(accept, array_type, _from, to, **kwargs)  # noqa: E501

    def get_array_range_with_http_info(self, accept, array_type, _from, to, **kwargs):  # noqa: E501
        """Get the memory mapped array within a range based on the array type.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_array_range_with_http_info(accept, array_type, _from, to, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str accept: (required)
        :param str array_type: Format in which the memory mapped array is returned in. (required)
        :param int _from: (required)
        :param int to: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['accept', 'array_type', '_from', 'to']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_array_range" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'accept' is set
        if ('accept' not in local_var_params or
                local_var_params['accept'] is None):
            raise ApiValueError("Missing the required parameter `accept` when calling `get_array_range`")  # noqa: E501
        # verify the required parameter 'array_type' is set
        if ('array_type' not in local_var_params or
                local_var_params['array_type'] is None):
            raise ApiValueError("Missing the required parameter `array_type` when calling `get_array_range`")  # noqa: E501
        # verify the required parameter '_from' is set
        if ('_from' not in local_var_params or
                local_var_params['_from'] is None):
            raise ApiValueError("Missing the required parameter `_from` when calling `get_array_range`")  # noqa: E501
        # verify the required parameter 'to' is set
        if ('to' not in local_var_params or
                local_var_params['to'] is None):
            raise ApiValueError("Missing the required parameter `to` when calling `get_array_range`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'array_type' in local_var_params:
            path_params['arrayType'] = local_var_params['array_type']  # noqa: E501
        if '_from' in local_var_params:
            path_params['from'] = local_var_params['_from']  # noqa: E501
        if 'to' in local_var_params:
            path_params['to'] = local_var_params['to']  # noqa: E501

        query_params = []

        header_params = {}
        if 'accept' in local_var_params:
            header_params['accept'] = local_var_params['accept']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/array/range/{from}/{to}/{arrayType}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_auth_policy(self, **kwargs):  # noqa: E501
        """Get auth policy  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_auth_policy(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: AuthPolicy
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_auth_policy_with_http_info(**kwargs)  # noqa: E501

    def get_auth_policy_with_http_info(self, **kwargs):  # noqa: E501
        """Get auth policy  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_auth_policy_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(AuthPolicy, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_auth_policy" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/auth/policy', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AuthPolicy',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_best_model_among_model_ids(self, model_history_server_id, best_model, **kwargs):  # noqa: E501
        """Gets the best model among the given model instance IDs, based on the evaluation type and column metric  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_best_model_among_model_ids(model_history_server_id, best_model, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str model_history_server_id: Process GUID of the model history server. Run `$SKIL_HOME/sbin/skil services` in a console to find out the model history server GUID. (required)
        :param BestModel best_model: Object encapsulating the model ids, eval type and column metric name (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ModelInstanceEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_best_model_among_model_ids_with_http_info(model_history_server_id, best_model, **kwargs)  # noqa: E501

    def get_best_model_among_model_ids_with_http_info(self, model_history_server_id, best_model, **kwargs):  # noqa: E501
        """Gets the best model among the given model instance IDs, based on the evaluation type and column metric  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_best_model_among_model_ids_with_http_info(model_history_server_id, best_model, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str model_history_server_id: Process GUID of the model history server. Run `$SKIL_HOME/sbin/skil services` in a console to find out the model history server GUID. (required)
        :param BestModel best_model: Object encapsulating the model ids, eval type and column metric name (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ModelInstanceEntity, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['model_history_server_id', 'best_model']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_best_model_among_model_ids" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'model_history_server_id' is set
        if ('model_history_server_id' not in local_var_params or
                local_var_params['model_history_server_id'] is None):
            raise ApiValueError("Missing the required parameter `model_history_server_id` when calling `get_best_model_among_model_ids`")  # noqa: E501
        # verify the required parameter 'best_model' is set
        if ('best_model' not in local_var_params or
                local_var_params['best_model'] is None):
            raise ApiValueError("Missing the required parameter `best_model` when calling `get_best_model_among_model_ids`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model_history_server_id' in local_var_params:
            path_params['modelHistoryServerId'] = local_var_params['model_history_server_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'best_model' in local_var_params:
            body_params = local_var_params['best_model']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/rpc/{modelHistoryServerId}/model/best', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ModelInstanceEntity',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_credentials_by_id(self, credential_id, **kwargs):  # noqa: E501
        """Get credentials given an ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_credentials_by_id(credential_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int credential_id: Credentials ID (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ResourceCredentials
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_credentials_by_id_with_http_info(credential_id, **kwargs)  # noqa: E501

    def get_credentials_by_id_with_http_info(self, credential_id, **kwargs):  # noqa: E501
        """Get credentials given an ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_credentials_by_id_with_http_info(credential_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int credential_id: Credentials ID (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ResourceCredentials, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['credential_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_credentials_by_id" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'credential_id' is set
        if ('credential_id' not in local_var_params or
                local_var_params['credential_id'] is None):
            raise ApiValueError("Missing the required parameter `credential_id` when calling `get_credentials_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'credential_id' in local_var_params:
            path_params['credentialId'] = local_var_params['credential_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/resources/credentials/{credentialId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ResourceCredentials',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_current_model(self, **kwargs):  # noqa: E501
        """Returns the current model being used for retraining.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_current_model(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_current_model_with_http_info(**kwargs)  # noqa: E501

    def get_current_model_with_http_info(self, **kwargs):  # noqa: E501
        """Returns the current model being used for retraining.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_current_model_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_current_model" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/model', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_evaluation_for_model_id(self, model_history_server_id, model_instance_id, **kwargs):  # noqa: E501
        """Gets the list of evaluation results entity, given a model instance ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_evaluation_for_model_id(model_history_server_id, model_instance_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str model_history_server_id: Process GUID of the model history server. Run `$SKIL_HOME/sbin/skil services` in a console to find out the model history server GUID. (required)
        :param str model_instance_id: GUID of the model instance to get evaluation results for. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: list[EvaluationResultsEntity]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_evaluation_for_model_id_with_http_info(model_history_server_id, model_instance_id, **kwargs)  # noqa: E501

    def get_evaluation_for_model_id_with_http_info(self, model_history_server_id, model_instance_id, **kwargs):  # noqa: E501
        """Gets the list of evaluation results entity, given a model instance ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_evaluation_for_model_id_with_http_info(model_history_server_id, model_instance_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str model_history_server_id: Process GUID of the model history server. Run `$SKIL_HOME/sbin/skil services` in a console to find out the model history server GUID. (required)
        :param str model_instance_id: GUID of the model instance to get evaluation results for. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(list[EvaluationResultsEntity], status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['model_history_server_id', 'model_instance_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_evaluation_for_model_id" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'model_history_server_id' is set
        if ('model_history_server_id' not in local_var_params or
                local_var_params['model_history_server_id'] is None):
            raise ApiValueError("Missing the required parameter `model_history_server_id` when calling `get_evaluation_for_model_id`")  # noqa: E501
        # verify the required parameter 'model_instance_id' is set
        if ('model_instance_id' not in local_var_params or
                local_var_params['model_instance_id'] is None):
            raise ApiValueError("Missing the required parameter `model_instance_id` when calling `get_evaluation_for_model_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model_history_server_id' in local_var_params:
            path_params['modelHistoryServerId'] = local_var_params['model_history_server_id']  # noqa: E501
        if 'model_instance_id' in local_var_params:
            path_params['modelInstanceID'] = local_var_params['model_instance_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/rpc/{modelHistoryServerId}/model/revisions/evaluations/{modelInstanceID}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[EvaluationResultsEntity]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_examples_for_minibatch(self, model_history_server_id, minibatch_id, **kwargs):  # noqa: E501
        """Gets all the examples for a minibatch ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_examples_for_minibatch(model_history_server_id, minibatch_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str model_history_server_id: Process GUID of the model history server. Run `$SKIL_HOME/sbin/skil services` in a console to find out the model history server GUID. (required)
        :param str minibatch_id: The GUID of the minibatch (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: list[ExampleEntity]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_examples_for_minibatch_with_http_info(model_history_server_id, minibatch_id, **kwargs)  # noqa: E501

    def get_examples_for_minibatch_with_http_info(self, model_history_server_id, minibatch_id, **kwargs):  # noqa: E501
        """Gets all the examples for a minibatch ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_examples_for_minibatch_with_http_info(model_history_server_id, minibatch_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str model_history_server_id: Process GUID of the model history server. Run `$SKIL_HOME/sbin/skil services` in a console to find out the model history server GUID. (required)
        :param str minibatch_id: The GUID of the minibatch (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(list[ExampleEntity], status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['model_history_server_id', 'minibatch_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_examples_for_minibatch" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'model_history_server_id' is set
        if ('model_history_server_id' not in local_var_params or
                local_var_params['model_history_server_id'] is None):
            raise ApiValueError("Missing the required parameter `model_history_server_id` when calling `get_examples_for_minibatch`")  # noqa: E501
        # verify the required parameter 'minibatch_id' is set
        if ('minibatch_id' not in local_var_params or
                local_var_params['minibatch_id'] is None):
            raise ApiValueError("Missing the required parameter `minibatch_id` when calling `get_examples_for_minibatch`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model_history_server_id' in local_var_params:
            path_params['modelHistoryServerId'] = local_var_params['model_history_server_id']  # noqa: E501
        if 'minibatch_id' in local_var_params:
            path_params['minibatchId'] = local_var_params['minibatch_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/rpc/{modelHistoryServerId}/model/example/{minibatchId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ExampleEntity]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_experiment(self, model_history_server_id, experiment_id, **kwargs):  # noqa: E501
        """Obtain an experiment's details, given its ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_experiment(model_history_server_id, experiment_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str model_history_server_id: Process GUID of the model history server. Run `$SKIL_HOME/sbin/skil services` in a console to find out the model history server GUID. (required)
        :param str experiment_id: the GUID of the experiment to obtain (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ExperimentEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_experiment_with_http_info(model_history_server_id, experiment_id, **kwargs)  # noqa: E501

    def get_experiment_with_http_info(self, model_history_server_id, experiment_id, **kwargs):  # noqa: E501
        """Obtain an experiment's details, given its ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_experiment_with_http_info(model_history_server_id, experiment_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str model_history_server_id: Process GUID of the model history server. Run `$SKIL_HOME/sbin/skil services` in a console to find out the model history server GUID. (required)
        :param str experiment_id: the GUID of the experiment to obtain (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ExperimentEntity, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['model_history_server_id', 'experiment_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_experiment" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'model_history_server_id' is set
        if ('model_history_server_id' not in local_var_params or
                local_var_params['model_history_server_id'] is None):
            raise ApiValueError("Missing the required parameter `model_history_server_id` when calling `get_experiment`")  # noqa: E501
        # verify the required parameter 'experiment_id' is set
        if ('experiment_id' not in local_var_params or
                local_var_params['experiment_id'] is None):
            raise ApiValueError("Missing the required parameter `experiment_id` when calling `get_experiment`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model_history_server_id' in local_var_params:
            path_params['modelHistoryServerId'] = local_var_params['model_history_server_id']  # noqa: E501
        if 'experiment_id' in local_var_params:
            path_params['experimentID'] = local_var_params['experiment_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/rpc/{modelHistoryServerId}/experiment/{experimentID}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ExperimentEntity',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_experiments_for_model_history(self, model_history_server_id, model_history_id, **kwargs):  # noqa: E501
        """Obtain all experiments for a model history / workspace  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_experiments_for_model_history(model_history_server_id, model_history_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str model_history_server_id: Process GUID of the model history server. Run `$SKIL_HOME/sbin/skil services` in a console to find out the model history server GUID. (required)
        :param str model_history_id: the GUID of the model history / workspace (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: list[ExperimentEntity]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_experiments_for_model_history_with_http_info(model_history_server_id, model_history_id, **kwargs)  # noqa: E501

    def get_experiments_for_model_history_with_http_info(self, model_history_server_id, model_history_id, **kwargs):  # noqa: E501
        """Obtain all experiments for a model history / workspace  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_experiments_for_model_history_with_http_info(model_history_server_id, model_history_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str model_history_server_id: Process GUID of the model history server. Run `$SKIL_HOME/sbin/skil services` in a console to find out the model history server GUID. (required)
        :param str model_history_id: the GUID of the model history / workspace (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(list[ExperimentEntity], status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['model_history_server_id', 'model_history_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_experiments_for_model_history" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'model_history_server_id' is set
        if ('model_history_server_id' not in local_var_params or
                local_var_params['model_history_server_id'] is None):
            raise ApiValueError("Missing the required parameter `model_history_server_id` when calling `get_experiments_for_model_history`")  # noqa: E501
        # verify the required parameter 'model_history_id' is set
        if ('model_history_id' not in local_var_params or
                local_var_params['model_history_id'] is None):
            raise ApiValueError("Missing the required parameter `model_history_id` when calling `get_experiments_for_model_history`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model_history_server_id' in local_var_params:
            path_params['modelHistoryServerId'] = local_var_params['model_history_server_id']  # noqa: E501
        if 'model_history_id' in local_var_params:
            path_params['modelHistoryID'] = local_var_params['model_history_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/rpc/{modelHistoryServerId}/experiments/{modelHistoryID}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ExperimentEntity]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_job_by_id(self, job_id_or_type, **kwargs):  # noqa: E501
        """Get a job by its ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_job_by_id(job_id_or_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int job_id_or_type: Job ID (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: JobEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_job_by_id_with_http_info(job_id_or_type, **kwargs)  # noqa: E501

    def get_job_by_id_with_http_info(self, job_id_or_type, **kwargs):  # noqa: E501
        """Get a job by its ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_job_by_id_with_http_info(job_id_or_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int job_id_or_type: Job ID (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(JobEntity, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['job_id_or_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_job_by_id" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'job_id_or_type' is set
        if ('job_id_or_type' not in local_var_params or
                local_var_params['job_id_or_type'] is None):
            raise ApiValueError("Missing the required parameter `job_id_or_type` when calling `get_job_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'job_id_or_type' in local_var_params:
            path_params['jobIdOrType'] = local_var_params['job_id_or_type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/jobs/{jobIdOrType}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='JobEntity',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_last_evaluation(self, **kwargs):  # noqa: E501
        """Get the last evaluation specifications from the current model.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_last_evaluation(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: EvaluationResultsEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_last_evaluation_with_http_info(**kwargs)  # noqa: E501

    def get_last_evaluation_with_http_info(self, **kwargs):  # noqa: E501
        """Get the last evaluation specifications from the current model.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_last_evaluation_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(EvaluationResultsEntity, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_last_evaluation" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/lastevaluation', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EvaluationResultsEntity',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_minibatch(self, model_history_server_id, minibatch_id, **kwargs):  # noqa: E501
        """Gets a minibatch for the model  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_minibatch(model_history_server_id, minibatch_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str model_history_server_id: Process GUID of the model history server. Run `$SKIL_HOME/sbin/skil services` in a console to find out the model history server GUID. (required)
        :param str minibatch_id: The GUID of the minibatch (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: MinibatchEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_minibatch_with_http_info(model_history_server_id, minibatch_id, **kwargs)  # noqa: E501

    def get_minibatch_with_http_info(self, model_history_server_id, minibatch_id, **kwargs):  # noqa: E501
        """Gets a minibatch for the model  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_minibatch_with_http_info(model_history_server_id, minibatch_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str model_history_server_id: Process GUID of the model history server. Run `$SKIL_HOME/sbin/skil services` in a console to find out the model history server GUID. (required)
        :param str minibatch_id: The GUID of the minibatch (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(MinibatchEntity, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['model_history_server_id', 'minibatch_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_minibatch" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'model_history_server_id' is set
        if ('model_history_server_id' not in local_var_params or
                local_var_params['model_history_server_id'] is None):
            raise ApiValueError("Missing the required parameter `model_history_server_id` when calling `get_minibatch`")  # noqa: E501
        # verify the required parameter 'minibatch_id' is set
        if ('minibatch_id' not in local_var_params or
                local_var_params['minibatch_id'] is None):
            raise ApiValueError("Missing the required parameter `minibatch_id` when calling `get_minibatch`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model_history_server_id' in local_var_params:
            path_params['modelHistoryServerId'] = local_var_params['model_history_server_id']  # noqa: E501
        if 'minibatch_id' in local_var_params:
            path_params['minibatchId'] = local_var_params['minibatch_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/rpc/{modelHistoryServerId}/model/minibatch/{minibatchId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MinibatchEntity',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_model_details(self, deployment_id, model_id, **kwargs):  # noqa: E501
        """Get model details  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_model_details(deployment_id, model_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str deployment_id: ID deployment group (required)
        :param str model_id: the id of the deployed model (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ModelEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_model_details_with_http_info(deployment_id, model_id, **kwargs)  # noqa: E501

    def get_model_details_with_http_info(self, deployment_id, model_id, **kwargs):  # noqa: E501
        """Get model details  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_model_details_with_http_info(deployment_id, model_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str deployment_id: ID deployment group (required)
        :param str model_id: the id of the deployed model (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ModelEntity, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['deployment_id', 'model_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_model_details" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'deployment_id' is set
        if ('deployment_id' not in local_var_params or
                local_var_params['deployment_id'] is None):
            raise ApiValueError("Missing the required parameter `deployment_id` when calling `get_model_details`")  # noqa: E501
        # verify the required parameter 'model_id' is set
        if ('model_id' not in local_var_params or
                local_var_params['model_id'] is None):
            raise ApiValueError("Missing the required parameter `model_id` when calling `get_model_details`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'deployment_id' in local_var_params:
            path_params['deploymentId'] = local_var_params['deployment_id']  # noqa: E501
        if 'model_id' in local_var_params:
            path_params['modelId'] = local_var_params['model_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/deployment/{deploymentId}/model/{modelId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ModelEntity',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_model_history(self, model_history_server_id, model_history_id, **kwargs):  # noqa: E501
        """Gets a model history, given its ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_model_history(model_history_server_id, model_history_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str model_history_server_id: Process GUID of the model history server. Run `$SKIL_HOME/sbin/skil services` in a console to find out the model history server GUID. (required)
        :param str model_history_id: GUID of the model history to get information of. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ModelHistoryEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_model_history_with_http_info(model_history_server_id, model_history_id, **kwargs)  # noqa: E501

    def get_model_history_with_http_info(self, model_history_server_id, model_history_id, **kwargs):  # noqa: E501
        """Gets a model history, given its ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_model_history_with_http_info(model_history_server_id, model_history_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str model_history_server_id: Process GUID of the model history server. Run `$SKIL_HOME/sbin/skil services` in a console to find out the model history server GUID. (required)
        :param str model_history_id: GUID of the model history to get information of. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ModelHistoryEntity, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['model_history_server_id', 'model_history_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_model_history" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'model_history_server_id' is set
        if ('model_history_server_id' not in local_var_params or
                local_var_params['model_history_server_id'] is None):
            raise ApiValueError("Missing the required parameter `model_history_server_id` when calling `get_model_history`")  # noqa: E501
        # verify the required parameter 'model_history_id' is set
        if ('model_history_id' not in local_var_params or
                local_var_params['model_history_id'] is None):
            raise ApiValueError("Missing the required parameter `model_history_id` when calling `get_model_history`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model_history_server_id' in local_var_params:
            path_params['modelHistoryServerId'] = local_var_params['model_history_server_id']  # noqa: E501
        if 'model_history_id' in local_var_params:
            path_params['modelHistoryID'] = local_var_params['model_history_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/rpc/{modelHistoryServerId}/model/revision/{modelHistoryID}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ModelHistoryEntity',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_model_instance(self, model_history_server_id, model_instance_id, **kwargs):  # noqa: E501
        """Gets a model instance, given its ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_model_instance(model_history_server_id, model_instance_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str model_history_server_id: Process GUID of the model history server. Run `$SKIL_HOME/sbin/skil services` in a console to find out the model history server GUID. (required)
        :param str model_instance_id: GUID of the model instance to get information of. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ModelInstanceEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_model_instance_with_http_info(model_history_server_id, model_instance_id, **kwargs)  # noqa: E501

    def get_model_instance_with_http_info(self, model_history_server_id, model_instance_id, **kwargs):  # noqa: E501
        """Gets a model instance, given its ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_model_instance_with_http_info(model_history_server_id, model_instance_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str model_history_server_id: Process GUID of the model history server. Run `$SKIL_HOME/sbin/skil services` in a console to find out the model history server GUID. (required)
        :param str model_instance_id: GUID of the model instance to get information of. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ModelInstanceEntity, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['model_history_server_id', 'model_instance_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_model_instance" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'model_history_server_id' is set
        if ('model_history_server_id' not in local_var_params or
                local_var_params['model_history_server_id'] is None):
            raise ApiValueError("Missing the required parameter `model_history_server_id` when calling `get_model_instance`")  # noqa: E501
        # verify the required parameter 'model_instance_id' is set
        if ('model_instance_id' not in local_var_params or
                local_var_params['model_instance_id'] is None):
            raise ApiValueError("Missing the required parameter `model_instance_id` when calling `get_model_instance`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model_history_server_id' in local_var_params:
            path_params['modelHistoryServerId'] = local_var_params['model_history_server_id']  # noqa: E501
        if 'model_instance_id' in local_var_params:
            path_params['modelInstanceID'] = local_var_params['model_instance_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/rpc/{modelHistoryServerId}/model/{modelInstanceID}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ModelInstanceEntity',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_models_for_experiment(self, model_history_server_id, experiment_id, **kwargs):  # noqa: E501
        """Obtain a list of all the models for an experiment  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_models_for_experiment(model_history_server_id, experiment_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str model_history_server_id: Process GUID of the model history server. Run `$SKIL_HOME/sbin/skil services` in a console to find out the model history server GUID. (required)
        :param str experiment_id: the GUID of the experiment (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: list[ModelInstanceEntity]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_models_for_experiment_with_http_info(model_history_server_id, experiment_id, **kwargs)  # noqa: E501

    def get_models_for_experiment_with_http_info(self, model_history_server_id, experiment_id, **kwargs):  # noqa: E501
        """Obtain a list of all the models for an experiment  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_models_for_experiment_with_http_info(model_history_server_id, experiment_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str model_history_server_id: Process GUID of the model history server. Run `$SKIL_HOME/sbin/skil services` in a console to find out the model history server GUID. (required)
        :param str experiment_id: the GUID of the experiment (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(list[ModelInstanceEntity], status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['model_history_server_id', 'experiment_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_models_for_experiment" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'model_history_server_id' is set
        if ('model_history_server_id' not in local_var_params or
                local_var_params['model_history_server_id'] is None):
            raise ApiValueError("Missing the required parameter `model_history_server_id` when calling `get_models_for_experiment`")  # noqa: E501
        # verify the required parameter 'experiment_id' is set
        if ('experiment_id' not in local_var_params or
                local_var_params['experiment_id'] is None):
            raise ApiValueError("Missing the required parameter `experiment_id` when calling `get_models_for_experiment`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model_history_server_id' in local_var_params:
            path_params['modelHistoryServerId'] = local_var_params['model_history_server_id']  # noqa: E501
        if 'experiment_id' in local_var_params:
            path_params['experimentID'] = local_var_params['experiment_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/rpc/{modelHistoryServerId}/experiment/{experimentID}/models', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ModelInstanceEntity]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_resource_by_id(self, resource_id, **kwargs):  # noqa: E501
        """Get the resource with the specified resource ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_resource_by_id(resource_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int resource_id: ID of the resource (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Resource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_resource_by_id_with_http_info(resource_id, **kwargs)  # noqa: E501

    def get_resource_by_id_with_http_info(self, resource_id, **kwargs):  # noqa: E501
        """Get the resource with the specified resource ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_resource_by_id_with_http_info(resource_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int resource_id: ID of the resource (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Resource, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['resource_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_resource_by_id" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'resource_id' is set
        if ('resource_id' not in local_var_params or
                local_var_params['resource_id'] is None):
            raise ApiValueError("Missing the required parameter `resource_id` when calling `get_resource_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'resource_id' in local_var_params:
            path_params['resourceId'] = local_var_params['resource_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/resources/resource/{resourceId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Resource',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_resource_by_sub_type(self, resource_sub_type, **kwargs):  # noqa: E501
        """Get all the resources with the specified resource subtype  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_resource_by_sub_type(resource_sub_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str resource_sub_type: Subtype of the resource (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: list[Resource]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_resource_by_sub_type_with_http_info(resource_sub_type, **kwargs)  # noqa: E501

    def get_resource_by_sub_type_with_http_info(self, resource_sub_type, **kwargs):  # noqa: E501
        """Get all the resources with the specified resource subtype  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_resource_by_sub_type_with_http_info(resource_sub_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str resource_sub_type: Subtype of the resource (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(list[Resource], status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['resource_sub_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_resource_by_sub_type" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'resource_sub_type' is set
        if ('resource_sub_type' not in local_var_params or
                local_var_params['resource_sub_type'] is None):
            raise ApiValueError("Missing the required parameter `resource_sub_type` when calling `get_resource_by_sub_type`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'resource_sub_type' in local_var_params:
            path_params['resourceSubType'] = local_var_params['resource_sub_type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/resources/resources/subtype/{resourceSubType}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Resource]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_resource_by_type(self, resource_type, **kwargs):  # noqa: E501
        """Get all the resources with the specified resource type  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_resource_by_type(resource_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str resource_type: Type of the resource (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: list[Resource]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_resource_by_type_with_http_info(resource_type, **kwargs)  # noqa: E501

    def get_resource_by_type_with_http_info(self, resource_type, **kwargs):  # noqa: E501
        """Get all the resources with the specified resource type  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_resource_by_type_with_http_info(resource_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str resource_type: Type of the resource (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(list[Resource], status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['resource_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_resource_by_type" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'resource_type' is set
        if ('resource_type' not in local_var_params or
                local_var_params['resource_type'] is None):
            raise ApiValueError("Missing the required parameter `resource_type` when calling `get_resource_by_type`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'resource_type' in local_var_params:
            path_params['resourceType'] = local_var_params['resource_type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/resources/resources/type/{resourceType}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Resource]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_resource_details_by_id(self, resource_id, **kwargs):  # noqa: E501
        """Get the resource details with the specified resource ID  # noqa: E501

        Get the details for the resource, for the given ID. Note that a 'ResourceDetails' object contains specific information about the resource (such as region for an AWS resource, or URI for a HDFS resource), where as the 'Resource' object contains only general information (name, id, type, subtype).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_resource_details_by_id(resource_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int resource_id: ID of the resource (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_resource_details_by_id_with_http_info(resource_id, **kwargs)  # noqa: E501

    def get_resource_details_by_id_with_http_info(self, resource_id, **kwargs):  # noqa: E501
        """Get the resource details with the specified resource ID  # noqa: E501

        Get the details for the resource, for the given ID. Note that a 'ResourceDetails' object contains specific information about the resource (such as region for an AWS resource, or URI for a HDFS resource), where as the 'Resource' object contains only general information (name, id, type, subtype).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_resource_details_by_id_with_http_info(resource_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int resource_id: ID of the resource (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['resource_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_resource_details_by_id" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'resource_id' is set
        if ('resource_id' not in local_var_params or
                local_var_params['resource_id'] is None):
            raise ApiValueError("Missing the required parameter `resource_id` when calling `get_resource_details_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'resource_id' in local_var_params:
            path_params['resourceId'] = local_var_params['resource_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/resources/details/{resourceId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_resource_group_by_id(self, resource_group_id, **kwargs):  # noqa: E501
        """Get the resource group with the specified resource group ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_resource_group_by_id(resource_group_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int resource_group_id: ID of the resource group (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ResourceGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_resource_group_by_id_with_http_info(resource_group_id, **kwargs)  # noqa: E501

    def get_resource_group_by_id_with_http_info(self, resource_group_id, **kwargs):  # noqa: E501
        """Get the resource group with the specified resource group ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_resource_group_by_id_with_http_info(resource_group_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int resource_group_id: ID of the resource group (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ResourceGroup, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['resource_group_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_resource_group_by_id" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'resource_group_id' is set
        if ('resource_group_id' not in local_var_params or
                local_var_params['resource_group_id'] is None):
            raise ApiValueError("Missing the required parameter `resource_group_id` when calling `get_resource_group_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'resource_group_id' in local_var_params:
            path_params['resourceGroupId'] = local_var_params['resource_group_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/resources/group/{resourceGroupId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ResourceGroup',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_resource_groups(self, **kwargs):  # noqa: E501
        """Get a list of all the resource groups  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_resource_groups(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: list[ResourceGroup]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_resource_groups_with_http_info(**kwargs)  # noqa: E501

    def get_resource_groups_with_http_info(self, **kwargs):  # noqa: E501
        """Get a list of all the resource groups  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_resource_groups_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(list[ResourceGroup], status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_resource_groups" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/resources/groups', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ResourceGroup]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_resources(self, **kwargs):  # noqa: E501
        """A list of all known/registered resources, of all types  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_resources(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: list[Resource]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_resources_with_http_info(**kwargs)  # noqa: E501

    def get_resources_with_http_info(self, **kwargs):  # noqa: E501
        """A list of all known/registered resources, of all types  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_resources_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(list[Resource], status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_resources" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/resources/resources', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Resource]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_resources_from_group(self, resource_group_id, **kwargs):  # noqa: E501
        """Get all resources from a resource group  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_resources_from_group(resource_group_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int resource_group_id: ID of the resource group (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: list[Resource]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_resources_from_group_with_http_info(resource_group_id, **kwargs)  # noqa: E501

    def get_resources_from_group_with_http_info(self, resource_group_id, **kwargs):  # noqa: E501
        """Get all resources from a resource group  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_resources_from_group_with_http_info(resource_group_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int resource_group_id: ID of the resource group (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(list[Resource], status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['resource_group_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_resources_from_group" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'resource_group_id' is set
        if ('resource_group_id' not in local_var_params or
                local_var_params['resource_group_id'] is None):
            raise ApiValueError("Missing the required parameter `resource_group_id` when calling `get_resources_from_group`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'resource_group_id' in local_var_params:
            path_params['resourceGroupId'] = local_var_params['resource_group_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/resources/group/{resourceGroupId}/resources', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Resource]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_roles(self, **kwargs):  # noqa: E501
        """Get all roles.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_roles(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: list[Role]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_roles_with_http_info(**kwargs)  # noqa: E501

    def get_roles_with_http_info(self, **kwargs):  # noqa: E501
        """Get all roles.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_roles_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(list[Role], status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_roles" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/security/roles', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Role]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_user(self, user_id, **kwargs):  # noqa: E501
        """Get a user by user ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_user(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str user_id: User's ID (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: User
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_user_with_http_info(user_id, **kwargs)  # noqa: E501

    def get_user_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """Get a user by user ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_user_with_http_info(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str user_id: User's ID (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(User, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['user_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_user" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in local_var_params or
                local_var_params['user_id'] is None):
            raise ApiValueError("Missing the required parameter `user_id` when calling `get_user`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in local_var_params:
            path_params['userId'] = local_var_params['user_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/user/{userId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='User',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_user_auth_tokens(self, user_id, **kwargs):  # noqa: E501
        """Get auth tokens for a user.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_user_auth_tokens(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str user_id: User's ID (required)
        :param bool only_valid: True if you only want the valid tokens.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: list[Token]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_user_auth_tokens_with_http_info(user_id, **kwargs)  # noqa: E501

    def get_user_auth_tokens_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """Get auth tokens for a user.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_user_auth_tokens_with_http_info(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str user_id: User's ID (required)
        :param bool only_valid: True if you only want the valid tokens.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(list[Token], status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['user_id', 'only_valid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_user_auth_tokens" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in local_var_params or
                local_var_params['user_id'] is None):
            raise ApiValueError("Missing the required parameter `user_id` when calling `get_user_auth_tokens`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in local_var_params:
            path_params['userId'] = local_var_params['user_id']  # noqa: E501

        query_params = []
        if 'only_valid' in local_var_params:
            query_params.append(('onlyValid', local_var_params['only_valid']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/auth/{userId}/tokens', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Token]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_users(self, **kwargs):  # noqa: E501
        """Get all users.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_users(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: list[User]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_users_with_http_info(**kwargs)  # noqa: E501

    def get_users_with_http_info(self, **kwargs):  # noqa: E501
        """Get all users.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_users_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(list[User], status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_users" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/security/users', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[User]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def is_training(self, **kwargs):  # noqa: E501
        """Get the retraining status  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.is_training(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: RetrainingStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.is_training_with_http_info(**kwargs)  # noqa: E501

    def is_training_with_http_info(self, **kwargs):  # noqa: E501
        """Get the retraining status  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.is_training_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(RetrainingStatus, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method is_training" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/istraining', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RetrainingStatus',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def jsonarray(self, deployment_name, version_name, model_name, body, **kwargs):  # noqa: E501
        """Run inference on the input and returns it as a JsonArrayResponse  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.jsonarray(deployment_name, version_name, model_name, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str model_name: ID or name of the deployed model (required)
        :param Prediction body: The input NDArray (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: JsonArrayResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.jsonarray_with_http_info(deployment_name, version_name, model_name, body, **kwargs)  # noqa: E501

    def jsonarray_with_http_info(self, deployment_name, version_name, model_name, body, **kwargs):  # noqa: E501
        """Run inference on the input and returns it as a JsonArrayResponse  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.jsonarray_with_http_info(deployment_name, version_name, model_name, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str model_name: ID or name of the deployed model (required)
        :param Prediction body: The input NDArray (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(JsonArrayResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['deployment_name', 'version_name', 'model_name', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method jsonarray" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'deployment_name' is set
        if ('deployment_name' not in local_var_params or
                local_var_params['deployment_name'] is None):
            raise ApiValueError("Missing the required parameter `deployment_name` when calling `jsonarray`")  # noqa: E501
        # verify the required parameter 'version_name' is set
        if ('version_name' not in local_var_params or
                local_var_params['version_name'] is None):
            raise ApiValueError("Missing the required parameter `version_name` when calling `jsonarray`")  # noqa: E501
        # verify the required parameter 'model_name' is set
        if ('model_name' not in local_var_params or
                local_var_params['model_name'] is None):
            raise ApiValueError("Missing the required parameter `model_name` when calling `jsonarray`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in local_var_params or
                local_var_params['body'] is None):
            raise ApiValueError("Missing the required parameter `body` when calling `jsonarray`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'deployment_name' in local_var_params:
            path_params['deploymentName'] = local_var_params['deployment_name']  # noqa: E501
        if 'version_name' in local_var_params:
            path_params['versionName'] = local_var_params['version_name']  # noqa: E501
        if 'model_name' in local_var_params:
            path_params['modelName'] = local_var_params['model_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/endpoints/{deploymentName}/model/{modelName}/{versionName}/jsonarray', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='JsonArrayResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def knn(self, deployment_name, version_name, knn_name, body, **kwargs):  # noqa: E501
        """Runs knn on the given index with the given k  # noqa: E501

        Runs knn on the given index with the given k (note that this is for data already within the existing dataset not new data)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.knn(deployment_name, version_name, knn_name, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str knn_name: ID or name of the deployed knn (required)
        :param NearestNeighborRequest body: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: NearestNeighborsResults
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.knn_with_http_info(deployment_name, version_name, knn_name, body, **kwargs)  # noqa: E501

    def knn_with_http_info(self, deployment_name, version_name, knn_name, body, **kwargs):  # noqa: E501
        """Runs knn on the given index with the given k  # noqa: E501

        Runs knn on the given index with the given k (note that this is for data already within the existing dataset not new data)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.knn_with_http_info(deployment_name, version_name, knn_name, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str knn_name: ID or name of the deployed knn (required)
        :param NearestNeighborRequest body: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(NearestNeighborsResults, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['deployment_name', 'version_name', 'knn_name', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method knn" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'deployment_name' is set
        if ('deployment_name' not in local_var_params or
                local_var_params['deployment_name'] is None):
            raise ApiValueError("Missing the required parameter `deployment_name` when calling `knn`")  # noqa: E501
        # verify the required parameter 'version_name' is set
        if ('version_name' not in local_var_params or
                local_var_params['version_name'] is None):
            raise ApiValueError("Missing the required parameter `version_name` when calling `knn`")  # noqa: E501
        # verify the required parameter 'knn_name' is set
        if ('knn_name' not in local_var_params or
                local_var_params['knn_name'] is None):
            raise ApiValueError("Missing the required parameter `knn_name` when calling `knn`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in local_var_params or
                local_var_params['body'] is None):
            raise ApiValueError("Missing the required parameter `body` when calling `knn`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'deployment_name' in local_var_params:
            path_params['deploymentName'] = local_var_params['deployment_name']  # noqa: E501
        if 'version_name' in local_var_params:
            path_params['versionName'] = local_var_params['version_name']  # noqa: E501
        if 'knn_name' in local_var_params:
            path_params['knnName'] = local_var_params['knn_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/endpoints/{deploymentName}/knn/{knnName}/{versionName}/knn', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NearestNeighborsResults',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def knnnew(self, deployment_name, version_name, knn_name, body, **kwargs):  # noqa: E501
        """Run a k nearest neighbors search on a NEW data point  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.knnnew(deployment_name, version_name, knn_name, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str knn_name: ID or name of the deployed knn (required)
        :param Base64NDArrayBodyKNN body: The input NDArray (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: NearestNeighborsResults
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.knnnew_with_http_info(deployment_name, version_name, knn_name, body, **kwargs)  # noqa: E501

    def knnnew_with_http_info(self, deployment_name, version_name, knn_name, body, **kwargs):  # noqa: E501
        """Run a k nearest neighbors search on a NEW data point  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.knnnew_with_http_info(deployment_name, version_name, knn_name, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str knn_name: ID or name of the deployed knn (required)
        :param Base64NDArrayBodyKNN body: The input NDArray (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(NearestNeighborsResults, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['deployment_name', 'version_name', 'knn_name', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method knnnew" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'deployment_name' is set
        if ('deployment_name' not in local_var_params or
                local_var_params['deployment_name'] is None):
            raise ApiValueError("Missing the required parameter `deployment_name` when calling `knnnew`")  # noqa: E501
        # verify the required parameter 'version_name' is set
        if ('version_name' not in local_var_params or
                local_var_params['version_name'] is None):
            raise ApiValueError("Missing the required parameter `version_name` when calling `knnnew`")  # noqa: E501
        # verify the required parameter 'knn_name' is set
        if ('knn_name' not in local_var_params or
                local_var_params['knn_name'] is None):
            raise ApiValueError("Missing the required parameter `knn_name` when calling `knnnew`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in local_var_params or
                local_var_params['body'] is None):
            raise ApiValueError("Missing the required parameter `body` when calling `knnnew`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'deployment_name' in local_var_params:
            path_params['deploymentName'] = local_var_params['deployment_name']  # noqa: E501
        if 'version_name' in local_var_params:
            path_params['versionName'] = local_var_params['version_name']  # noqa: E501
        if 'knn_name' in local_var_params:
            path_params['knnName'] = local_var_params['knn_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/endpoints/{deploymentName}/knn/{knnName}/{versionName}/knnnew', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NearestNeighborsResults',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_all_experiments(self, model_history_server_id, **kwargs):  # noqa: E501
        """List all of the experiments in every model history / workspace  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_all_experiments(model_history_server_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str model_history_server_id: Process GUID of the model history server. Run `$SKIL_HOME/sbin/skil services` in a console to find out the model history server GUID. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: list[ExperimentEntity]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.list_all_experiments_with_http_info(model_history_server_id, **kwargs)  # noqa: E501

    def list_all_experiments_with_http_info(self, model_history_server_id, **kwargs):  # noqa: E501
        """List all of the experiments in every model history / workspace  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_all_experiments_with_http_info(model_history_server_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str model_history_server_id: Process GUID of the model history server. Run `$SKIL_HOME/sbin/skil services` in a console to find out the model history server GUID. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(list[ExperimentEntity], status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['model_history_server_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_all_experiments" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'model_history_server_id' is set
        if ('model_history_server_id' not in local_var_params or
                local_var_params['model_history_server_id'] is None):
            raise ApiValueError("Missing the required parameter `model_history_server_id` when calling `list_all_experiments`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model_history_server_id' in local_var_params:
            path_params['modelHistoryServerId'] = local_var_params['model_history_server_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/rpc/{modelHistoryServerId}/experiments', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ExperimentEntity]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def logfilepath(self, deployment_name, version_name, model_name, **kwargs):  # noqa: E501
        """Get logs file path  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.logfilepath(deployment_name, version_name, model_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str model_name: ID or name of the deployed model (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.logfilepath_with_http_info(deployment_name, version_name, model_name, **kwargs)  # noqa: E501

    def logfilepath_with_http_info(self, deployment_name, version_name, model_name, **kwargs):  # noqa: E501
        """Get logs file path  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.logfilepath_with_http_info(deployment_name, version_name, model_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str model_name: ID or name of the deployed model (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(str, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['deployment_name', 'version_name', 'model_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method logfilepath" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'deployment_name' is set
        if ('deployment_name' not in local_var_params or
                local_var_params['deployment_name'] is None):
            raise ApiValueError("Missing the required parameter `deployment_name` when calling `logfilepath`")  # noqa: E501
        # verify the required parameter 'version_name' is set
        if ('version_name' not in local_var_params or
                local_var_params['version_name'] is None):
            raise ApiValueError("Missing the required parameter `version_name` when calling `logfilepath`")  # noqa: E501
        # verify the required parameter 'model_name' is set
        if ('model_name' not in local_var_params or
                local_var_params['model_name'] is None):
            raise ApiValueError("Missing the required parameter `model_name` when calling `logfilepath`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'deployment_name' in local_var_params:
            path_params['deploymentName'] = local_var_params['deployment_name']  # noqa: E501
        if 'version_name' in local_var_params:
            path_params['versionName'] = local_var_params['version_name']  # noqa: E501
        if 'model_name' in local_var_params:
            path_params['modelName'] = local_var_params['model_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/endpoints/{deploymentName}/model/{modelName}/{versionName}/logfilepath', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def login(self, login_request, **kwargs):  # noqa: E501
        """Post JSON credentials and obtain a JWT authorization token.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.login(login_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param LoginRequest login_request: Login credentials. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: LoginResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.login_with_http_info(login_request, **kwargs)  # noqa: E501

    def login_with_http_info(self, login_request, **kwargs):  # noqa: E501
        """Post JSON credentials and obtain a JWT authorization token.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.login_with_http_info(login_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param LoginRequest login_request: Login credentials. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(LoginResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['login_request']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method login" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'login_request' is set
        if ('login_request' not in local_var_params or
                local_var_params['login_request'] is None):
            raise ApiValueError("Missing the required parameter `login_request` when calling `login`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'login_request' in local_var_params:
            body_params = local_var_params['login_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/login', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LoginResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def logs(self, deployment_name, version_name, model_name, log_request, **kwargs):  # noqa: E501
        """Get logs  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.logs(deployment_name, version_name, model_name, log_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str model_name: ID or name of the deployed model (required)
        :param LogRequest log_request: The log object (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: LogBatch
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.logs_with_http_info(deployment_name, version_name, model_name, log_request, **kwargs)  # noqa: E501

    def logs_with_http_info(self, deployment_name, version_name, model_name, log_request, **kwargs):  # noqa: E501
        """Get logs  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.logs_with_http_info(deployment_name, version_name, model_name, log_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str model_name: ID or name of the deployed model (required)
        :param LogRequest log_request: The log object (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(LogBatch, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['deployment_name', 'version_name', 'model_name', 'log_request']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method logs" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'deployment_name' is set
        if ('deployment_name' not in local_var_params or
                local_var_params['deployment_name'] is None):
            raise ApiValueError("Missing the required parameter `deployment_name` when calling `logs`")  # noqa: E501
        # verify the required parameter 'version_name' is set
        if ('version_name' not in local_var_params or
                local_var_params['version_name'] is None):
            raise ApiValueError("Missing the required parameter `version_name` when calling `logs`")  # noqa: E501
        # verify the required parameter 'model_name' is set
        if ('model_name' not in local_var_params or
                local_var_params['model_name'] is None):
            raise ApiValueError("Missing the required parameter `model_name` when calling `logs`")  # noqa: E501
        # verify the required parameter 'log_request' is set
        if ('log_request' not in local_var_params or
                local_var_params['log_request'] is None):
            raise ApiValueError("Missing the required parameter `log_request` when calling `logs`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'deployment_name' in local_var_params:
            path_params['deploymentName'] = local_var_params['deployment_name']  # noqa: E501
        if 'version_name' in local_var_params:
            path_params['versionName'] = local_var_params['version_name']  # noqa: E501
        if 'model_name' in local_var_params:
            path_params['modelName'] = local_var_params['model_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'log_request' in local_var_params:
            body_params = local_var_params['log_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/endpoints/{deploymentName}/model/{modelName}/{versionName}/logs', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogBatch',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def meta_get(self, deployment_name, version_name, model_name, **kwargs):  # noqa: E501
        """this method can be used to get the meta data for the current model which set to the server  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.meta_get(deployment_name, version_name, model_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str model_name: ID or name of the deployed model (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.meta_get_with_http_info(deployment_name, version_name, model_name, **kwargs)  # noqa: E501

    def meta_get_with_http_info(self, deployment_name, version_name, model_name, **kwargs):  # noqa: E501
        """this method can be used to get the meta data for the current model which set to the server  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.meta_get_with_http_info(deployment_name, version_name, model_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str model_name: ID or name of the deployed model (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['deployment_name', 'version_name', 'model_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method meta_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'deployment_name' is set
        if ('deployment_name' not in local_var_params or
                local_var_params['deployment_name'] is None):
            raise ApiValueError("Missing the required parameter `deployment_name` when calling `meta_get`")  # noqa: E501
        # verify the required parameter 'version_name' is set
        if ('version_name' not in local_var_params or
                local_var_params['version_name'] is None):
            raise ApiValueError("Missing the required parameter `version_name` when calling `meta_get`")  # noqa: E501
        # verify the required parameter 'model_name' is set
        if ('model_name' not in local_var_params or
                local_var_params['model_name'] is None):
            raise ApiValueError("Missing the required parameter `model_name` when calling `meta_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'deployment_name' in local_var_params:
            path_params['deploymentName'] = local_var_params['deployment_name']  # noqa: E501
        if 'version_name' in local_var_params:
            path_params['versionName'] = local_var_params['version_name']  # noqa: E501
        if 'model_name' in local_var_params:
            path_params['modelName'] = local_var_params['model_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/endpoints/{deploymentName}/model/{modelName}/{versionName}/meta', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def meta_post(self, content_type, deployment_name, version_name, model_name, body, **kwargs):  # noqa: E501
        """This method can be used to set meta data for the current model which is set to the server  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.meta_post(content_type, deployment_name, version_name, model_name, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str content_type: The `Content-Type` should always be `application/json` (required)
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str model_name: ID or name of the deployed model (required)
        :param str body: the meta data object (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.meta_post_with_http_info(content_type, deployment_name, version_name, model_name, body, **kwargs)  # noqa: E501

    def meta_post_with_http_info(self, content_type, deployment_name, version_name, model_name, body, **kwargs):  # noqa: E501
        """This method can be used to set meta data for the current model which is set to the server  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.meta_post_with_http_info(content_type, deployment_name, version_name, model_name, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str content_type: The `Content-Type` should always be `application/json` (required)
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str model_name: ID or name of the deployed model (required)
        :param str body: the meta data object (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['content_type', 'deployment_name', 'version_name', 'model_name', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method meta_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'content_type' is set
        if ('content_type' not in local_var_params or
                local_var_params['content_type'] is None):
            raise ApiValueError("Missing the required parameter `content_type` when calling `meta_post`")  # noqa: E501
        # verify the required parameter 'deployment_name' is set
        if ('deployment_name' not in local_var_params or
                local_var_params['deployment_name'] is None):
            raise ApiValueError("Missing the required parameter `deployment_name` when calling `meta_post`")  # noqa: E501
        # verify the required parameter 'version_name' is set
        if ('version_name' not in local_var_params or
                local_var_params['version_name'] is None):
            raise ApiValueError("Missing the required parameter `version_name` when calling `meta_post`")  # noqa: E501
        # verify the required parameter 'model_name' is set
        if ('model_name' not in local_var_params or
                local_var_params['model_name'] is None):
            raise ApiValueError("Missing the required parameter `model_name` when calling `meta_post`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in local_var_params or
                local_var_params['body'] is None):
            raise ApiValueError("Missing the required parameter `body` when calling `meta_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'deployment_name' in local_var_params:
            path_params['deploymentName'] = local_var_params['deployment_name']  # noqa: E501
        if 'version_name' in local_var_params:
            path_params['versionName'] = local_var_params['version_name']  # noqa: E501
        if 'model_name' in local_var_params:
            path_params['modelName'] = local_var_params['model_name']  # noqa: E501

        query_params = []

        header_params = {}
        if 'content_type' in local_var_params:
            header_params['Content-Type'] = local_var_params['content_type']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/endpoints/{deploymentName}/model/{modelName}/{versionName}/meta', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def model_state_change(self, deployment_id, model_id, body, **kwargs):  # noqa: E501
        """Modify the state (start/stop) of a deployed model  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.model_state_change(deployment_id, model_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str deployment_id: ID deployment group (required)
        :param str model_id: the id of the deployed model (required)
        :param SetState body: the model state object (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ModelEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.model_state_change_with_http_info(deployment_id, model_id, body, **kwargs)  # noqa: E501

    def model_state_change_with_http_info(self, deployment_id, model_id, body, **kwargs):  # noqa: E501
        """Modify the state (start/stop) of a deployed model  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.model_state_change_with_http_info(deployment_id, model_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str deployment_id: ID deployment group (required)
        :param str model_id: the id of the deployed model (required)
        :param SetState body: the model state object (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ModelEntity, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['deployment_id', 'model_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method model_state_change" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'deployment_id' is set
        if ('deployment_id' not in local_var_params or
                local_var_params['deployment_id'] is None):
            raise ApiValueError("Missing the required parameter `deployment_id` when calling `model_state_change`")  # noqa: E501
        # verify the required parameter 'model_id' is set
        if ('model_id' not in local_var_params or
                local_var_params['model_id'] is None):
            raise ApiValueError("Missing the required parameter `model_id` when calling `model_state_change`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in local_var_params or
                local_var_params['body'] is None):
            raise ApiValueError("Missing the required parameter `body` when calling `model_state_change`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'deployment_id' in local_var_params:
            path_params['deploymentId'] = local_var_params['deployment_id']  # noqa: E501
        if 'model_id' in local_var_params:
            path_params['modelId'] = local_var_params['model_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/deployment/{deploymentId}/model/{modelId}/state', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ModelEntity',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def models(self, deployment_id, **kwargs):  # noqa: E501
        """Retrieve a list of all the deployed models given a deployment id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.models(deployment_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str deployment_id: ID deployment group (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: list[ModelEntity]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.models_with_http_info(deployment_id, **kwargs)  # noqa: E501

    def models_with_http_info(self, deployment_id, **kwargs):  # noqa: E501
        """Retrieve a list of all the deployed models given a deployment id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.models_with_http_info(deployment_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str deployment_id: ID deployment group (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(list[ModelEntity], status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['deployment_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method models" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'deployment_id' is set
        if ('deployment_id' not in local_var_params or
                local_var_params['deployment_id'] is None):
            raise ApiValueError("Missing the required parameter `deployment_id` when calling `models`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'deployment_id' in local_var_params:
            path_params['deploymentId'] = local_var_params['deployment_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/deployment/{deploymentId}/models', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ModelEntity]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def modelset(self, deployment_name, version_name, model_name, **kwargs):  # noqa: E501
        """Set the model to be served  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.modelset(deployment_name, version_name, model_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str model_name: ID or name of the deployed model (required)
        :param file file: The model file to upload (.pb file)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ModelStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.modelset_with_http_info(deployment_name, version_name, model_name, **kwargs)  # noqa: E501

    def modelset_with_http_info(self, deployment_name, version_name, model_name, **kwargs):  # noqa: E501
        """Set the model to be served  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.modelset_with_http_info(deployment_name, version_name, model_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str model_name: ID or name of the deployed model (required)
        :param file file: The model file to upload (.pb file)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ModelStatus, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['deployment_name', 'version_name', 'model_name', 'file']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method modelset" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'deployment_name' is set
        if ('deployment_name' not in local_var_params or
                local_var_params['deployment_name'] is None):
            raise ApiValueError("Missing the required parameter `deployment_name` when calling `modelset`")  # noqa: E501
        # verify the required parameter 'version_name' is set
        if ('version_name' not in local_var_params or
                local_var_params['version_name'] is None):
            raise ApiValueError("Missing the required parameter `version_name` when calling `modelset`")  # noqa: E501
        # verify the required parameter 'model_name' is set
        if ('model_name' not in local_var_params or
                local_var_params['model_name'] is None):
            raise ApiValueError("Missing the required parameter `model_name` when calling `modelset`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'deployment_name' in local_var_params:
            path_params['deploymentName'] = local_var_params['deployment_name']  # noqa: E501
        if 'version_name' in local_var_params:
            path_params['versionName'] = local_var_params['version_name']  # noqa: E501
        if 'model_name' in local_var_params:
            path_params['modelName'] = local_var_params['model_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'file' in local_var_params:
            local_var_files['file'] = local_var_params['file']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/endpoints/{deploymentName}/model/{modelName}/{versionName}/modelset', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ModelStatus',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def modelupdate(self, deployment_name, version_name, model_name, file, **kwargs):  # noqa: E501
        """Update the model to be served  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.modelupdate(deployment_name, version_name, model_name, file, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str model_name: ID or name of the deployed model (required)
        :param file file: The model file to update with (.pb file) (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ModelStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.modelupdate_with_http_info(deployment_name, version_name, model_name, file, **kwargs)  # noqa: E501

    def modelupdate_with_http_info(self, deployment_name, version_name, model_name, file, **kwargs):  # noqa: E501
        """Update the model to be served  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.modelupdate_with_http_info(deployment_name, version_name, model_name, file, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str model_name: ID or name of the deployed model (required)
        :param file file: The model file to update with (.pb file) (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ModelStatus, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['deployment_name', 'version_name', 'model_name', 'file']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method modelupdate" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'deployment_name' is set
        if ('deployment_name' not in local_var_params or
                local_var_params['deployment_name'] is None):
            raise ApiValueError("Missing the required parameter `deployment_name` when calling `modelupdate`")  # noqa: E501
        # verify the required parameter 'version_name' is set
        if ('version_name' not in local_var_params or
                local_var_params['version_name'] is None):
            raise ApiValueError("Missing the required parameter `version_name` when calling `modelupdate`")  # noqa: E501
        # verify the required parameter 'model_name' is set
        if ('model_name' not in local_var_params or
                local_var_params['model_name'] is None):
            raise ApiValueError("Missing the required parameter `model_name` when calling `modelupdate`")  # noqa: E501
        # verify the required parameter 'file' is set
        if ('file' not in local_var_params or
                local_var_params['file'] is None):
            raise ApiValueError("Missing the required parameter `file` when calling `modelupdate`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'deployment_name' in local_var_params:
            path_params['deploymentName'] = local_var_params['deployment_name']  # noqa: E501
        if 'version_name' in local_var_params:
            path_params['versionName'] = local_var_params['version_name']  # noqa: E501
        if 'model_name' in local_var_params:
            path_params['modelName'] = local_var_params['model_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'file' in local_var_params:
            local_var_files['file'] = local_var_params['file']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/endpoints/{deploymentName}/model/{modelName}/{versionName}/modelupdate', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ModelStatus',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def multiclassify(self, deployment_name, version_name, model_name, body, **kwargs):  # noqa: E501
        """Represents all of the labels for a given classification  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.multiclassify(deployment_name, version_name, model_name, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str model_name: ID or name of the deployed model (required)
        :param Prediction body: The input NDArray (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: MultiClassClassificationResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.multiclassify_with_http_info(deployment_name, version_name, model_name, body, **kwargs)  # noqa: E501

    def multiclassify_with_http_info(self, deployment_name, version_name, model_name, body, **kwargs):  # noqa: E501
        """Represents all of the labels for a given classification  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.multiclassify_with_http_info(deployment_name, version_name, model_name, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str model_name: ID or name of the deployed model (required)
        :param Prediction body: The input NDArray (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(MultiClassClassificationResult, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['deployment_name', 'version_name', 'model_name', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method multiclassify" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'deployment_name' is set
        if ('deployment_name' not in local_var_params or
                local_var_params['deployment_name'] is None):
            raise ApiValueError("Missing the required parameter `deployment_name` when calling `multiclassify`")  # noqa: E501
        # verify the required parameter 'version_name' is set
        if ('version_name' not in local_var_params or
                local_var_params['version_name'] is None):
            raise ApiValueError("Missing the required parameter `version_name` when calling `multiclassify`")  # noqa: E501
        # verify the required parameter 'model_name' is set
        if ('model_name' not in local_var_params or
                local_var_params['model_name'] is None):
            raise ApiValueError("Missing the required parameter `model_name` when calling `multiclassify`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in local_var_params or
                local_var_params['body'] is None):
            raise ApiValueError("Missing the required parameter `body` when calling `multiclassify`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'deployment_name' in local_var_params:
            path_params['deploymentName'] = local_var_params['deployment_name']  # noqa: E501
        if 'version_name' in local_var_params:
            path_params['versionName'] = local_var_params['version_name']  # noqa: E501
        if 'model_name' in local_var_params:
            path_params['modelName'] = local_var_params['model_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/endpoints/{deploymentName}/model/{modelName}/{versionName}/multiclassify', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MultiClassClassificationResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def multipredict(self, deployment_name, version_name, model_name, body, **kwargs):  # noqa: E501
        """Get the output from the network, based on the given INDArray[] input  # noqa: E501

        Networks with multiple input/output are supported via this method. A Normalizer will be used if needsPreProcessing is set to true. The output/returned array of INDArray will be the raw predictions, and consequently this method can be used for classification or regression networks, with any type of output layer (standard, time series / RnnOutputLayer, etc).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.multipredict(deployment_name, version_name, model_name, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str model_name: ID or name of the deployed model (required)
        :param MultiPredictRequest body: The multiple input arrays with mask inputs to run inferences on (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: MultiPredictResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.multipredict_with_http_info(deployment_name, version_name, model_name, body, **kwargs)  # noqa: E501

    def multipredict_with_http_info(self, deployment_name, version_name, model_name, body, **kwargs):  # noqa: E501
        """Get the output from the network, based on the given INDArray[] input  # noqa: E501

        Networks with multiple input/output are supported via this method. A Normalizer will be used if needsPreProcessing is set to true. The output/returned array of INDArray will be the raw predictions, and consequently this method can be used for classification or regression networks, with any type of output layer (standard, time series / RnnOutputLayer, etc).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.multipredict_with_http_info(deployment_name, version_name, model_name, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str model_name: ID or name of the deployed model (required)
        :param MultiPredictRequest body: The multiple input arrays with mask inputs to run inferences on (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(MultiPredictResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['deployment_name', 'version_name', 'model_name', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method multipredict" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'deployment_name' is set
        if ('deployment_name' not in local_var_params or
                local_var_params['deployment_name'] is None):
            raise ApiValueError("Missing the required parameter `deployment_name` when calling `multipredict`")  # noqa: E501
        # verify the required parameter 'version_name' is set
        if ('version_name' not in local_var_params or
                local_var_params['version_name'] is None):
            raise ApiValueError("Missing the required parameter `version_name` when calling `multipredict`")  # noqa: E501
        # verify the required parameter 'model_name' is set
        if ('model_name' not in local_var_params or
                local_var_params['model_name'] is None):
            raise ApiValueError("Missing the required parameter `model_name` when calling `multipredict`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in local_var_params or
                local_var_params['body'] is None):
            raise ApiValueError("Missing the required parameter `body` when calling `multipredict`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'deployment_name' in local_var_params:
            path_params['deploymentName'] = local_var_params['deployment_name']  # noqa: E501
        if 'version_name' in local_var_params:
            path_params['versionName'] = local_var_params['version_name']  # noqa: E501
        if 'model_name' in local_var_params:
            path_params['modelName'] = local_var_params['model_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/endpoints/{deploymentName}/model/{modelName}/{versionName}/multipredict', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MultiPredictResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def multipredictimage(self, deployment_name, version_name, model_name, file, id, needs_preprocessing, **kwargs):  # noqa: E501
        """Get the output from the network using the given image file using the /multipredict endpoint's method  # noqa: E501

        Networks with multiple input/output are supported via this method. A Normalizer will be used if needsPreProcessing is set to true. The output/returned array of INDArray will be the raw predictions, and consequently this method can be used for classification or regression networks, with any type of output layer (standard, time series / RnnOutputLayer, etc).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.multipredictimage(deployment_name, version_name, model_name, file, id, needs_preprocessing, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str model_name: ID or name of the deployed model (required)
        :param file file: The image file to run the prediction on (required)
        :param str id: The id of the request (could be self generated) (required)
        :param bool needs_preprocessing: Whether or not the preprocessing is required (either 'true' or 'false') (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: MultiPredictResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.multipredictimage_with_http_info(deployment_name, version_name, model_name, file, id, needs_preprocessing, **kwargs)  # noqa: E501

    def multipredictimage_with_http_info(self, deployment_name, version_name, model_name, file, id, needs_preprocessing, **kwargs):  # noqa: E501
        """Get the output from the network using the given image file using the /multipredict endpoint's method  # noqa: E501

        Networks with multiple input/output are supported via this method. A Normalizer will be used if needsPreProcessing is set to true. The output/returned array of INDArray will be the raw predictions, and consequently this method can be used for classification or regression networks, with any type of output layer (standard, time series / RnnOutputLayer, etc).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.multipredictimage_with_http_info(deployment_name, version_name, model_name, file, id, needs_preprocessing, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str model_name: ID or name of the deployed model (required)
        :param file file: The image file to run the prediction on (required)
        :param str id: The id of the request (could be self generated) (required)
        :param bool needs_preprocessing: Whether or not the preprocessing is required (either 'true' or 'false') (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(MultiPredictResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['deployment_name', 'version_name', 'model_name', 'file', 'id', 'needs_preprocessing']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method multipredictimage" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'deployment_name' is set
        if ('deployment_name' not in local_var_params or
                local_var_params['deployment_name'] is None):
            raise ApiValueError("Missing the required parameter `deployment_name` when calling `multipredictimage`")  # noqa: E501
        # verify the required parameter 'version_name' is set
        if ('version_name' not in local_var_params or
                local_var_params['version_name'] is None):
            raise ApiValueError("Missing the required parameter `version_name` when calling `multipredictimage`")  # noqa: E501
        # verify the required parameter 'model_name' is set
        if ('model_name' not in local_var_params or
                local_var_params['model_name'] is None):
            raise ApiValueError("Missing the required parameter `model_name` when calling `multipredictimage`")  # noqa: E501
        # verify the required parameter 'file' is set
        if ('file' not in local_var_params or
                local_var_params['file'] is None):
            raise ApiValueError("Missing the required parameter `file` when calling `multipredictimage`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in local_var_params or
                local_var_params['id'] is None):
            raise ApiValueError("Missing the required parameter `id` when calling `multipredictimage`")  # noqa: E501
        # verify the required parameter 'needs_preprocessing' is set
        if ('needs_preprocessing' not in local_var_params or
                local_var_params['needs_preprocessing'] is None):
            raise ApiValueError("Missing the required parameter `needs_preprocessing` when calling `multipredictimage`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'deployment_name' in local_var_params:
            path_params['deploymentName'] = local_var_params['deployment_name']  # noqa: E501
        if 'version_name' in local_var_params:
            path_params['versionName'] = local_var_params['version_name']  # noqa: E501
        if 'model_name' in local_var_params:
            path_params['modelName'] = local_var_params['model_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'file' in local_var_params:
            local_var_files['file'] = local_var_params['file']  # noqa: E501
        if 'id' in local_var_params:
            form_params.append(('id', local_var_params['id']))  # noqa: E501
        if 'needs_preprocessing' in local_var_params:
            form_params.append(('needs_preprocessing', local_var_params['needs_preprocessing']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/endpoints/{deploymentName}/model/{modelName}/{versionName}/multipredictimage', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MultiPredictResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def num_revisions(self, **kwargs):  # noqa: E501
        """Gets the number of retrained models written with retraining.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.num_revisions(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: RevisionsWritten
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.num_revisions_with_http_info(**kwargs)  # noqa: E501

    def num_revisions_with_http_info(self, **kwargs):  # noqa: E501
        """Gets the number of retrained models written with retraining.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.num_revisions_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(RevisionsWritten, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method num_revisions" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/numrevisions', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RevisionsWritten',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def predict(self, deployment_name, version_name, model_name, body, **kwargs):  # noqa: E501
        """Run inference on the input array.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.predict(deployment_name, version_name, model_name, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str model_name: ID or name of the deployed model (required)
        :param Prediction body: The input NDArray (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Prediction
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.predict_with_http_info(deployment_name, version_name, model_name, body, **kwargs)  # noqa: E501

    def predict_with_http_info(self, deployment_name, version_name, model_name, body, **kwargs):  # noqa: E501
        """Run inference on the input array.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.predict_with_http_info(deployment_name, version_name, model_name, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str model_name: ID or name of the deployed model (required)
        :param Prediction body: The input NDArray (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Prediction, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['deployment_name', 'version_name', 'model_name', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method predict" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'deployment_name' is set
        if ('deployment_name' not in local_var_params or
                local_var_params['deployment_name'] is None):
            raise ApiValueError("Missing the required parameter `deployment_name` when calling `predict`")  # noqa: E501
        # verify the required parameter 'version_name' is set
        if ('version_name' not in local_var_params or
                local_var_params['version_name'] is None):
            raise ApiValueError("Missing the required parameter `version_name` when calling `predict`")  # noqa: E501
        # verify the required parameter 'model_name' is set
        if ('model_name' not in local_var_params or
                local_var_params['model_name'] is None):
            raise ApiValueError("Missing the required parameter `model_name` when calling `predict`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in local_var_params or
                local_var_params['body'] is None):
            raise ApiValueError("Missing the required parameter `body` when calling `predict`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'deployment_name' in local_var_params:
            path_params['deploymentName'] = local_var_params['deployment_name']  # noqa: E501
        if 'version_name' in local_var_params:
            path_params['versionName'] = local_var_params['version_name']  # noqa: E501
        if 'model_name' in local_var_params:
            path_params['modelName'] = local_var_params['model_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/endpoints/{deploymentName}/model/{modelName}/{versionName}/predict', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Prediction',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def predict_error(self, content_type, operation, input_type, **kwargs):  # noqa: E501
        """Runs inference and find invalid rows based on the input data. Output is defined relative to the output adapter specified.  # noqa: E501

        These \"error\" endpoints are slower for inference, but will also ignore invalid rows that are found. They will output skipped rows where errors were encountered so users can fix problems with input data pipelines.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.predict_error(content_type, operation, input_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str content_type: The `Content-Type` should always be `application/json`. (required)
        :param str operation: Operation to perform on the input data. (required)
        :param str input_type: Type of the input data. (required)
        :param str input_data:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.predict_error_with_http_info(content_type, operation, input_type, **kwargs)  # noqa: E501

    def predict_error_with_http_info(self, content_type, operation, input_type, **kwargs):  # noqa: E501
        """Runs inference and find invalid rows based on the input data. Output is defined relative to the output adapter specified.  # noqa: E501

        These \"error\" endpoints are slower for inference, but will also ignore invalid rows that are found. They will output skipped rows where errors were encountered so users can fix problems with input data pipelines.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.predict_error_with_http_info(content_type, operation, input_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str content_type: The `Content-Type` should always be `application/json`. (required)
        :param str operation: Operation to perform on the input data. (required)
        :param str input_type: Type of the input data. (required)
        :param str input_data:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['content_type', 'operation', 'input_type', 'input_data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method predict_error" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'content_type' is set
        if ('content_type' not in local_var_params or
                local_var_params['content_type'] is None):
            raise ApiValueError("Missing the required parameter `content_type` when calling `predict_error`")  # noqa: E501
        # verify the required parameter 'operation' is set
        if ('operation' not in local_var_params or
                local_var_params['operation'] is None):
            raise ApiValueError("Missing the required parameter `operation` when calling `predict_error`")  # noqa: E501
        # verify the required parameter 'input_type' is set
        if ('input_type' not in local_var_params or
                local_var_params['input_type'] is None):
            raise ApiValueError("Missing the required parameter `input_type` when calling `predict_error`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'operation' in local_var_params:
            path_params['operation'] = local_var_params['operation']  # noqa: E501
        if 'input_type' in local_var_params:
            path_params['inputType'] = local_var_params['input_type']  # noqa: E501

        query_params = []

        header_params = {}
        if 'content_type' in local_var_params:
            header_params['Content-Type'] = local_var_params['content_type']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'input_data' in local_var_params:
            body_params = local_var_params['input_data']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/{operation}/{inputType}/error', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def predict_v2_file(self, operation, input_type_file, input_data, **kwargs):  # noqa: E501
        """Runs inference based on the input data. Output is defined relative to the output adapter specified.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.predict_v2_file(operation, input_type_file, input_data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str operation: The operation to perform on the input data.  (required)
        :param str input_type_file: Type of the input data.  (required)
        :param file input_data: The input data to run inference on. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.predict_v2_file_with_http_info(operation, input_type_file, input_data, **kwargs)  # noqa: E501

    def predict_v2_file_with_http_info(self, operation, input_type_file, input_data, **kwargs):  # noqa: E501
        """Runs inference based on the input data. Output is defined relative to the output adapter specified.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.predict_v2_file_with_http_info(operation, input_type_file, input_data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str operation: The operation to perform on the input data.  (required)
        :param str input_type_file: Type of the input data.  (required)
        :param file input_data: The input data to run inference on. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['operation', 'input_type_file', 'input_data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method predict_v2_file" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'operation' is set
        if ('operation' not in local_var_params or
                local_var_params['operation'] is None):
            raise ApiValueError("Missing the required parameter `operation` when calling `predict_v2_file`")  # noqa: E501
        # verify the required parameter 'input_type_file' is set
        if ('input_type_file' not in local_var_params or
                local_var_params['input_type_file'] is None):
            raise ApiValueError("Missing the required parameter `input_type_file` when calling `predict_v2_file`")  # noqa: E501
        # verify the required parameter 'input_data' is set
        if ('input_data' not in local_var_params or
                local_var_params['input_data'] is None):
            raise ApiValueError("Missing the required parameter `input_data` when calling `predict_v2_file`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'operation' in local_var_params:
            path_params['operation'] = local_var_params['operation']  # noqa: E501
        if 'input_type_file' in local_var_params:
            path_params['inputTypeFile'] = local_var_params['input_type_file']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'input_data' in local_var_params:
            local_var_files['inputData'] = local_var_params['input_data']  # noqa: E501

        body_params = None
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/{operation}/{inputTypeFile}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def predict_v2_json(self, content_type, operation, input_type_json, input_data, **kwargs):  # noqa: E501
        """Runs inference based on the input data. Output is defined relative to the output adapter specified.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.predict_v2_json(content_type, operation, input_type_json, input_data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str content_type: The `Content-Type` should always be `application/json`. (required)
        :param str operation: The operation to perform on the input data.  (required)
        :param str input_type_json: Type of the input data.  (required)
        :param str input_data: The input data to run inference on. (Specify a JSON string here) (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.predict_v2_json_with_http_info(content_type, operation, input_type_json, input_data, **kwargs)  # noqa: E501

    def predict_v2_json_with_http_info(self, content_type, operation, input_type_json, input_data, **kwargs):  # noqa: E501
        """Runs inference based on the input data. Output is defined relative to the output adapter specified.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.predict_v2_json_with_http_info(content_type, operation, input_type_json, input_data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str content_type: The `Content-Type` should always be `application/json`. (required)
        :param str operation: The operation to perform on the input data.  (required)
        :param str input_type_json: Type of the input data.  (required)
        :param str input_data: The input data to run inference on. (Specify a JSON string here) (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['content_type', 'operation', 'input_type_json', 'input_data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method predict_v2_json" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'content_type' is set
        if ('content_type' not in local_var_params or
                local_var_params['content_type'] is None):
            raise ApiValueError("Missing the required parameter `content_type` when calling `predict_v2_json`")  # noqa: E501
        # verify the required parameter 'operation' is set
        if ('operation' not in local_var_params or
                local_var_params['operation'] is None):
            raise ApiValueError("Missing the required parameter `operation` when calling `predict_v2_json`")  # noqa: E501
        # verify the required parameter 'input_type_json' is set
        if ('input_type_json' not in local_var_params or
                local_var_params['input_type_json'] is None):
            raise ApiValueError("Missing the required parameter `input_type_json` when calling `predict_v2_json`")  # noqa: E501
        # verify the required parameter 'input_data' is set
        if ('input_data' not in local_var_params or
                local_var_params['input_data'] is None):
            raise ApiValueError("Missing the required parameter `input_data` when calling `predict_v2_json`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'operation' in local_var_params:
            path_params['operation'] = local_var_params['operation']  # noqa: E501
        if 'input_type_json' in local_var_params:
            path_params['inputTypeJson'] = local_var_params['input_type_json']  # noqa: E501

        query_params = []

        header_params = {}
        if 'content_type' in local_var_params:
            header_params['Content-Type'] = local_var_params['content_type']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'input_data' in local_var_params:
            body_params = local_var_params['input_data']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/{operation}/{inputTypeJson}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def predictimage(self, deployment_name, version_name, model_name, **kwargs):  # noqa: E501
        """Run inference on the input array, using input image file from multipart form data.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.predictimage(deployment_name, version_name, model_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str model_name: ID or name of the deployed model (required)
        :param file image: The file to upload.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Prediction
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.predictimage_with_http_info(deployment_name, version_name, model_name, **kwargs)  # noqa: E501

    def predictimage_with_http_info(self, deployment_name, version_name, model_name, **kwargs):  # noqa: E501
        """Run inference on the input array, using input image file from multipart form data.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.predictimage_with_http_info(deployment_name, version_name, model_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str model_name: ID or name of the deployed model (required)
        :param file image: The file to upload.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Prediction, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['deployment_name', 'version_name', 'model_name', 'image']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method predictimage" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'deployment_name' is set
        if ('deployment_name' not in local_var_params or
                local_var_params['deployment_name'] is None):
            raise ApiValueError("Missing the required parameter `deployment_name` when calling `predictimage`")  # noqa: E501
        # verify the required parameter 'version_name' is set
        if ('version_name' not in local_var_params or
                local_var_params['version_name'] is None):
            raise ApiValueError("Missing the required parameter `version_name` when calling `predictimage`")  # noqa: E501
        # verify the required parameter 'model_name' is set
        if ('model_name' not in local_var_params or
                local_var_params['model_name'] is None):
            raise ApiValueError("Missing the required parameter `model_name` when calling `predictimage`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'deployment_name' in local_var_params:
            path_params['deploymentName'] = local_var_params['deployment_name']  # noqa: E501
        if 'version_name' in local_var_params:
            path_params['versionName'] = local_var_params['version_name']  # noqa: E501
        if 'model_name' in local_var_params:
            path_params['modelName'] = local_var_params['model_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'image' in local_var_params:
            local_var_files['image'] = local_var_params['image']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/endpoints/{deploymentName}/model/{modelName}/{versionName}/predictimage', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Prediction',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def predictwithpreprocess(self, deployment_name, version_name, model_name, body, **kwargs):  # noqa: E501
        """Preprocesses the input and run inference on it  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.predictwithpreprocess(deployment_name, version_name, model_name, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str model_name: ID or name of the deployed model (required)
        :param list[str] body: The input array (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Prediction
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.predictwithpreprocess_with_http_info(deployment_name, version_name, model_name, body, **kwargs)  # noqa: E501

    def predictwithpreprocess_with_http_info(self, deployment_name, version_name, model_name, body, **kwargs):  # noqa: E501
        """Preprocesses the input and run inference on it  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.predictwithpreprocess_with_http_info(deployment_name, version_name, model_name, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str model_name: ID or name of the deployed model (required)
        :param list[str] body: The input array (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Prediction, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['deployment_name', 'version_name', 'model_name', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method predictwithpreprocess" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'deployment_name' is set
        if ('deployment_name' not in local_var_params or
                local_var_params['deployment_name'] is None):
            raise ApiValueError("Missing the required parameter `deployment_name` when calling `predictwithpreprocess`")  # noqa: E501
        # verify the required parameter 'version_name' is set
        if ('version_name' not in local_var_params or
                local_var_params['version_name'] is None):
            raise ApiValueError("Missing the required parameter `version_name` when calling `predictwithpreprocess`")  # noqa: E501
        # verify the required parameter 'model_name' is set
        if ('model_name' not in local_var_params or
                local_var_params['model_name'] is None):
            raise ApiValueError("Missing the required parameter `model_name` when calling `predictwithpreprocess`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in local_var_params or
                local_var_params['body'] is None):
            raise ApiValueError("Missing the required parameter `body` when calling `predictwithpreprocess`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'deployment_name' in local_var_params:
            path_params['deploymentName'] = local_var_params['deployment_name']  # noqa: E501
        if 'version_name' in local_var_params:
            path_params['versionName'] = local_var_params['version_name']  # noqa: E501
        if 'model_name' in local_var_params:
            path_params['modelName'] = local_var_params['model_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/endpoints/{deploymentName}/model/{modelName}/{versionName}/predictwithpreprocess', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Prediction',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def predictwithpreprocessjson(self, deployment_name, version_name, model_name, body, **kwargs):  # noqa: E501
        """Preprocesses the input and run inference on it and returns it as a JsonArrayResponse  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.predictwithpreprocessjson(deployment_name, version_name, model_name, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str model_name: ID or name of the deployed model (required)
        :param list[str] body: The input array (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: JsonArrayResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.predictwithpreprocessjson_with_http_info(deployment_name, version_name, model_name, body, **kwargs)  # noqa: E501

    def predictwithpreprocessjson_with_http_info(self, deployment_name, version_name, model_name, body, **kwargs):  # noqa: E501
        """Preprocesses the input and run inference on it and returns it as a JsonArrayResponse  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.predictwithpreprocessjson_with_http_info(deployment_name, version_name, model_name, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str model_name: ID or name of the deployed model (required)
        :param list[str] body: The input array (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(JsonArrayResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['deployment_name', 'version_name', 'model_name', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method predictwithpreprocessjson" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'deployment_name' is set
        if ('deployment_name' not in local_var_params or
                local_var_params['deployment_name'] is None):
            raise ApiValueError("Missing the required parameter `deployment_name` when calling `predictwithpreprocessjson`")  # noqa: E501
        # verify the required parameter 'version_name' is set
        if ('version_name' not in local_var_params or
                local_var_params['version_name'] is None):
            raise ApiValueError("Missing the required parameter `version_name` when calling `predictwithpreprocessjson`")  # noqa: E501
        # verify the required parameter 'model_name' is set
        if ('model_name' not in local_var_params or
                local_var_params['model_name'] is None):
            raise ApiValueError("Missing the required parameter `model_name` when calling `predictwithpreprocessjson`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in local_var_params or
                local_var_params['body'] is None):
            raise ApiValueError("Missing the required parameter `body` when calling `predictwithpreprocessjson`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'deployment_name' in local_var_params:
            path_params['deploymentName'] = local_var_params['deployment_name']  # noqa: E501
        if 'version_name' in local_var_params:
            path_params['versionName'] = local_var_params['version_name']  # noqa: E501
        if 'model_name' in local_var_params:
            path_params['modelName'] = local_var_params['model_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/endpoints/{deploymentName}/model/{modelName}/{versionName}/predictwithpreprocessjson', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='JsonArrayResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def raw_predict_binary(self, input_type, output_type, **kwargs):  # noqa: E501
        """Runs inference based on the input data. Output is defined relative to the output adapter specified.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.raw_predict_binary(input_type, output_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str input_type: Input data type. (required)
        :param str output_type: Binary output data type. (required)
        :param file input_data: The input file to upload.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.raw_predict_binary_with_http_info(input_type, output_type, **kwargs)  # noqa: E501

    def raw_predict_binary_with_http_info(self, input_type, output_type, **kwargs):  # noqa: E501
        """Runs inference based on the input data. Output is defined relative to the output adapter specified.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.raw_predict_binary_with_http_info(input_type, output_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str input_type: Input data type. (required)
        :param str output_type: Binary output data type. (required)
        :param file input_data: The input file to upload.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['input_type', 'output_type', 'input_data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method raw_predict_binary" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'input_type' is set
        if ('input_type' not in local_var_params or
                local_var_params['input_type'] is None):
            raise ApiValueError("Missing the required parameter `input_type` when calling `raw_predict_binary`")  # noqa: E501
        # verify the required parameter 'output_type' is set
        if ('output_type' not in local_var_params or
                local_var_params['output_type'] is None):
            raise ApiValueError("Missing the required parameter `output_type` when calling `raw_predict_binary`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'input_type' in local_var_params:
            path_params['inputType'] = local_var_params['input_type']  # noqa: E501
        if 'output_type' in local_var_params:
            path_params['outputType'] = local_var_params['output_type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'input_data' in local_var_params:
            local_var_files['inputData'] = local_var_params['input_data']  # noqa: E501

        body_params = None
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/raw/{inputType}/{outputType}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def refresh_job_status(self, job_id, **kwargs):  # noqa: E501
        """Refresh the remote job status. Can be used for monitoring.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.refresh_job_status(job_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int job_id: Job ID (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: JobEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.refresh_job_status_with_http_info(job_id, **kwargs)  # noqa: E501

    def refresh_job_status_with_http_info(self, job_id, **kwargs):  # noqa: E501
        """Refresh the remote job status. Can be used for monitoring.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.refresh_job_status_with_http_info(job_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int job_id: Job ID (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(JobEntity, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['job_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method refresh_job_status" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'job_id' is set
        if ('job_id' not in local_var_params or
                local_var_params['job_id'] is None):
            raise ApiValueError("Missing the required parameter `job_id` when calling `refresh_job_status`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'job_id' in local_var_params:
            path_params['jobId'] = local_var_params['job_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/jobs/{jobId}/refresh', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='JobEntity',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def register_user(self, user, **kwargs):  # noqa: E501
        """Register a new user  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.register_user(user, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param User user: User details (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: User
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.register_user_with_http_info(user, **kwargs)  # noqa: E501

    def register_user_with_http_info(self, user, **kwargs):  # noqa: E501
        """Register a new user  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.register_user_with_http_info(user, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param User user: User details (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(User, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['user']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method register_user" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'user' is set
        if ('user' not in local_var_params or
                local_var_params['user'] is None):
            raise ApiValueError("Missing the required parameter `user` when calling `register_user`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'user' in local_var_params:
            body_params = local_var_params['user']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/user/register', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='User',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def reimport_model(self, deployment_id, model_id, body, **kwargs):  # noqa: E501
        """Reimport a model to a previous deployed model in a deployment  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.reimport_model(deployment_id, model_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str deployment_id: ID deployment group (required)
        :param str model_id: the id of the deployed model (required)
        :param ImportModelRequest body: the deployment request (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ModelEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.reimport_model_with_http_info(deployment_id, model_id, body, **kwargs)  # noqa: E501

    def reimport_model_with_http_info(self, deployment_id, model_id, body, **kwargs):  # noqa: E501
        """Reimport a model to a previous deployed model in a deployment  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.reimport_model_with_http_info(deployment_id, model_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str deployment_id: ID deployment group (required)
        :param str model_id: the id of the deployed model (required)
        :param ImportModelRequest body: the deployment request (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ModelEntity, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['deployment_id', 'model_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method reimport_model" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'deployment_id' is set
        if ('deployment_id' not in local_var_params or
                local_var_params['deployment_id'] is None):
            raise ApiValueError("Missing the required parameter `deployment_id` when calling `reimport_model`")  # noqa: E501
        # verify the required parameter 'model_id' is set
        if ('model_id' not in local_var_params or
                local_var_params['model_id'] is None):
            raise ApiValueError("Missing the required parameter `model_id` when calling `reimport_model`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in local_var_params or
                local_var_params['body'] is None):
            raise ApiValueError("Missing the required parameter `body` when calling `reimport_model`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'deployment_id' in local_var_params:
            path_params['deploymentId'] = local_var_params['deployment_id']  # noqa: E501
        if 'model_id' in local_var_params:
            path_params['modelId'] = local_var_params['model_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/deployment/{deploymentId}/model/{modelId}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ModelEntity',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def revoke_user_token(self, token_id, **kwargs):  # noqa: E501
        """Revoke a user token.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.revoke_user_token(token_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int token_id: Token ID (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Token
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.revoke_user_token_with_http_info(token_id, **kwargs)  # noqa: E501

    def revoke_user_token_with_http_info(self, token_id, **kwargs):  # noqa: E501
        """Revoke a user token.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.revoke_user_token_with_http_info(token_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int token_id: Token ID (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Token, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['token_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method revoke_user_token" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'token_id' is set
        if ('token_id' not in local_var_params or
                local_var_params['token_id'] is None):
            raise ApiValueError("Missing the required parameter `token_id` when calling `revoke_user_token`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'token_id' in local_var_params:
            path_params['tokenId'] = local_var_params['token_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/auth/token/{tokenId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Token',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def rollback(self, index, **kwargs):  # noqa: E501
        """Rollback to a previous revision of the model.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.rollback(index, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int index: Model revision index. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: RollbackStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.rollback_with_http_info(index, **kwargs)  # noqa: E501

    def rollback_with_http_info(self, index, **kwargs):  # noqa: E501
        """Rollback to a previous revision of the model.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.rollback_with_http_info(index, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int index: Model revision index. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(RollbackStatus, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['index']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method rollback" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'index' is set
        if ('index' not in local_var_params or
                local_var_params['index'] is None):
            raise ApiValueError("Missing the required parameter `index` when calling `rollback`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'index' in local_var_params:
            path_params['index'] = local_var_params['index']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/rollback/{index}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RollbackStatus',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def run_a_job(self, job_id, **kwargs):  # noqa: E501
        """Start running an (already created) job on the remote resource  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.run_a_job(job_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int job_id: Job ID (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: JobEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.run_a_job_with_http_info(job_id, **kwargs)  # noqa: E501

    def run_a_job_with_http_info(self, job_id, **kwargs):  # noqa: E501
        """Start running an (already created) job on the remote resource  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.run_a_job_with_http_info(job_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int job_id: Job ID (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(JobEntity, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['job_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method run_a_job" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'job_id' is set
        if ('job_id' not in local_var_params or
                local_var_params['job_id'] is None):
            raise ApiValueError("Missing the required parameter `job_id` when calling `run_a_job`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'job_id' in local_var_params:
            path_params['jobId'] = local_var_params['job_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/jobs/{jobId}/run', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='JobEntity',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def transform_csv(self, deployment_name, version_name, transform_name, **kwargs):  # noqa: E501
        """Takes a BatchCSVRecord and returns the transformed array as BatchCSVRecord  # noqa: E501

        Takes a batch of SingleCSVRecord object and transforms it into the desired format  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.transform_csv(deployment_name, version_name, transform_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str transform_name: ID or name of the deployed transform (required)
        :param BatchCSVRecord batch_csv_record: The input batch of record arrays
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: BatchCSVRecord
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.transform_csv_with_http_info(deployment_name, version_name, transform_name, **kwargs)  # noqa: E501

    def transform_csv_with_http_info(self, deployment_name, version_name, transform_name, **kwargs):  # noqa: E501
        """Takes a BatchCSVRecord and returns the transformed array as BatchCSVRecord  # noqa: E501

        Takes a batch of SingleCSVRecord object and transforms it into the desired format  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.transform_csv_with_http_info(deployment_name, version_name, transform_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str transform_name: ID or name of the deployed transform (required)
        :param BatchCSVRecord batch_csv_record: The input batch of record arrays
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(BatchCSVRecord, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['deployment_name', 'version_name', 'transform_name', 'batch_csv_record']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method transform_csv" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'deployment_name' is set
        if ('deployment_name' not in local_var_params or
                local_var_params['deployment_name'] is None):
            raise ApiValueError("Missing the required parameter `deployment_name` when calling `transform_csv`")  # noqa: E501
        # verify the required parameter 'version_name' is set
        if ('version_name' not in local_var_params or
                local_var_params['version_name'] is None):
            raise ApiValueError("Missing the required parameter `version_name` when calling `transform_csv`")  # noqa: E501
        # verify the required parameter 'transform_name' is set
        if ('transform_name' not in local_var_params or
                local_var_params['transform_name'] is None):
            raise ApiValueError("Missing the required parameter `transform_name` when calling `transform_csv`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'deployment_name' in local_var_params:
            path_params['deploymentName'] = local_var_params['deployment_name']  # noqa: E501
        if 'version_name' in local_var_params:
            path_params['versionName'] = local_var_params['version_name']  # noqa: E501
        if 'transform_name' in local_var_params:
            path_params['transformName'] = local_var_params['transform_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'batch_csv_record' in local_var_params:
            body_params = local_var_params['batch_csv_record']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/endpoints/{deploymentName}/datavec/{transformName}/{versionName}/transform', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BatchCSVRecord',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def transformarray(self, deployment_name, version_name, transform_name, **kwargs):  # noqa: E501
        """Takes a batch input arrays and transforms it  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.transformarray(deployment_name, version_name, transform_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str transform_name: ID or name of the deployed transform (required)
        :param BatchRecord batch_record: The input batch of record arrays
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Base64NDArrayBody
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.transformarray_with_http_info(deployment_name, version_name, transform_name, **kwargs)  # noqa: E501

    def transformarray_with_http_info(self, deployment_name, version_name, transform_name, **kwargs):  # noqa: E501
        """Takes a batch input arrays and transforms it  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.transformarray_with_http_info(deployment_name, version_name, transform_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str transform_name: ID or name of the deployed transform (required)
        :param BatchRecord batch_record: The input batch of record arrays
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Base64NDArrayBody, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['deployment_name', 'version_name', 'transform_name', 'batch_record']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method transformarray" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'deployment_name' is set
        if ('deployment_name' not in local_var_params or
                local_var_params['deployment_name'] is None):
            raise ApiValueError("Missing the required parameter `deployment_name` when calling `transformarray`")  # noqa: E501
        # verify the required parameter 'version_name' is set
        if ('version_name' not in local_var_params or
                local_var_params['version_name'] is None):
            raise ApiValueError("Missing the required parameter `version_name` when calling `transformarray`")  # noqa: E501
        # verify the required parameter 'transform_name' is set
        if ('transform_name' not in local_var_params or
                local_var_params['transform_name'] is None):
            raise ApiValueError("Missing the required parameter `transform_name` when calling `transformarray`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'deployment_name' in local_var_params:
            path_params['deploymentName'] = local_var_params['deployment_name']  # noqa: E501
        if 'version_name' in local_var_params:
            path_params['versionName'] = local_var_params['version_name']  # noqa: E501
        if 'transform_name' in local_var_params:
            path_params['transformName'] = local_var_params['transform_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'batch_record' in local_var_params:
            body_params = local_var_params['batch_record']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/endpoints/{deploymentName}/datavec/{transformName}/{versionName}/transformarray', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Base64NDArrayBody',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def transformimage(self, deployment_name, version_name, image_transform_name, files, **kwargs):  # noqa: E501
        """Takes multiple multipart image file to transform and returns Base64NDArrayBody  # noqa: E501

        Takes multiple multipart image file and transforms it into the desired format and returns it in the form of Base64NDArrayBody  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.transformimage(deployment_name, version_name, image_transform_name, files, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str image_transform_name: ID or name of the deployed image transform (required)
        :param list[file] files: The image files to upload (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Base64NDArrayBody
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.transformimage_with_http_info(deployment_name, version_name, image_transform_name, files, **kwargs)  # noqa: E501

    def transformimage_with_http_info(self, deployment_name, version_name, image_transform_name, files, **kwargs):  # noqa: E501
        """Takes multiple multipart image file to transform and returns Base64NDArrayBody  # noqa: E501

        Takes multiple multipart image file and transforms it into the desired format and returns it in the form of Base64NDArrayBody  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.transformimage_with_http_info(deployment_name, version_name, image_transform_name, files, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str image_transform_name: ID or name of the deployed image transform (required)
        :param list[file] files: The image files to upload (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Base64NDArrayBody, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['deployment_name', 'version_name', 'image_transform_name', 'files']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method transformimage" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'deployment_name' is set
        if ('deployment_name' not in local_var_params or
                local_var_params['deployment_name'] is None):
            raise ApiValueError("Missing the required parameter `deployment_name` when calling `transformimage`")  # noqa: E501
        # verify the required parameter 'version_name' is set
        if ('version_name' not in local_var_params or
                local_var_params['version_name'] is None):
            raise ApiValueError("Missing the required parameter `version_name` when calling `transformimage`")  # noqa: E501
        # verify the required parameter 'image_transform_name' is set
        if ('image_transform_name' not in local_var_params or
                local_var_params['image_transform_name'] is None):
            raise ApiValueError("Missing the required parameter `image_transform_name` when calling `transformimage`")  # noqa: E501
        # verify the required parameter 'files' is set
        if ('files' not in local_var_params or
                local_var_params['files'] is None):
            raise ApiValueError("Missing the required parameter `files` when calling `transformimage`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'deployment_name' in local_var_params:
            path_params['deploymentName'] = local_var_params['deployment_name']  # noqa: E501
        if 'version_name' in local_var_params:
            path_params['versionName'] = local_var_params['version_name']  # noqa: E501
        if 'image_transform_name' in local_var_params:
            path_params['imageTransformName'] = local_var_params['image_transform_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'files' in local_var_params:
            local_var_files['files'] = local_var_params['files']  # noqa: E501
            collection_formats['files'] = 'csv'  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/endpoints/{deploymentName}/datavec/{imageTransformName}/{versionName}/transformimage', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Base64NDArrayBody',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def transformincremental_csv(self, deployment_name, version_name, transform_name, **kwargs):  # noqa: E501
        """Takes SingleCSVRecord as input and returns the transformed array as SingleCSVRecord  # noqa: E501

        Takes a SingleCSVRecord object and transforms it into the desired format  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.transformincremental_csv(deployment_name, version_name, transform_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str transform_name: ID or name of the deployed transform (required)
        :param SingleCSVRecord single_csv_record: The input record array
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: SingleCSVRecord
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.transformincremental_csv_with_http_info(deployment_name, version_name, transform_name, **kwargs)  # noqa: E501

    def transformincremental_csv_with_http_info(self, deployment_name, version_name, transform_name, **kwargs):  # noqa: E501
        """Takes SingleCSVRecord as input and returns the transformed array as SingleCSVRecord  # noqa: E501

        Takes a SingleCSVRecord object and transforms it into the desired format  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.transformincremental_csv_with_http_info(deployment_name, version_name, transform_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str transform_name: ID or name of the deployed transform (required)
        :param SingleCSVRecord single_csv_record: The input record array
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(SingleCSVRecord, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['deployment_name', 'version_name', 'transform_name', 'single_csv_record']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method transformincremental_csv" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'deployment_name' is set
        if ('deployment_name' not in local_var_params or
                local_var_params['deployment_name'] is None):
            raise ApiValueError("Missing the required parameter `deployment_name` when calling `transformincremental_csv`")  # noqa: E501
        # verify the required parameter 'version_name' is set
        if ('version_name' not in local_var_params or
                local_var_params['version_name'] is None):
            raise ApiValueError("Missing the required parameter `version_name` when calling `transformincremental_csv`")  # noqa: E501
        # verify the required parameter 'transform_name' is set
        if ('transform_name' not in local_var_params or
                local_var_params['transform_name'] is None):
            raise ApiValueError("Missing the required parameter `transform_name` when calling `transformincremental_csv`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'deployment_name' in local_var_params:
            path_params['deploymentName'] = local_var_params['deployment_name']  # noqa: E501
        if 'version_name' in local_var_params:
            path_params['versionName'] = local_var_params['version_name']  # noqa: E501
        if 'transform_name' in local_var_params:
            path_params['transformName'] = local_var_params['transform_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'single_csv_record' in local_var_params:
            body_params = local_var_params['single_csv_record']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/endpoints/{deploymentName}/datavec/{transformName}/{versionName}/transformincremental', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SingleCSVRecord',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def transformincrementalarray(self, deployment_name, version_name, transform_name, **kwargs):  # noqa: E501
        """Same as /transformincremental but returns Base64NDArrayBody.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.transformincrementalarray(deployment_name, version_name, transform_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str transform_name: ID or name of the deployed transform (required)
        :param SingleRecord single_record: The input record array
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Base64NDArrayBody
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.transformincrementalarray_with_http_info(deployment_name, version_name, transform_name, **kwargs)  # noqa: E501

    def transformincrementalarray_with_http_info(self, deployment_name, version_name, transform_name, **kwargs):  # noqa: E501
        """Same as /transformincremental but returns Base64NDArrayBody.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.transformincrementalarray_with_http_info(deployment_name, version_name, transform_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str transform_name: ID or name of the deployed transform (required)
        :param SingleRecord single_record: The input record array
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Base64NDArrayBody, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['deployment_name', 'version_name', 'transform_name', 'single_record']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method transformincrementalarray" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'deployment_name' is set
        if ('deployment_name' not in local_var_params or
                local_var_params['deployment_name'] is None):
            raise ApiValueError("Missing the required parameter `deployment_name` when calling `transformincrementalarray`")  # noqa: E501
        # verify the required parameter 'version_name' is set
        if ('version_name' not in local_var_params or
                local_var_params['version_name'] is None):
            raise ApiValueError("Missing the required parameter `version_name` when calling `transformincrementalarray`")  # noqa: E501
        # verify the required parameter 'transform_name' is set
        if ('transform_name' not in local_var_params or
                local_var_params['transform_name'] is None):
            raise ApiValueError("Missing the required parameter `transform_name` when calling `transformincrementalarray`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'deployment_name' in local_var_params:
            path_params['deploymentName'] = local_var_params['deployment_name']  # noqa: E501
        if 'version_name' in local_var_params:
            path_params['versionName'] = local_var_params['version_name']  # noqa: E501
        if 'transform_name' in local_var_params:
            path_params['transformName'] = local_var_params['transform_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'single_record' in local_var_params:
            body_params = local_var_params['single_record']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/endpoints/{deploymentName}/datavec/{transformName}/{versionName}/transformincrementalarray', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Base64NDArrayBody',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def transformincrementalimage(self, deployment_name, version_name, image_transform_name, file, **kwargs):  # noqa: E501
        """Takes a single multipart image file to transform and returns Base64NDArrayBody  # noqa: E501

        Takes a single multipart image file and transforms it into the desired format and returns it in the form of Base64NDArrayBody  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.transformincrementalimage(deployment_name, version_name, image_transform_name, file, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str image_transform_name: ID or name of the deployed image transform (required)
        :param file file: The image file to upload (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Base64NDArrayBody
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.transformincrementalimage_with_http_info(deployment_name, version_name, image_transform_name, file, **kwargs)  # noqa: E501

    def transformincrementalimage_with_http_info(self, deployment_name, version_name, image_transform_name, file, **kwargs):  # noqa: E501
        """Takes a single multipart image file to transform and returns Base64NDArrayBody  # noqa: E501

        Takes a single multipart image file and transforms it into the desired format and returns it in the form of Base64NDArrayBody  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.transformincrementalimage_with_http_info(deployment_name, version_name, image_transform_name, file, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str image_transform_name: ID or name of the deployed image transform (required)
        :param file file: The image file to upload (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Base64NDArrayBody, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['deployment_name', 'version_name', 'image_transform_name', 'file']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method transformincrementalimage" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'deployment_name' is set
        if ('deployment_name' not in local_var_params or
                local_var_params['deployment_name'] is None):
            raise ApiValueError("Missing the required parameter `deployment_name` when calling `transformincrementalimage`")  # noqa: E501
        # verify the required parameter 'version_name' is set
        if ('version_name' not in local_var_params or
                local_var_params['version_name'] is None):
            raise ApiValueError("Missing the required parameter `version_name` when calling `transformincrementalimage`")  # noqa: E501
        # verify the required parameter 'image_transform_name' is set
        if ('image_transform_name' not in local_var_params or
                local_var_params['image_transform_name'] is None):
            raise ApiValueError("Missing the required parameter `image_transform_name` when calling `transformincrementalimage`")  # noqa: E501
        # verify the required parameter 'file' is set
        if ('file' not in local_var_params or
                local_var_params['file'] is None):
            raise ApiValueError("Missing the required parameter `file` when calling `transformincrementalimage`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'deployment_name' in local_var_params:
            path_params['deploymentName'] = local_var_params['deployment_name']  # noqa: E501
        if 'version_name' in local_var_params:
            path_params['versionName'] = local_var_params['version_name']  # noqa: E501
        if 'image_transform_name' in local_var_params:
            path_params['imageTransformName'] = local_var_params['image_transform_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'file' in local_var_params:
            local_var_files['file'] = local_var_params['file']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/endpoints/{deploymentName}/datavec/{imageTransformName}/{versionName}/transformincrementalimage', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Base64NDArrayBody',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def transformprocess_get(self, deployment_name, version_name, transform_name, **kwargs):  # noqa: E501
        """Gets the JSON string of the deployed transform process (CSV or Image)  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.transformprocess_get(deployment_name, version_name, transform_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str transform_name: ID or name of the deployed transform (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.transformprocess_get_with_http_info(deployment_name, version_name, transform_name, **kwargs)  # noqa: E501

    def transformprocess_get_with_http_info(self, deployment_name, version_name, transform_name, **kwargs):  # noqa: E501
        """Gets the JSON string of the deployed transform process (CSV or Image)  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.transformprocess_get_with_http_info(deployment_name, version_name, transform_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str transform_name: ID or name of the deployed transform (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['deployment_name', 'version_name', 'transform_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method transformprocess_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'deployment_name' is set
        if ('deployment_name' not in local_var_params or
                local_var_params['deployment_name'] is None):
            raise ApiValueError("Missing the required parameter `deployment_name` when calling `transformprocess_get`")  # noqa: E501
        # verify the required parameter 'version_name' is set
        if ('version_name' not in local_var_params or
                local_var_params['version_name'] is None):
            raise ApiValueError("Missing the required parameter `version_name` when calling `transformprocess_get`")  # noqa: E501
        # verify the required parameter 'transform_name' is set
        if ('transform_name' not in local_var_params or
                local_var_params['transform_name'] is None):
            raise ApiValueError("Missing the required parameter `transform_name` when calling `transformprocess_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'deployment_name' in local_var_params:
            path_params['deploymentName'] = local_var_params['deployment_name']  # noqa: E501
        if 'version_name' in local_var_params:
            path_params['versionName'] = local_var_params['version_name']  # noqa: E501
        if 'transform_name' in local_var_params:
            path_params['transformName'] = local_var_params['transform_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/endpoints/{deploymentName}/datavec/{transformName}/{versionName}/transformprocess', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def transformprocess_post(self, content_type, deployment_name, version_name, transform_name, **kwargs):  # noqa: E501
        """Sets the deployed (CSV or Image) transform process through the provided JSON string  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.transformprocess_post(content_type, deployment_name, version_name, transform_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str content_type: The `Content-Type` should be `application/json`. (required)
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str transform_name: ID or name of the deployed transform (required)
        :param str transform_process: The transform process to set (Specify a JSON string here).
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.transformprocess_post_with_http_info(content_type, deployment_name, version_name, transform_name, **kwargs)  # noqa: E501

    def transformprocess_post_with_http_info(self, content_type, deployment_name, version_name, transform_name, **kwargs):  # noqa: E501
        """Sets the deployed (CSV or Image) transform process through the provided JSON string  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.transformprocess_post_with_http_info(content_type, deployment_name, version_name, transform_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str content_type: The `Content-Type` should be `application/json`. (required)
        :param str deployment_name: Name of the deployment group (required)
        :param str version_name: Version name of the endpoint. The default value is \"default\" (required)
        :param str transform_name: ID or name of the deployed transform (required)
        :param str transform_process: The transform process to set (Specify a JSON string here).
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['content_type', 'deployment_name', 'version_name', 'transform_name', 'transform_process']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method transformprocess_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'content_type' is set
        if ('content_type' not in local_var_params or
                local_var_params['content_type'] is None):
            raise ApiValueError("Missing the required parameter `content_type` when calling `transformprocess_post`")  # noqa: E501
        # verify the required parameter 'deployment_name' is set
        if ('deployment_name' not in local_var_params or
                local_var_params['deployment_name'] is None):
            raise ApiValueError("Missing the required parameter `deployment_name` when calling `transformprocess_post`")  # noqa: E501
        # verify the required parameter 'version_name' is set
        if ('version_name' not in local_var_params or
                local_var_params['version_name'] is None):
            raise ApiValueError("Missing the required parameter `version_name` when calling `transformprocess_post`")  # noqa: E501
        # verify the required parameter 'transform_name' is set
        if ('transform_name' not in local_var_params or
                local_var_params['transform_name'] is None):
            raise ApiValueError("Missing the required parameter `transform_name` when calling `transformprocess_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'deployment_name' in local_var_params:
            path_params['deploymentName'] = local_var_params['deployment_name']  # noqa: E501
        if 'version_name' in local_var_params:
            path_params['versionName'] = local_var_params['version_name']  # noqa: E501
        if 'transform_name' in local_var_params:
            path_params['transformName'] = local_var_params['transform_name']  # noqa: E501

        query_params = []

        header_params = {}
        if 'content_type' in local_var_params:
            header_params['Content-Type'] = local_var_params['content_type']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'transform_process' in local_var_params:
            body_params = local_var_params['transform_process']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/endpoints/{deploymentName}/datavec/{transformName}/{versionName}/transformprocess', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_auth_policy(self, auth_policy, **kwargs):  # noqa: E501
        """Update auth policy  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_auth_policy(auth_policy, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param AuthPolicy auth_policy: Auth policy object (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: AuthPolicy
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.update_auth_policy_with_http_info(auth_policy, **kwargs)  # noqa: E501

    def update_auth_policy_with_http_info(self, auth_policy, **kwargs):  # noqa: E501
        """Update auth policy  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_auth_policy_with_http_info(auth_policy, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param AuthPolicy auth_policy: Auth policy object (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(AuthPolicy, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['auth_policy']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_auth_policy" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'auth_policy' is set
        if ('auth_policy' not in local_var_params or
                local_var_params['auth_policy'] is None):
            raise ApiValueError("Missing the required parameter `auth_policy` when calling `update_auth_policy`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'auth_policy' in local_var_params:
            body_params = local_var_params['auth_policy']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/auth/policy', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AuthPolicy',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_best_model_for_experiment(self, model_history_server_id, update_best_model, **kwargs):  # noqa: E501
        """Updates the best model for an experiment  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_best_model_for_experiment(model_history_server_id, update_best_model, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str model_history_server_id: Process GUID of the model history server. Run `$SKIL_HOME/sbin/skil services` in a console to find out the model history server GUID. (required)
        :param UpdateBestModel update_best_model: Model encapsulating the experiment id to update and the best model id. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ExperimentEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.update_best_model_for_experiment_with_http_info(model_history_server_id, update_best_model, **kwargs)  # noqa: E501

    def update_best_model_for_experiment_with_http_info(self, model_history_server_id, update_best_model, **kwargs):  # noqa: E501
        """Updates the best model for an experiment  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_best_model_for_experiment_with_http_info(model_history_server_id, update_best_model, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str model_history_server_id: Process GUID of the model history server. Run `$SKIL_HOME/sbin/skil services` in a console to find out the model history server GUID. (required)
        :param UpdateBestModel update_best_model: Model encapsulating the experiment id to update and the best model id. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ExperimentEntity, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['model_history_server_id', 'update_best_model']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_best_model_for_experiment" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'model_history_server_id' is set
        if ('model_history_server_id' not in local_var_params or
                local_var_params['model_history_server_id'] is None):
            raise ApiValueError("Missing the required parameter `model_history_server_id` when calling `update_best_model_for_experiment`")  # noqa: E501
        # verify the required parameter 'update_best_model' is set
        if ('update_best_model' not in local_var_params or
                local_var_params['update_best_model'] is None):
            raise ApiValueError("Missing the required parameter `update_best_model` when calling `update_best_model_for_experiment`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model_history_server_id' in local_var_params:
            path_params['modelHistoryServerId'] = local_var_params['model_history_server_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'update_best_model' in local_var_params:
            body_params = local_var_params['update_best_model']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/rpc/{modelHistoryServerId}/experiment/best', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ExperimentEntity',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_experiment(self, model_history_server_id, experiment_id, experiment_entity, **kwargs):  # noqa: E501
        """Updates an experiment, given an experiment entity  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_experiment(model_history_server_id, experiment_id, experiment_entity, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str model_history_server_id: Process GUID of the model history server. Run `$SKIL_HOME/sbin/skil services` in a console to find out the model history server GUID. (required)
        :param str experiment_id: the GUID of the experiment to update (required)
        :param ExperimentEntity experiment_entity: The experiment entity to update with (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ExperimentEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.update_experiment_with_http_info(model_history_server_id, experiment_id, experiment_entity, **kwargs)  # noqa: E501

    def update_experiment_with_http_info(self, model_history_server_id, experiment_id, experiment_entity, **kwargs):  # noqa: E501
        """Updates an experiment, given an experiment entity  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_experiment_with_http_info(model_history_server_id, experiment_id, experiment_entity, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str model_history_server_id: Process GUID of the model history server. Run `$SKIL_HOME/sbin/skil services` in a console to find out the model history server GUID. (required)
        :param str experiment_id: the GUID of the experiment to update (required)
        :param ExperimentEntity experiment_entity: The experiment entity to update with (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ExperimentEntity, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['model_history_server_id', 'experiment_id', 'experiment_entity']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_experiment" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'model_history_server_id' is set
        if ('model_history_server_id' not in local_var_params or
                local_var_params['model_history_server_id'] is None):
            raise ApiValueError("Missing the required parameter `model_history_server_id` when calling `update_experiment`")  # noqa: E501
        # verify the required parameter 'experiment_id' is set
        if ('experiment_id' not in local_var_params or
                local_var_params['experiment_id'] is None):
            raise ApiValueError("Missing the required parameter `experiment_id` when calling `update_experiment`")  # noqa: E501
        # verify the required parameter 'experiment_entity' is set
        if ('experiment_entity' not in local_var_params or
                local_var_params['experiment_entity'] is None):
            raise ApiValueError("Missing the required parameter `experiment_entity` when calling `update_experiment`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model_history_server_id' in local_var_params:
            path_params['modelHistoryServerId'] = local_var_params['model_history_server_id']  # noqa: E501
        if 'experiment_id' in local_var_params:
            path_params['experimentID'] = local_var_params['experiment_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'experiment_entity' in local_var_params:
            body_params = local_var_params['experiment_entity']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/rpc/{modelHistoryServerId}/experiment/{experimentID}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ExperimentEntity',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_model_history(self, model_history_server_id, model_history_id, update_model_history_request, **kwargs):  # noqa: E501
        """Update a model history / workspace  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_model_history(model_history_server_id, model_history_id, update_model_history_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str model_history_server_id: Process GUID of the model history server. Run `$SKIL_HOME/sbin/skil services` in a console to find out the model history server GUID. (required)
        :param str model_history_id: the GUID of the model history / workspace to update (required)
        :param AddModelHistoryRequest update_model_history_request: The model history request object (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ModelHistoryEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.update_model_history_with_http_info(model_history_server_id, model_history_id, update_model_history_request, **kwargs)  # noqa: E501

    def update_model_history_with_http_info(self, model_history_server_id, model_history_id, update_model_history_request, **kwargs):  # noqa: E501
        """Update a model history / workspace  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_model_history_with_http_info(model_history_server_id, model_history_id, update_model_history_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str model_history_server_id: Process GUID of the model history server. Run `$SKIL_HOME/sbin/skil services` in a console to find out the model history server GUID. (required)
        :param str model_history_id: the GUID of the model history / workspace to update (required)
        :param AddModelHistoryRequest update_model_history_request: The model history request object (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ModelHistoryEntity, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['model_history_server_id', 'model_history_id', 'update_model_history_request']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_model_history" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'model_history_server_id' is set
        if ('model_history_server_id' not in local_var_params or
                local_var_params['model_history_server_id'] is None):
            raise ApiValueError("Missing the required parameter `model_history_server_id` when calling `update_model_history`")  # noqa: E501
        # verify the required parameter 'model_history_id' is set
        if ('model_history_id' not in local_var_params or
                local_var_params['model_history_id'] is None):
            raise ApiValueError("Missing the required parameter `model_history_id` when calling `update_model_history`")  # noqa: E501
        # verify the required parameter 'update_model_history_request' is set
        if ('update_model_history_request' not in local_var_params or
                local_var_params['update_model_history_request'] is None):
            raise ApiValueError("Missing the required parameter `update_model_history_request` when calling `update_model_history`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model_history_server_id' in local_var_params:
            path_params['modelHistoryServerId'] = local_var_params['model_history_server_id']  # noqa: E501
        if 'model_history_id' in local_var_params:
            path_params['modelHistoryID'] = local_var_params['model_history_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'update_model_history_request' in local_var_params:
            body_params = local_var_params['update_model_history_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/rpc/{modelHistoryServerId}/modelhistory/{modelHistoryID}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ModelHistoryEntity',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_user(self, user, **kwargs):  # noqa: E501
        """Update a user  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_user(user, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param User user: User details (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: User
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.update_user_with_http_info(user, **kwargs)  # noqa: E501

    def update_user_with_http_info(self, user, **kwargs):  # noqa: E501
        """Update a user  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_user_with_http_info(user, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param User user: User details (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(User, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['user']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_user" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'user' is set
        if ('user' not in local_var_params or
                local_var_params['user'] is None):
            raise ApiValueError("Missing the required parameter `user` when calling `update_user`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'user' in local_var_params:
            body_params = local_var_params['user']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/user', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='User',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def upload(self, **kwargs):  # noqa: E501
        """Upload a model file to SKIL for import.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.upload(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param file file: The file to upload.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: FileUploadList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.upload_with_http_info(**kwargs)  # noqa: E501

    def upload_with_http_info(self, **kwargs):  # noqa: E501
        """Upload a model file to SKIL for import.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.upload_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param file file: The file to upload.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(FileUploadList, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['file']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method upload" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'file' in local_var_params:
            local_var_files['file'] = local_var_params['file']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key', 'x_api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api/upload/model', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FileUploadList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)
