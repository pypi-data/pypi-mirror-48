"""Routines for the export of scripts to various form

"""

import biseau as bs
import datetime
import itertools
from . import Script, __version__
try:
    import black
except ImportError:
    black = None


def get_pipeline_options(scripts:[Script]) -> dict:
    """Return the mapping option->False to be used by standalone_export_pipeline.

    One may want to set some options to True, to get them in pipeline standalone export.

    """
    return {n: False for _, __, n in option_names_from_options(scripts)}


def standalone_export_pipeline(scripts:[Script], options:dict={}, default_context:str='', verbosity:int=0) -> [str]:
    """Return a string of Python code, implementing a standalone program reproducing given pipeline.

    options -- {option name: bool} indicating whether or not the option
               must be exposed as program option.
    default_context -- the default initial context.
    verbosity -- verbosity of the standalone program itself.

    """
    gen = _standalone_export_pipeline(scripts, options, default_context, verbosity)
    python_code = '\n'.join(gen)
    if black:
        return black.format_str(python_code, mode=black.FileMode())
    return python_code

def _standalone_export_pipeline(scripts:[Script], options:dict={}, default_context:str='', verbosity:int=0) -> [str]:
    """Yield Python code strings, implementing a standalone program reproducing given pipeline.

    options -- {option name: bool} indicating whether or not the option
               must be exposed as program option.
    default_context -- the default initial context.
    verbosity -- verbosity of the standalone program itself.

    """
    option_names = {(idx, name): final_name for idx, (_, name, final_name) in enumerate(option_names_from_options(scripts), 1)}
    options_used = tuple(
        (idx, final_name) for idx, final_name in option_names.items()
        if options.get(final_name)
    )
    yield '"""Standalone script generated by biseau ' + str(__version__) + ', ' + str(datetime.datetime.now()) + '"""\n'
    yield 'import argparse'
    yield 'import clitogui'
    yield 'import clyngor'
    yield ''
    if options:
        yield '@clitogui'
        yield 'def cli():'
        yield '    parser = argparse.ArgumentParser()'
        for (idx, name), final_name in options_used:
            option = scripts[idx-1].options
            option = scripts[idx].options[name]
            print(option)
            yield f'    parser.addArgument({final_name})'
        yield '    ...'
        yield '    return parser'
        yield ''
    # add a run_on function for each script
    runons = []
    for script in scripts:
        bs.utils.name_to_identifier(script.name)
        runon_name = f"run_on_{bs.utils.name_to_identifier(script.name)}"
        runons.append((runon_name, script))
    for runon_name, script in runons:
        params = ', '.join(f"{name}:{valtype.__name__ if type(valtype) in {type(open), type(bool)} else str(valtype)}={repr(default)}" for name, valtype, default, _ in script.options)
        yield f'def {runon_name}(context, {params}):'
        if script.language == 'python':
            for line in script.source_code.splitlines(False):
                yield '    ' + line
        elif script.language == 'asp':
            yield '     context += """\\n' + script.source_code + '"""'
        elif script.language == 'asp file':
            yield '    with open({script.source_code}) as fd:'
            yield '        context += "\\n" + fd.read().strip()'
        else:
            raise ValueError(f"unhandled export of language '{script.language}'")
        runon_args = ', '.join(f"{name}={name}" for name, *_ in script.options)
        yield f'    return \'\'.join(run_on(context, {runon_args}))'
    yield 'def run_on(context:str, ' '):'
    for runon, script in runons:
        args = ', '.join(f"{name}=args.{name}" for name, *_ in script.options)
        yield f'    context = {runon}(context, {args})'
    yield '    print(context)'
    yield 'if __name__ == "__main__":'
    yield '    args = cli()'
    yield '    context = ' + repr(default_context)
    yield '    run_on(context)'


def option_names_from_options(scripts:[Script]) -> [(str, str, str)]:
    """Yield (script name, option name, unambiguous option name)
    so that unambiguous option name is deterministic and unique
    accross all options of given scripts.

    """
    used_names = set()  # set of all available options
    conflicting_names = set()  # names that will need the script name
    script_names = tuple(script.name for script in scripts)
    script_name_doublons = {n: itertools.count(1) for n in script_names if script_names.count(n) > 1}
    # define names of scripts (append their index when multiple scripts of same name)
    script_names = tuple(
        (script.name + ' ' + str(next(script_name_doublons[script.name])))
        if script.name in script_name_doublons else script.name
        for script in scripts
    )
    assert len(script_names) == len(scripts)
    # detect the name conflicts among scripts options
    for script in scripts:
        for name, type, default, description in script.options:
            if name in used_names:
                conflicting_names.add(name)
            used_names.add(name)
    # for each script, ensure the use of proper option name
    for script_name, script in zip(script_names, scripts):
        for name, type, default, description in script.options:
            final_name = name
            if name in conflicting_names:
                final_name = f'{script_name}_{name}'
            yield script_name, name, final_name
