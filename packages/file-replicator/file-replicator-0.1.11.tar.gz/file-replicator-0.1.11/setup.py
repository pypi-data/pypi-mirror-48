# -*- coding: utf-8 -*-
from distutils.core import setup

packages = \
['file_replicator']

package_data = \
{'': ['*']}

install_requires = \
['click>=7.0,<8.0', 'inotify>=0.2.10,<0.3.0', 'pathspec>=0.5.9,<0.6.0']

entry_points = \
{'console_scripts': ['file-replicator = file_replicator.cli:main']}

setup_kwargs = {
    'name': 'file-replicator',
    'version': '0.1.11',
    'description': 'Replicate files to another computer for remote development',
    'long_description': '# File Replicator\n\nReplicate files one-way to another computer e.g. for remote development.\n\nA key use-case is to keep in sync a directory of development files from a computer on which\nthe files are edited with a copy of those files in a docker container running on a remote docker host.\n\nTested and known to work between two Linux machines. Support for developing on macOS coming...\n\n# Installation\n\nDependencies are:\n* Python 3 and some Python packages on the development machine.\n* Ability to run a shell (bash or bash-like) on the remote machine with connected `stdin`.\n* The tar utility (the full version, not the busybox version) on both machines.\n\nNote that nothing is installed remotely, there are no ports to open, and the remote user only needs\nthe ability to create the files and directories at the specified location.\n\nSo to install `file-replicator` on the machine with the source files to replicate:\n\n    pip install file-replicator\n\nNothing needs to be installed on the destination machine so long as it has `bash`\n(busybox bash is fine) and `tar` (gnu). Note that on alpine linux, the busybox tar\nis insufficient, so install gnu tar with:\n\n    apk install tar\n\n# How it works\n\nThe approach involves running a small bash program on the remote (destination) end which is able to\nadd/update new files in (potentially) new directories. It receives these files over `stdin`\nusing the `tar` format (binary).\n\nThe controlling (source) end then simply sends files over to the `stdin` of the receiving bash\nprogram, which pipes them through `tar` to unpack them again. Note that gnu `tar` is able to extract from\nnon-blocking file descriptor (as well as blocking), which means it keeps trying until it has all the data.\nNB the busybox tar does not have this behaviour.\n\nEstablishing the connection to the remote end is outside the remit of the tool, but `file-replicator`\nrequires as an argument the command to make such a connection. See examples below.\n\nOnce a connection has been made, two phases of operation occur:\n\n1. first, recursively walk a source tree of files and send them "over the wire" to the destination\n2. then, watch for changes or new files and directories before sending them "over the wire" to the destination\n\nSo there is no "difference algorithm" like rsync, no attempt to compress (although of course the connection\ncould already be compressing e.g. if over ssh), the connection is made entirely using standard means like\nssh and docker, there are no ports to open, and even the bash program on the remote end is sent over every time\nso nothing is installed remotely.\n\nThis is sufficient for editing code on a local computer and automatically replicating them to a\nremote server or docker container whenever a file is created or modified.\n\n# Usage and examples\n\nSee help with `file-replicate --help`:\n\n    Usage: file-replicator [OPTIONS] SRC_DIR DEST_PARENT_DIR \\\n                           [CONNECTION_COMMAND]...\n\n    Replicate files to another computer e.g. for remote development.\n\n    SRC_DIR is the source directory on this machine.\n\n    DEST_PARENT_DIR is the (absolute) destination parent directory on the\n    remote machine accessed using the CONNECTION_COMMAND.\n\n    The CONNECTION_COMMAND must result in a running instance of bash ready to\n    receive commands on stdin.\n\n    Example CONNECTION_COMMANDs include:\n\n        ssh some.host.com bash\n\n        docker exec -i my_container bash\n\n        docker-compose exec -T my_container bash\n\n    So a full use of the tool might look like:\n\n        file-replicator my_code_dir /home/code -- docker exec -i a_container bash\n\n    (the use of "--" prevents any further processing of command line arguments\n    by file-replicator, leaving them all for docker)\n\n    Initially, all files and required directories are recursively copied. Then\n    it waits for changes before copying each modified or new file. This can be\n    modified with the switches.\n\n    Note that empty directories are not replicated until they contain a file.\n\n    Options:\n    --clean-out-first               Optionally start by cleaning out the\n                                    destination directory.\n    --with-initial-replication / --no-initial-replication\n                                    Perform (or not) an initial replication of\n                                    all files.\n    --replicate-on-change / --no-replicate-on-change\n                                    Perform (or not) a wait-for-change-and-\n                                    replicate cycle.\n    --gitignore / --no-gitignore    Use .gitignore (or not) to filter files.\n    --debugging                     Print debugging information.\n    --version                       Show the version and exit.\n    --help                          Show this message and exit.\n\nFor example, to replicate files from local directory `my_project_dir` to directory\n`/home/code/my_project_dir` on remote machine called `my.server.com`:\n\n    file-replicator my_project_dir /home/code ssh my.server.com bash\n\nAs another example, to replicate files from local directory `my_project_dir` to directory\n`/home/code/my_project_dir` in a running docker container called `my_container` on a potentially\nremote host (depending upon the `DOCKER*` environment variables e.g. as set by `docker-machine eval`):\n\n    file-replicator my_project_dir /home/code -- docker exec -i my_container bash\n\nOr to do the same but using `docker-compose` instead:\n\n    file-replicator my_project_dir /home/code -- docker-compose exec -T my_container bash\n\nLastly, as a degenerate example which doesn\'t actually connect to a remote machine at all\nbut replicates into the local `/tmp/my_project_dir`:\n\n    file-replicator my_project_dir /tmp bash\n\nThe unit tests use this degenerate approach to test the tool.\n\n# Limitations\n\nDue to limitations with inotify (race conditions around watching for changes in newly created directories), it\nis possible that the watching-for-changes phase becomes out of step. In which case, just restart the whole program.\nThe tool includes some self-restarting behaviour, but ultimately a full restart may sometimes be needed.\n\nInformation printed to stdout indicates when this happens.\n\n# Tests\n\n    ============================= test session starts ==============================\n    platform linux -- Python 3.6.7, pytest-3.10.1, py-1.8.0, pluggy-0.12.0 -- /home/tcorbettclark/.cache/pypoetry/virtualenvs/file-replicator-py3.6/bin/python\n    cachedir: .pytest_cache\n    rootdir: /home/tcorbettclark/code/file-replicator, inifile:\n    collecting ... collected 8 items\n\n    tests/test_lib.py::test_empty_directories_are_copied PASSED                [ 12%]\n    tests/test_lib.py::test_copy_one_file PASSED                               [ 25%]\n    tests/test_lib.py::test_copy_file_with_unusual_characters_in_name PASSED   [ 37%]\n    tests/test_lib.py::test_make_missing_parent_directories PASSED             [ 50%]\n    tests/test_lib.py::test_replicate_all_files PASSED                         [ 62%]\n    tests/test_lib.py::test_detect_and_copy_new_file PASSED                    [ 75%]\n    tests/test_lib.py::test_detect_and_copy_modified_file PASSED               [ 87%]\n    tests/test_lib.py::test_detect_and_copy_new_file_in_new_directories PASSED [100%]\n\n    =========================== 8 passed in 4.00 seconds ===========================\n\n# Contributions\n\nPull-requests are welcome! Please consider including tests and updating docs at the same time.\n\nThe package is maintained using poetry (https://poetry.eustace.io) and pyenv (https://github.com/pyenv/pyenv).\n\nThe code is formatted using black (https://black.readthedocs.io/en/stable) and isort (https://github.com/timothycrosley/isort).\n\nIt is tested using pytest (https://pytest.org).\n\n# Commit checklist\n\n1. `isort -rc .`\n1. `black .`\n1. `pytest -v`\n1. clock version in `pyproject.toml`\n1. clock version in `file_replicator/__init__.py`\n1. `git tag`\n1. update this README.md with the latest output from the tests\n1. update this README.md with the latest output from the --help option\n',
    'author': 'Timothy Corbett-Clark',
    'author_email': 'timothy.corbettclark@gmail.com',
    'url': 'https://github.com/tcorbettclark/file-replicator',
    'packages': packages,
    'package_data': package_data,
    'install_requires': install_requires,
    'entry_points': entry_points,
    'python_requires': '>=3.6,<4.0',
}


setup(**setup_kwargs)
