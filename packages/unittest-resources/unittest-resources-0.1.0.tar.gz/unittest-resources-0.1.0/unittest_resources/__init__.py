# -*- coding: utf-8 -*-
"""
Dynamic resource-based unittest suites made easy.

More details on project `README.md` and
`repository <https://gitlab.com/ergoithz/unittest-resources/>`_.

License
-------
MIT (see LICENSE file).
"""

import re
import unittest

import six

try:  # python 3.5+
    import typing
except ImportError:
    pass

try:  # python 3.7+
    import importlib.resources as res
except ImportError:
    import importlib_resources as res  # type: ignore  # noqa


__version__ = '0.1.0'
__all__ = ['ResourceTestMeta', 'ResourceTestCase', '__version__']


class ResourceTestMeta(type):
    """
    Resource-based :class:`unittest.TestCase` metaclass.

    This metaclass generates test methods for every resource matching
    given pattern (ie. regex).

    Automatically-generated resource test methods will end calling
    :method:`ResourceTestCase.meta_test` method with both module name and
    resource name as arguments, which will be responsible of implementing
    the actual test logic.

    The following functions from :module:`importlib.resources` are
    injected as :class:`staticmethod`s:
    - :func:`importlib.resources.contents` as `contents`
    - :func:`importlib.resources.is_resource` as `is_resource`
    - :func:`importlib.resources.open_binary` as `open_binary`
    - :func:`importlib.resources.open_text` as `open_text`
    - :func:`importlib.resources.path` as `path`
    - :func:`importlib.resources.read_binary` as `read_binary`
    - :func:`importlib.resources.read_text` as `read_text`

    Honored class attributes:
    - `meta_test`: actual test logic, must accept module and resource.
    - `meta_module`: module to inspect for resources (defaults to None).
    - `meta_resource_pattern`: regexp matching resources (defaults to None).
    - `meta_prefix`: prefix to add to tests (defaults to `resource`).
    - `meta_suffix`: suffix to add to tests (defaults to empty string).
    - `meta_resources`: iterable module/resource pairs (defaults to empty).
    """

    resource_methods = (
        'contents',
        'is_resource',
        'open_binary',
        'open_text',
        'path',
        'read_binary',
        'read_text',
        )
    escape_pattern = re.compile(r'[^a-zA-Z0-9]+')
    autogenerated_flag = '_from_resource_test_meta'

    @classmethod
    def iter_content_items(cls,
                           module,   # type: str
                           item,     # type: str
                           pattern,  # type: typing.Pattern
                           ):
        # type: (...) -> typing.Generator[typing.Tuple[str, str], None, None]
        """
        Iterate resources from given submodule or resource, recursively.

        Only resources matching any of given given pattern will be
        returned.

        :param module: module name where resources will be search on
        :type module: str
        :param item: submodule or resource name
        :type item: str
        :param pattern: regular expression used to match resources
        :type pattern: typing.Pattern
        :returns: iterator of tuples with module and resource name
        :rtype: typing.Generator[typing.Tuple[str, str], None, None]
        """
        if res.is_resource(module, item):
            if pattern.search(item):
                yield (module, item)
        else:
            submodule = '%s.%s' % (module, item)
            for subitem in cls.iter_contents(submodule, pattern):
                yield subitem

    @classmethod
    def iter_contents(cls,
                      module,   # type: str
                      pattern,  # type: typing.Pattern
                      ):
        # type: (...) -> typing.Generator[typing.Tuple[str, str], None, None]
        """
        Iterate resources from given module, recursively.

        Only resources matching any of given given pattern will be
        returned.

        :param module: module name where resources will be search on
        :type module: str
        :param pattern: regular expression used to match resources
        :type pattern: typing.Pattern
        :returns: iterator of tuples with module and resource name
        :rtype: typing.Iterator[typing.Tuple[str, str], None]
        """
        if None in (module, pattern):
            return
        try:
            for item in res.contents(module):
                for subitem in cls.iter_content_items(module, item, pattern):
                    yield subitem
        except ImportError:
            pass

    @classmethod
    def create_method(cls,
                      base,    # type: str
                      module,    # type: str
                      resource,  # type: str
                      pattern,   # type: typing.Pattern
                      prefix,    # type: str
                      suffix,    # type: str
                      ):
        # type: (...) -> typing.Callable[[object], None]
        """
        Genetrate a test_method from given parameters.

        This method creates an instance method which applies an already
        defined :method:`ResourceTestCase.meta_test` to the given
        resource.

        :param base: base module name will be stripped from test name
        :type base: str
        :param module: resource module name, used as namespace
        :type module: str
        :param resource: resource name
        :type resource: str
        :param pattern: regular expression used to strip resources
        :type pattern: typing.Pattern
        :param prefix: test name prefix
        :type prefix: str
        :param suffix: test name suffix
        :type suffix: str
        :return: method function named test_{prefix}_{namespace}_{name}
        :type: typing.Callable[[]]
        """
        def test(self):
            self.meta_test(module, resource)

        under_base = base and (module == base or module.startswith(base + '.'))
        test.__name__ = cls.escape_pattern.sub('_', '_'.join(
            filter(None, (
                'test',
                prefix,
                module[len(base) + 1:] if under_base else module,
                resource,
                suffix
                ))
            ))
        return test

    def __init__(self,
                 name,   # type: str
                 bases,  # type: typing.List[type]
                 dct,    # type: typing.Mapping[str, typing.Any]
                 ):
        # type: (...) -> None
        """
        Metaclass constructor, initializes the target class.

        :param name: target class name
        :type name: str
        :param bases: base class hierarchy
        :type bases: typing.Iterable[type]
        :param dct: future class __dict__
        :type dct: typing.Mapping[str, typing.Any]
        """
        super_init = super(ResourceTestMeta, self).__init__
        super_init(name, bases, dct)  # type: ignore

        base = getattr(self, 'meta_module', None)
        pattern = getattr(self, 'meta_resource_pattern', None)
        prefix = getattr(self, 'meta_prefix', 'resource_')
        suffix = getattr(self, 'meta_suffix', '')
        extra = getattr(self, 'meta_resources', ())

        # generate tests from files
        for resources in (self.iter_contents(base, pattern), extra):
            for module, resource in resources:
                test = self.create_method(
                    base, module, resource, pattern, prefix, suffix)
                setattr(self, test.__name__, test)

        # add resource methods if not already defined
        for method in self.resource_methods:
            if not hasattr(self, method):
                setattr(self, method, staticmethod(getattr(res, method)))


class ResourceTestCase(six.with_metaclass(ResourceTestMeta,
                                          unittest.TestCase)):
    """
    TestCase base class implementing ResourceTestMeta.

    This class is just a :class:`unitttest.TestCase` base class which
    already includes :class:`ResourceTestMeta` metaclass for convenience.

    If you need other kind of inheritance (ie, using your own base),
    just apply :class:`ResourceTestMeta` metaclass as usual.

    The following functions from :module:`importlib.resources` are
    available as :class:`staticmethod`s:
    - :func:`importlib.resources.contents` as `contents`
    - :func:`importlib.resources.is_resource` as `is_resource`
    - :func:`importlib.resources.open_binary` as `open_binary`
    - :func:`importlib.resources.open_text` as `open_text`
    - :func:`importlib.resources.path` as `path`
    - :func:`importlib.resources.read_binary` as `read_binary`
    - :func:`importlib.resources.read_text` as `read_text`
    """

    # defined here to help linters
    contents = staticmethod(res.contents)
    is_resource = staticmethod(res.is_resource)
    open_binary = staticmethod(res.open_binary)
    open_text = staticmethod(res.open_text)
    path = staticmethod(res.path)
    read_binary = staticmethod(res.read_binary)
    read_text = staticmethod(res.read_text)

    def meta_test(self, module, resource):
        # type: (str, str) -> None
        """
        Abstract method to implement tests for given module resource.

        This method is not implemented.

        :param module: resource module name
        :type module: str
        :param resource: resource name
        :type resource: str

        :raises NotImplementedError: unconditionally
        """
        raise NotImplementedError
