diff --git a/tests/api_mocks.py b/tests/api_mocks.py
index fd1e18c..cd7ce60 100644
--- a/tests/api_mocks.py
+++ b/tests/api_mocks.py
@@ -128,7 +128,8 @@ index 30d74d2..9a2c773 100644
 
 
 def success_or_failure(payload=None, body_match="query"):
-    def wrapper(mocker, status_code=200, error=None):
+    def wrapper(mocker, status_code=200, error=None, attempts=1):
+        """attempts will pass the status_code provided until the final attempt when it will pass 200"""
         if error:
             body = {'errors': error}
         else:
@@ -137,8 +138,14 @@ def success_or_failure(payload=None, body_match="query"):
         def match_body(request):
             return body_match in (request.text or '')
 
+        res = [{'json': body, 'status_code': status_code}]
+        if attempts > 1:
+            for i in range(attempts - 1):
+                if i == attempts - 2:
+                    status_code = 200
+                res.append({'json': body, 'status_code': status_code})
         return mocker.register_uri('POST', 'https://api.wandb.ai/graphql',
-                                   [{'json': body, 'status_code': status_code}], additional_matcher=match_body)
+                                   res, additional_matcher=match_body)
     return wrapper
 
 
diff --git a/tests/test_public_api.py b/tests/test_public_api.py
index 6493a1e..ac76495 100644
--- a/tests/test_public_api.py
+++ b/tests/test_public_api.py
@@ -76,6 +76,13 @@ def test_run_from_path(request_mocker, query_run_v2, query_download_h5):
     assert run.summary_metrics == {"acc": 100, "loss": 0}
 
 
+def test_run_retry(request_mocker, query_run_v2, query_download_h5):
+    run_mock = query_run_v2(request_mocker, status_code=500, attempts=3)
+    query_download_h5(request_mocker)
+    run = api.run("test/test/test")
+    assert run.summary_metrics == {"acc": 100, "loss": 0}
+
+
 def test_run_history(request_mocker, query_run_v2, query_download_h5):
     run_mock = query_run_v2(request_mocker)
     query_download_h5(request_mocker)
diff --git a/wandb/apis/internal.py b/wandb/apis/internal.py
index 8fa9a91..a99af88 100644
--- a/wandb/apis/internal.py
+++ b/wandb/apis/internal.py
@@ -191,8 +191,10 @@ class Api(object):
                     with open(upstream_patch_path, 'wb') as upstream_patch:
                         subprocess.check_call(
                             ['git', 'diff', sha], stdout=upstream_patch, cwd=root, timeout=5)
-        except (subprocess.CalledProcessError, subprocess.TimeoutExpired):
-            logger.error('Error generating diff')
+        # TODO: A customer saw `ValueError: Reference at 'refs/remotes/origin/foo' does not exist`
+        # so we now catch ValueError.  Catching this error feels too generic.
+        except (ValueError, subprocess.CalledProcessError, subprocess.TimeoutExpired) as e:
+            logger.error('Error generating diff: %s' % e)
 
     def set_current_run_id(self, run_id):
         self._current_run_id = run_id
diff --git a/wandb/apis/public.py b/wandb/apis/public.py
index 83b60e3..74422da 100644
--- a/wandb/apis/public.py
+++ b/wandb/apis/public.py
@@ -7,6 +7,7 @@ import json
 import re
 import six
 import tempfile
+import datetime
 from gql import Client, gql
 from gql.client import RetryError
 from gql.transport.requests import RequestsHTTPTransport
@@ -14,6 +15,7 @@ from gql.transport.requests import RequestsHTTPTransport
 import wandb
 from wandb import Error, __version__
 from wandb import util
+from wandb.retry import retriable
 from wandb.summary import HTTPSummary, download_h5
 from wandb.env import get_dir
 from wandb.env import get_base_url
@@ -33,6 +35,10 @@ RUN_FRAGMENT = '''fragment RunFragment on Run {
     description
     systemMetrics
     summaryMetrics
+    user {
+        name
+        username
+    }
 }'''
 
 FILE_FRAGMENT = '''fragment RunFilesFragment on Run {
@@ -56,6 +62,18 @@ FILE_FRAGMENT = '''fragment RunFilesFragment on Run {
 }'''
 
 
+class RetryingClient(object):
+    def __init__(self, client):
+        self._client = client
+
+    @retriable(retry_timedelta=datetime.timedelta(
+        seconds=10),
+        check_retry_fn=util.no_retry_auth,
+        retryable_exceptions=(RetryError, requests.RequestException))
+    def execute(self, *args, **kwargs):
+        return self._client.execute(*args, **kwargs)
+
+
 class Api(object):
     """W&B Public API
 
@@ -74,14 +92,7 @@ class Api(object):
             'base_url': get_base_url("https://api.wandb.ai")
         }
         self._runs = {}
-        self.settings.update(overrides)
-
-    def create_run(self, **kwargs):
-        return Run.create(self, **kwargs)
-
-    @property
-    def client(self):
-        return Client(
+        self._base_client = Client(
             transport=RequestsHTTPTransport(
                 headers={'User-Agent': self.user_agent},
                 use_json=True,
@@ -92,6 +103,15 @@ class Api(object):
                 url='%s/graphql' % self.settings['base_url']
             )
         )
+        self._client = RetryingClient(self._base_client)
+        self.settings.update(overrides)
+
+    def create_run(self, **kwargs):
+        return Run.create(self, **kwargs)
+
+    @property
+    def client(self):
+        return self._client
 
     @property
     def user_agent(self):
@@ -168,6 +188,27 @@ class Api(object):
         return self._runs[path]
 
 
+class Attrs(object):
+    def __init__(self, attrs):
+        self._attrs = attrs
+
+    def snake_to_camel(self, string):
+        camel = "".join([i.title() for i in string.split("_")])
+        return camel[0].lower() + camel[1:]
+
+    def __getattr__(self, name):
+        key = self.snake_to_camel(name)
+        if key == "user":
+            raise AttributeError()
+        if key in self._attrs.keys():
+            return self._attrs[key]
+        elif name in self._attrs.keys():
+            return self._attrs[name]
+        else:
+            raise AttributeError(
+                "'{}' object has no attribute '{}'".format(self.__repr__, name))
+
+
 class Paginator(object):
     QUERY = None
 
@@ -228,6 +269,11 @@ class Paginator(object):
     next = __next__
 
 
+class User(Attrs):
+    def init(self, attrs):
+        super(User, self).__init__(attrs)
+
+
 class Runs(Paginator):
     QUERY = gql('''
         query Runs($project: String!, $entity: String!, $cursor: String, $perPage: Int = 50, $order: String, $filters: JSONString) {
@@ -291,7 +337,7 @@ class Runs(Paginator):
         return "<Runs {}/{} ({})>".format(self.username, self.project, len(self))
 
 
-class Run(object):
+class Run(Attrs):
     """A single run associated with a user and project"""
 
     def __init__(self, client, username, project, name, attrs={}):
@@ -307,7 +353,7 @@ class Run(object):
         except OSError:
             pass
         self._summary = None
-        self._attrs = attrs
+        super(Run, self).__init__(attrs)
         self.state = attrs.get("state", "not found")
         self.load()
 
@@ -371,11 +417,13 @@ class Run(object):
             self._attrs = response['project']['run']
             self.state = self._attrs['state']
         self._attrs['summaryMetrics'] = json.loads(
-            self._attrs['summaryMetrics']) if self._attrs['summaryMetrics'] else {}
+            self._attrs['summaryMetrics']) if self._attrs.get('summaryMetrics') else {}
         self._attrs['systemMetrics'] = json.loads(
-            self._attrs['systemMetrics']) if self._attrs['systemMetrics'] else {}
+            self._attrs['systemMetrics']) if self._attrs.get('systemMetrics') else {}
+        if self._attrs.get('user'):
+            self.user = User(self._attrs["user"])
         config = {}
-        for key, value in six.iteritems(json.loads(self._attrs['config'] or "{}")):
+        for key, value in six.iteritems(json.loads(self._attrs.get('config') or "{}")):
             if isinstance(value, dict) and value.get("value"):
                 config[key] = value["value"]
             else:
@@ -399,10 +447,6 @@ class Run(object):
                          description=self.description, config=self.json_config)
         self.summary.update()
 
-    def snake_to_camel(self, string):
-        camel = "".join([i.title() for i in string.split("_")])
-        return camel[0].lower() + camel[1:]
-
     @property
     def json_config(self):
         config = {}
@@ -410,15 +454,6 @@ class Run(object):
             config[k] = {"value": v, "desc": None}
         return json.dumps(config)
 
-    def __getattr__(self, name):
-        key = self.snake_to_camel(name)
-        if key in self._attrs.keys():
-            return self._attrs[key]
-        elif name in self._attrs.keys():
-            return self._attrs[name]
-        else:
-            raise AttributeError("'Run' object has no attribute '%s'" % name)
-
     def _exec(self, query, **kwargs):
         """Execute a query against the cloud backend"""
         variables = {'entity': self.username,
diff --git a/wandb/tensorboard/__init__.py b/wandb/tensorboard/__init__.py
index 72b6859..2718dac 100644
--- a/wandb/tensorboard/__init__.py
+++ b/wandb/tensorboard/__init__.py
@@ -14,7 +14,11 @@ if tensorboardX_loaded:
     from tensorboardX.proto.summary_pb2 import Summary
     from tensorboardX.proto.event_pb2 import Event
 else:
-    from tensorflow.summary import Summary, Event
+    try:
+        from tensorboard.compat.proto.summary_pb2 import Summary
+        from tensorboard.compat.proto.event_pb2 import Event
+    except ImportError:
+        from tensorflow.summary import Summary, Event
 
 
 def patch(save=True, tensorboardX=tensorboardX_loaded):
