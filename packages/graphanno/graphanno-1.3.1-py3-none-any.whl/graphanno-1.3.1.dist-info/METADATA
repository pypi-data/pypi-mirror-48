Metadata-Version: 2.1
Name: graphanno
Version: 1.3.1
Summary: Create graphene ObjectType based on the type annotations.
Home-page: https://github.com/aklajnert/graphanno
Author: Andrzej Klajnert
Author-email: py@aklajnert.pl
License: MIT
Project-URL: Bug Reports, https://github.com/aklajnert/graphanno/issues
Project-URL: Source, https://github.com/aklajnert/graphanno
Keywords: graphene graphql type_annotations annotations
Platform: UNKNOWN
Classifier: Development Status :: 4 - Beta
Classifier: Intended Audience :: Developers
Classifier: Topic :: Software Development :: Code Generators
Classifier: License :: OSI Approved :: MIT License
Classifier: Programming Language :: Python :: 3 :: Only
Classifier: Programming Language :: Python :: 3.6
Classifier: Programming Language :: Python :: 3.7
Classifier: Programming Language :: Python :: 3.8
Requires-Python: >=3.6, <4
Description-Content-Type: text/markdown
Requires-Dist: graphene (<3,>=2.0)
Provides-Extra: test
Requires-Dist: pytest ; extra == 'test'
Requires-Dist: pylint ; extra == 'test'
Requires-Dist: flake8 ; extra == 'test'

# graphanno

Use Python 3.6+ type annotations to generate the graphene `ObjectType` classes.  


## Installation

You can install the project via `pip` by running:  
```bash
pip install graphanno
```

Installation from source:  
```bash
python setup.py install
```

## Usage

The `@graphanno.graph_annotations` decorator works only with classes that contains type 
annotations. If there are no type annotations within the decorator target, 
`NoAnnotationsError` exception is raised. Arguments without annotations will
be ignored.

To create the `graphene.ObjectType` object, you can just decorate your class with 
`@graphanno.graph_annotations`. 

It is recommended to subclass `graphanno.ObjectType` to provide hints for IDE's. 
This is not mandatory, the `@graphanno.graph_annotations` will replace your decorated class 
with the `ObjectType` subclass anyway.

```python
import graphene
import graphanno

# the class below...
@graphanno.graph_annotations
class Graphanno(graphanno.ObjectType):
    value: str

# ... is equivalent to:
class Graphene(graphene.ObjectType):
    value = graphene.String()
```

If you still need your class with type annotations, set `__model__` variable to annotated
class within the decorated one:

```python
import graphene
import graphanno

class Annotated: # this class will be still available later
    value: str

# the class below...
@graphanno.graph_annotations
class Graphanno(graphanno.ObjectType): 
    """
    This class can inherit from graphene.ObjectType already, 
    but it won't change the @graph_annotations behavior.
    """
    __model__ = Annotated

# ... is equivalent to:
class Graphene(graphene.ObjectType):
    value = graphene.String()
```

If another class with the same name will be decorated, the `SchemaClashError` exception
will be raised.

### Additional parameters

- `__excluded_fields__` (tuple): names of the fields that will be excluded from
schema. Private attributes are always excluded.
- `__ignore_unsupported__` (bool): do not raise an exception for unsupported annotations. 
Default `False`.

## Supported annotations

The class decorated with `@graph_annotations` can use type annotations listed below.

 - str
 - int
 - float
 - bool
 - datetime.datetime
 - datetime.date
 - datetime.time
 - typing.List
 - custom classes with supported type annotations

Using unsupported annotations will raise the `UnsupportedAnnotationError` exception. 
To ignore this exception set `__ignore_unsupported__` to `True` in the decorated class.



